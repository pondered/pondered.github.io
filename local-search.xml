<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第二章 初始化和内存清理</title>
    <link href="/posts/10/"/>
    <url>/posts/10/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化和内存清理"><a href="#初始化和内存清理" class="headerlink" title="初始化和内存清理"></a>初始化和内存清理</h1><h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><p>通过构造器，可以确保每个对象都会被初始化。没有任何参数的构造器叫做<code>默认构造器</code></p><ul><li>构造器和类同名</li><li>每个类可以用一个或以上的构造器</li><li>构造器可以有0个或多个参数</li><li>构造器没有返回值</li><li>构造器随着 <code>new</code> 操作一起调用</li></ul><h3 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h3><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h2 id="垃圾清理和回收"><a href="#垃圾清理和回收" class="headerlink" title="垃圾清理和回收"></a>垃圾清理和回收</h2><h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><h2 id="构造器初始化-1"><a href="#构造器初始化-1" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>Java入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 Java基础</title>
    <link href="/posts/5/"/>
    <url>/posts/5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><table><thead><tr><th>数据类型</th><th>代表含义</th><th>默认值</th><th>取值</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>布尔型</td><td>false</td><td>0(false) 到 1(true)</td><td>Boolean</td></tr><tr><td>byte</td><td>字节型</td><td>(byte)0</td><td>﹣128 到 127</td><td>Byte</td></tr><tr><td>char</td><td>字符型</td><td>‘\u0000’(空)</td><td>‘\u0000’ 到 ‘\uFFFF’</td><td>Character</td></tr><tr><td>short</td><td>短整数型</td><td>(short)0</td><td>-$2^{15}$ 到 $2^{15}$</td><td>Short</td></tr><tr><td>int</td><td>整数型</td><td>0</td><td>﹣$2^{31}$ 到 $2^{31}$﹣1</td><td>Integer</td></tr><tr><td>long</td><td>长整数型</td><td>0 L</td><td>﹣$2^{63}$ 到 $2^{63}$﹣1</td><td>Long</td></tr><tr><td>float</td><td>单浮点型</td><td>0.0f</td><td>1.4e-45 到 3.4e+38</td><td>Float</td></tr><tr><td>double</td><td>双浮点型</td><td>0.0d</td><td>4.9e-324 到 1. 798e+308</td><td>Double</td></tr></tbody></table><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="基本类型的作用域"><a href="#基本类型的作用域" class="headerlink" title="基本类型的作用域"></a>基本类型的作用域</h3><p>基本类型在执行完后，超过作用域时就会立即被释放。</p><blockquote><p>在作用域内定义的变量的可见性和生命周期，由花括号 <code>&#123;&#125;</code> 的位置决定。也叫代码块</p></blockquote><h3 id="对象的作用域"><a href="#对象的作用域" class="headerlink" title="对象的作用域"></a>对象的作用域</h3><p>对象和基本类型的作用域不一样。 当用 new 创建一个对象时， 它可以存活在作用域之外的。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然变量 <code>str</code> 在这个代码块运行后就消失了， 但是 <code>str</code> 所指向的 <code>String</code> 对象还是会继续占用内存空间，直到垃圾回收器检测到这个 <code>String</code> 对象没有被引用才会释放这个内存空间。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>定义了对象的外观和行为。</p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>可以是任何类型的对象。如果字段是基本数据类型，那么即便没有进行初始化，也会存在一个默认值。其他数据类型则如果没有进行初始化，默认值都为 <code>null</code>。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法只能作为类的一部分来创建。非静态(没有使用<code>static</code>)的方法只有通过对象才能被调用<br>在有些地方也叫 <code>函数</code>，表示用来做某些事情。基本形式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">返回类型 方法名称(类型<span class="hljs-number">1</span> 参数<span class="hljs-number">1</span>, 类型<span class="hljs-number">2</span> 参数<span class="hljs-number">2</span>)&#123;<br>方法体<br><span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法名和参数列表合类型起来被称为 <strong>方法签名</strong>，方法签名在当前类下必须唯一。<br><strong>注意：方法名和参数列表类型相同但是返回值不同会在编译时报错，因为返回值不是组成方法签名的条件</strong></p><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>方法参数用来指定要传递给方法什么样的信息。所以在方法参数中，必须指定每个所传递对象的类型及名字。当方法参数是基本数据类型时是 <strong>值传递</strong>，如果是其他数据类型则为 <strong>引用传递</strong>。<br>并且引用类型必须正确，即如果参数是 String类型，那么传递过来的参数也必须为 String 类型。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回类型是返回值所属的类型，如果不需要返回任何类型，那么 返回类型可以为 <code>void</code>， 这样就不需要写 <code>return 返回值;</code>。<br>如果返回类型不是 <code>void</code> 那么无论怎么返回，都必须有返回一个正确类型的返回值。</p><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>Java中的数据是通过使用操作符来操作的。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>赋值操作符 <code>=</code>。 意思是：把右边的值(右值)复制给左边(左值)的变量。右值可以是常数、变量或表达式，只要能生成一个值。 左边的值必须是一个明确的，已命名的变。同时右边计算后的类型需要和左值的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="算数"><a href="#算数" class="headerlink" title="算数"></a>算数</h2><p>分别是： <code>+ - * / %</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> b/a;<br><span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span> % <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h2 id="递增递减"><a href="#递增递减" class="headerlink" title="递增递减"></a>递增递减</h2><p><code>-- ++</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>a--;<br>a++;<br></code></pre></td></tr></table></figure><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p><code>&gt;= &lt;= &gt; &lt; != ==</code> 生成的是一个 boolean 结果</p><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p><code>与 &amp;&amp;  或 ||  非!</code></p><h3 id="短路操作"><a href="#短路操作" class="headerlink" title="短路操作"></a>短路操作</h3><p>一旦能够明确的确定整个表达式，就不会再计算表达式剩余部分。</p><h2 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">123L</span>;<br></code></pre></td></tr></table></figure><h2 id="按位"><a href="#按位" class="headerlink" title="按位"></a>按位</h2><p>二进制操作，按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。<br><code>与&amp; 或| 非~ 异或^</code></p><h2 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h2><p><code>&gt;&gt; 或 &lt;&lt;</code> 表示在二进制中 向左或向右 位移多少位。</p><h2 id="三元"><a href="#三元" class="headerlink" title="三元"></a>三元</h2><p><code>exp ? value0 : value1</code> 如果 exp 结果为 true， 就计算 value0, 如果为 false 就计算 value1</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p><code>+ +=</code></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)i;<br></code></pre></td></tr></table></figure><h1 id="控制执行流程"><a href="#控制执行流程" class="headerlink" title="控制执行流程"></a>控制执行流程</h1><h2 id="true-x2F-false"><a href="#true-x2F-false" class="headerlink" title="true&#x2F;false"></a>true&#x2F;false</h2><p>所有条件语句都是通过表达式的真假来决定执行路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>a == <span class="hljs-number">100</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>if-else 是控制程序流程的最基本形式。其中，else 是可选的，所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(布尔表达式)&#123;<br>语句<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>语句<br>&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(布尔表达式)&#123;<br>语句<br>&#125;<br></code></pre></td></tr></table></figure><p>布尔表达式的结果必须是一个布尔值，即 true&#x2F;false。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(布尔表达式)&#123;<br>语句<br>&#125;<br></code></pre></td></tr></table></figure><p>当循环开始时，会计算一次布尔表达式的值，执行完语句后，回再次计算布尔表达式</p><h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>语句<br>&#125;<span class="hljs-keyword">while</span>(布尔表达式)<br></code></pre></td></tr></table></figure><p>do-while 和 while 的区别在于， do-while 会至少执行一次，因为布尔表达式在下面，而Java 是按顺序执行的。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化;表达式;更新/步进)&#123;<br>语句<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化&#x2F;表达式&#x2F;步进 都可以为空.</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (声明语句 : 表达式) &#123;  <br>    语句<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><ol><li>指定一个方法返回什么值</li><li>退出当前方法，并返回对应的值</li></ol><h2 id="break-x2F-continue"><a href="#break-x2F-continue" class="headerlink" title="break&#x2F;continue"></a>break&#x2F;continue</h2><p>break：强行退出当前循环，不在执行当前循环中剩余的语句<br>continue：可以理解为不在执行当前循环中剩余的语句，而是继续执行下一个循环</p><h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>保留字，尽量少用甚至不用</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>在处理多个选项时， 如果使用 if&#x2F;else 结构会使得代码变长且显得有些笨拙。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <br><span class="hljs-keyword">switch</span> (x)&#123;  <br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <br>        System.out.println(<span class="hljs-number">0</span>);  <br>    <span class="hljs-keyword">break</span>;    <br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:  <br>        System.out.println(<span class="hljs-number">10</span>);  <br>    <span class="hljs-keyword">break</span>;    <br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>:  <br>        System.out.println(<span class="hljs-number">20</span>);  <br>        <span class="hljs-keyword">break</span>;    <br>    <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:  <br>        System.out.println(<span class="hljs-number">100</span>);  <br>        <span class="hljs-keyword">break</span>;    <br>    <span class="hljs-keyword">default</span>:  <br>        System.out.println(<span class="hljs-string">&quot;Not Found&quot;</span>);  <br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>case 后面跟着的内容可以为：</p><ul><li>类型为 char、byte、short 或 int 的常量表达式</li><li>枚举常量</li><li>从JDK7开始 还可以为 string 字符串</li></ul><blockquote><p>switch 底层是通过 int 来进行判断的。所以上面的所有类型都可以转换为int类型<br>字符串比较的原理是根据 字符串中的 hashCode 进行匹配。然后在执行具体的语句时，会在通过 if equals 判断两个值是否相等来防止 哈希冲突</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>Java入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo草稿(Draft)写在Posts文件夹下</title>
    <link href="/posts/2586766203/"/>
    <url>/posts/2586766203/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-草稿"><a href="#Hexo-草稿" class="headerlink" title="Hexo  草稿"></a>Hexo  草稿</h1><p>hexo在写文章时，如果不想文章发布，又不想把文章放到 <code>_drafts</code> 目录下。这时候可以在文章的头添加 <code>published: false</code> 时， Hexo 便会将 文章认为是草稿，而且可以和正常的草稿一样，当在后面添加 <code>--draft</code> 时也可以将文章显示出来。<br>当文章写完后，需要将文章发布时只需要将 <code>published</code>修改为 <code>true</code> 或者直接删除这一条就可以像正常文章一样发布。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>软件</category>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DDD详解-第一讲[转载]</title>
    <link href="/posts/485079eb/"/>
    <url>/posts/485079eb/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文为转载，原文链接为: <a href="https://juejin.cn/post/6844904177207001101">https://juejin.cn/post/6844904177207001101</a></p>          </div><h1 id="DDD详解-Domain-Primitive"><a href="#DDD详解-Domain-Primitive" class="headerlink" title="DDD详解-Domain Primitive"></a>DDD详解-Domain Primitive</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于 DDD 不是一套框架，而是一种架构思想，所以在代码层面缺乏了足够的约束，导致 DDD 在实际应用中上手门槛很高，甚至可以说绝大部分人都对 DDD 的理解有所偏差。举个例子， Martin Fowler 在他个人博客里描述的一个 Anti-pattern，<a href="https://link.juejin.cn/?target=https://martinfowler.com/bliki/AnemicDomainModel.html" title="https://martinfowler.com/bliki/AnemicDomainModel.html">Anemic Domain Model</a> <a href="/posts/2879773850/">贫血模型</a>在实际应用当中层出不穷，而一些仍然火热的 ORM 工具比如 Hibernate，Entity Framework 实际上助长了贫血模型的扩散。同样的，传统的基于数据库技术以及 MVC 的四层应用架构（UI、Business、Data Access、Database），在一定程度上和 DDD 的一些概念混淆，导致绝大部分人在实际应用当中仅仅用到了 DDD 的建模的思想，而其对于整个架构体系的思想无法落地。</p><p>我第一次接触 DDD 应该是 2012 年，当时除了大型互联网公司，基本上商业应用都还处于单机的时代，服务化的架构还局限于单机+LB 用 MVC 提供 Rest 接口供外部调用，或者用 SOAP 或 WebServices 做 RPC 调用，但其实更多局限于对外部依赖的协议。让我关注到 DDD 思想的是一个叫 Anti-Corruption Layer（防腐层）的概念，特别是其在解决外部依赖频繁变更的情况下，如何将核心业务逻辑和外部依赖隔离的机制。到了 2014 年， SOA 开始大行其道，微服务的概念开始冒头，而如何将一个 Monolith 应用合理的拆分为多个微服务成为了各大论坛的热门话题，而 DDD 里面的 Bounded Context（限界上下文）的思想为微服务拆分提供了一套合理的框架。而在今天，在一个所有的东西都能被称之为“服务”的时代（XAAS<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="一切皆服务">[1]</span></a></sup>）， DDD 的思想让我们能冷静下来，去思考到底哪些东西可以被服务化拆分，哪些逻辑需要聚合，才能带来最小的维护成本，而不是简单的去追求开发效率。</p><p>所以今天，我开始这个关于 DDD 的一系列文章，希望能继续在总结前人的基础上发扬光大 DDD 的思想，但是通过一套我认为合理的代码结构、框架和约束，来降低 DDD 的实践门槛，提升代码质量、可测试性、安全性、健壮性。</p><p>未来会覆盖的内容包括：</p><ol><li>最佳架构实践：六边形应用架构 &#x2F; Clean 架构的核心思想和落地方案</li><li>持续发现和交付：Event Storming &gt; Context Map &gt; Design Heuristics &gt; Modelling</li><li>降低架构腐败速度：通过 Anti-Corruption Layer 集成第三方库的模块化方案</li><li>标准组件的规范和边界：Entity, Aggregate, Repository, Domain Service, Application Service, Event, DTO Assembler 等</li><li>基于 Use Case 重定义应用服务的边界</li><li>基于 DDD 的微服务化改造及颗粒度控制</li><li>CQRS 架构的改造和挑战</li><li>基于事件驱动的架构的挑战</li><li>等等</li></ol><p>今天先给大家带来一篇最基础，但极其有价值的Domain Primitive的概念。</p><h2 id="Domain-Primitive"><a href="#Domain-Primitive" class="headerlink" title="Domain Primitive"></a>Domain Primitive</h2><p>就好像在学任何语言时首先需要了解的是基础数据类型一样，在全面了解 DDD 之前，首先给大家介绍一个最基础的概念: Domain Primitive（DP）。</p><p>Primitive 的定义是：<br><strong>不从任何其他事物发展而来</strong><br><strong>初级的形成或生长的早期阶段</strong></p><p>就好像 Integer、String 是所有编程语言的Primitive一样，在 DDD 里， DP 可以说是一切模型、方法、架构的基础，而就像 Integer、String 一样， DP 又是无所不在的。所以，第一讲会对 DP 做一个全面的介绍和分析，但我们先不去讲概念，而是从案例入手，看看为什么 DP 是一个强大的概念。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>我们先看一个简单的例子，这个 case 的业务逻辑如下：</p><blockquote><p>一个新应用在全国通过 地推业务员 做推广，需要做一个用户注册系统，同时希望在用户注册后能够通过用户电话（先假设仅限座机）的地域（区号）对业务员发奖金</p></blockquote><p>先不要去纠结这个根据用户电话去发奖金的业务逻辑是否合理，也先不要去管用户是否应该在注册时和业务员做绑定，这里我们看的主要还是如何更加合理的去实现这个逻辑。一个简单的用户和用户注册的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    Long userId;<br>    String name;<br>    String phone;<br>    String address;<br>    Long repId;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegistrationServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegistrationService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> SalesRepRepository salesRepRepo;<br>    <span class="hljs-keyword">private</span> UserRepository userRepo;<br><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(String name, String phone, String address)</span> <br>      <span class="hljs-keyword">throws</span> ValidationException &#123;<br>        <span class="hljs-comment">// 校验逻辑</span><br>        <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span> || name.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;name&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (phone == <span class="hljs-literal">null</span> || !isValidPhoneNumber(phone)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;phone&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 此处省略address的校验逻辑</span><br><br>        <span class="hljs-comment">// 取电话号里的区号，然后通过区号找到区域内的SalesRep</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">areaCode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        String[] areas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;0571&quot;</span>, <span class="hljs-string">&quot;021&quot;</span>, <span class="hljs-string">&quot;010&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; phone.length(); i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> phone.substring(<span class="hljs-number">0</span>, i);<br>            <span class="hljs-keyword">if</span> (Arrays.asList(areas).contains(prefix)) &#123;<br>                areaCode = prefix;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">SalesRep</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> salesRepRepo.findRep(areaCode);<br><br>        <span class="hljs-comment">// 最后创建用户，落盘，然后返回</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.name = name;<br>        user.phone = phone;<br>        user.address = address;<br>        <span class="hljs-keyword">if</span> (rep != <span class="hljs-literal">null</span>) &#123;<br>            user.repId = rep.repId;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> userRepo.save(user);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidPhoneNumber</span><span class="hljs-params">(String phone)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^0[1-9]&#123;2,3&#125;-?\\d&#123;8&#125;$&quot;</span>;<br>        <span class="hljs-keyword">return</span> phone.matches(pattern);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们日常绝大部分代码和模型其实都跟这个是类似的，乍一看貌似没啥问题，但我们再深入一步，从以下四个维度去分析一下：接口的清晰度（可阅读性）、数据验证和错误处理、业务逻辑代码的清晰度、和可测试性。</p><h3 id="问题1-接口的清晰度"><a href="#问题1-接口的清晰度" class="headerlink" title="问题1 - 接口的清晰度"></a>问题1 - 接口的清晰度</h3><p>在Java代码中，对于一个方法来说所有的参数名在编译时丢失，留下的仅仅是一个参数类型的列表，所以我们重新看一下以上的接口定义，其实在运行时仅仅是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">register</span><span class="hljs-params">(String, String, String)</span>;<br></code></pre></td></tr></table></figure><p>所以以下的代码是一段编译器完全不会报错的，很难通过看代码就能发现的 bug ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">service.register(<span class="hljs-string">&quot;殷浩&quot;</span>, <span class="hljs-string">&quot;浙江省杭州市余杭区文三西路969号&quot;</span>, <span class="hljs-string">&quot;0571-12345678&quot;</span>);<br></code></pre></td></tr></table></figure><p>当然，在真实代码中运行时会报错，但这种 bug 是在运行时被发现的，而不是在编译时。普通的 Code Review 也很难发现这种问题，很有可能是代码上线后才会被暴露出来。这里的思考是，有没有办法在编码时就避免这种可能会出现的问题？</p><p>另外一种常见的，特别是在查询服务中容易出现的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">findByName</span><span class="hljs-params">(String name)</span>;<br>User <span class="hljs-title function_">findByPhone</span><span class="hljs-params">(String phone)</span>;<br>User <span class="hljs-title function_">findByNameAndPhone</span><span class="hljs-params">(String name, String phone)</span>;<br></code></pre></td></tr></table></figure><p>在这个场景下，由于入参都是 String 类型，不得不在方法名上面加上 ByXXX 来区分，而 findByNameAndPhone 同样也会陷入前面的入参顺序错误的问题，而且和前面的入参不同，这里参数顺序如果输错了，方法不会报错只会返回 null，而这种 bug 更加难被发现。这里的思考是，有没有办法让方法入参一目了然，避免入参错误导致的 bug ？</p><h3 id="问题2-数据验证和错误处理"><a href="#问题2-数据验证和错误处理" class="headerlink" title="问题2 - 数据验证和错误处理"></a>问题2 - 数据验证和错误处理</h3><p>在前面这段数据校验代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (phone == <span class="hljs-literal">null</span> || !isValidPhoneNumber(phone)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;phone&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在日常编码中经常会出现，一般来说这种代码需要出现在方法的最前端，确保能够 fail-fast 。但是假设你有多个类似的接口和类似的入参，在每个方法里这段逻辑会被重复。而更严重的是如果未来我们要拓展电话号去包含手机时，很可能需要加入以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (phone == <span class="hljs-literal">null</span> || !isValidPhoneNumber(phone) || !isValidCellNumber(phone)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;phone&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你有很多个地方用到了 phone 这个入参，但是有个地方忘记修改了，会造成 bug 。这是一个 DRY 原则被违背时经常会发生的问题。</p><p>如果有个新的需求，需要把入参错误的原因返回，那么这段代码就变得更加复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (phone == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;phone不能为空&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isValidPhoneNumber(phone)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;phone格式错误&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以想像得到，代码里充斥着大量的类似代码块时，维护成本要有多高。</p><p>最后，在这个业务方法里，会（隐性或显性的）抛 ValidationException，所以需要外部调用方去try&#x2F;catch，而业务逻辑异常和数据校验异常被混在了一起，是否是合理的？</p><p>在传统Java架构里有几个办法能够去解决一部分问题，常见的如BeanValidation注解或ValidationUtils类，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Use Bean Validation</span><br>User <span class="hljs-title function_">registerWithBeanValidation</span><span class="hljs-params">(</span><br><span class="hljs-params">  <span class="hljs-meta">@NotNull</span> <span class="hljs-meta">@NotBlank</span> String name,</span><br><span class="hljs-params">  <span class="hljs-meta">@NotNull</span> <span class="hljs-meta">@Pattern(regexp = &quot;^0?[1-9]&#123;2,3&#125;-?\\d&#123;8&#125;$&quot;)</span> String phone,</span><br><span class="hljs-params">  <span class="hljs-meta">@NotNull</span> String address</span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">// Use ValidationUtils:</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">registerWithUtils</span><span class="hljs-params">(String name, String phone, String address)</span> &#123;<br>    ValidationUtils.validateName(name); <span class="hljs-comment">// throws ValidationException</span><br>    ValidationUtils.validatePhone(phone);<br>    ValidationUtils.validateAddress(address);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>但这几个传统的方法同样有问题：</p><p><strong>BeanValidation：</strong></p><ul><li>通常只能解决简单的校验逻辑，复杂的校验逻辑一样要写代码实现定制校验器</li><li>在添加了新校验逻辑时，同样会出现在某些地方忘记添加一个注解的情况，DRY原则还是会被违背</li></ul><p><strong>ValidationUtils类：</strong></p><ul><li>当大量的校验逻辑集中在一个类里之后，违背了Single Responsibility单一性原则，导致代码混乱和不可维护</li><li>业务异常和校验异常还是会混杂</li></ul><p>所以，有没有一种方法，能够一劳永逸的解决所有校验的问题以及降低后续的维护成本和异常处理成本呢？</p><h3 id="问题3-业务代码的清晰度"><a href="#问题3-业务代码的清晰度" class="headerlink" title="问题3 - 业务代码的清晰度"></a>问题3 - 业务代码的清晰度</h3><p>在这段代码里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">areaCode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>String[] areas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;0571&quot;</span>, <span class="hljs-string">&quot;021&quot;</span>, <span class="hljs-string">&quot;010&quot;</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; phone.length(); i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> phone.substring(<span class="hljs-number">0</span>, i);<br>    <span class="hljs-keyword">if</span> (Arrays.asList(areas).contains(prefix)) &#123;<br>        areaCode = prefix;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">SalesRep</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> salesRepRepo.findRep(areaCode);<br></code></pre></td></tr></table></figure><p>实际上出现了另外一种常见的情况，那就是从一些入参里抽取一部分数据，然后调用一个外部依赖获取更多的数据，然后通常从新的数据中再抽取部分数据用作其他的作用。这种代码通常被称作“胶水代码”，其本质是由于外部依赖的服务的入参并不符合我们原始的入参导致的。比如，如果SalesRepRepository包含一个findRepByPhone的方法，则上面大部分的代码都不必要了。</p><p>所以，一个常见的办法是将这段代码抽离出来，变成独立的一个或多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">findAreaCode</span><span class="hljs-params">(String phone)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; phone.length(); i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> phone.substring(<span class="hljs-number">0</span>, i);<br>        <span class="hljs-keyword">if</span> (isAreaCode(prefix)) &#123;<br>            <span class="hljs-keyword">return</span> prefix;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAreaCode</span><span class="hljs-params">(String prefix)</span> &#123;<br>    String[] areas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;0571&quot;</span>, <span class="hljs-string">&quot;021&quot;</span>&#125;;<br>    <span class="hljs-keyword">return</span> Arrays.asList(areas).contains(prefix);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后原始代码变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">areaCode</span> <span class="hljs-operator">=</span> findAreaCode(phone);<br><span class="hljs-type">SalesRep</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> salesRepRepo.findRep(areaCode);<br></code></pre></td></tr></table></figure><p>而为了复用以上的方法，可能会抽离出一个静态工具类 PhoneUtils 。但是这里要思考的是，静态工具类是否是最好的实现方式呢？当你的项目里充斥着大量的静态工具类，业务代码散在多个文件当中时，你是否还能找到核心的业务逻辑呢？</p><h3 id="问题4-可测试性"><a href="#问题4-可测试性" class="headerlink" title="问题4 - 可测试性"></a>问题4 - 可测试性</h3><p>为了保证代码质量，每个方法里的每个入参的每个可能出现的条件都要有 TC<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Test Case 测试用例">[2]</span></a></sup> 覆盖（假设我们先不去测试内部业务逻辑），所以在我们这个方法里需要以下的 TC：<br><img src="/posts/485079eb/images/DDD-DomainPrimitive.png" alt=""><br>假如一个方法有 N 个参数，每个参数有 M 个校验逻辑，至少要有 N * M 个 TC 。</p><p>如果这时候在该方法中加入一个新的入参字段 fax ，即使 fax 和 phone 的校验逻辑完全一致，为了保证 TC 覆盖率，也一样需要 M 个新的 TC 。</p><p>而假设有 P 个方法中都用到了 phone 这个字段，这 P 个方法都需要对该字段进行测试，也就是说整体需要：<br><strong>P * N * M</strong></p><p>个测试用例才能完全覆盖所有数据验证的问题，在日常项目中，这个测试的成本非常之高，导致大量的代码没被覆盖到。而没被测试覆盖到的代码才是最有可能出现问题的地方。</p><p>在这个情况下，降低测试成本 &#x3D;&#x3D; 提升代码质量，如何能够降低测试的成本呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们回头先重新看一下原始的 use case，并且标注其中可能重要的概念：<br>一个新应用在全国通过 地推业务员 做推广，需要做一个用户的注册系统，在用户注册后能够通过用户电话号的区号对业务员发奖金。</p><p>在分析了 use case 后，发现其中地推业务员、用户本身自带 ID 属性，属于 Entity（实体），而注册系统属于 Application Service（应用服务），这几个概念已经有存在。但是发现电话号这个概念却完全被隐藏到了代码之中。我们可以问一下自己，取电话号的区号的逻辑是否属于用户（用户的区号？）？是否属于注册服务（注册的区号？）？如果都不是很贴切，那就说明这个逻辑应该属于一个独立的概念。所以这里引入我们第一个原则：<br><strong>Make Implicit Concepts Explicit 将隐性的概念显性化</strong></p><p>在这里，我们可以看到，原来电话号仅仅是用户的一个参数，属于隐形概念，但实际上电话号的区号才是真正的业务逻辑，而我们需要将电话号的概念显性化，通过写一个 Value Object：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span> &#123;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String number;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PhoneNumber</span><span class="hljs-params">(String number)</span> &#123;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;number不能为空&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isValid(number)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;number格式错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAreaCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; number.length(); i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> number.substring(<span class="hljs-number">0</span>, i);<br>            <span class="hljs-keyword">if</span> (isAreaCode(prefix)) &#123;<br>                <span class="hljs-keyword">return</span> prefix;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAreaCode</span><span class="hljs-params">(String prefix)</span> &#123;<br>        String[] areas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;0571&quot;</span>, <span class="hljs-string">&quot;021&quot;</span>, <span class="hljs-string">&quot;010&quot;</span>&#125;;<br>        <span class="hljs-keyword">return</span> Arrays.asList(areas).contains(prefix);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String number)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^0?[1-9]&#123;2,3&#125;-?\\d&#123;8&#125;$&quot;</span>;<br>        <span class="hljs-keyword">return</span> number.matches(pattern);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里面有几个很重要的元素：</p><ul><li>通过 private final String number 确保 PhoneNumber 是一个（Immutable）Value Object。（一般来说 VO 都是 Immutable 的，这里只是重点强调一下）</li><li>校验逻辑都放在了 constructor 里面，确保只要 PhoneNumber 类被创建出来后，一定是校验通过的。</li><li>之前的 findAreaCode 方法变成了 PhoneNumber 类里的 getAreaCode ，突出了 areaCode 是 PhoneNumber 的一个计算属性。</li></ul><p>这样做完之后，我们发现把 PhoneNumber 显性化之后，其实是生成了一个 Type（数据类型）和一个 Class（类）：</p><ol><li>Type 指我们在今后的代码里可以通过 PhoneNumber 去显性的标识电话号这个概念</li><li>Class 指我们可以把所有跟电话号相关的逻辑完整的收集到一个文件里</li></ol><p>这两个概念加起来，构造成了本文标题的 Domain Primitive（DP）。</p><p>我们看一下全面使用了 DP 之后效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; <br>UserId userId; <br>Name name; <br>PhoneNumber phone; <br>Address address; <br>RepId repId; <br>&#125;<br><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Name name, <span class="hljs-meta">@NotNull</span> PhoneNumber phone, <span class="hljs-meta">@NotNull</span> Address address )</span> &#123; <br><span class="hljs-comment">// 找到区域内的SalesRep </span><br><span class="hljs-type">SalesRep</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> salesRepRepo.findRep(phone.getAreaCode());<br><br><span class="hljs-comment">// 最后创建用户，落盘，然后返回，这部分代码实际上也能用Builder解决</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>user.name = name;<br>user.phone = phone;<br>user.address = address;<br><span class="hljs-keyword">if</span> (rep != <span class="hljs-literal">null</span>) &#123;<br>    user.repId = rep.repId;<br>&#125;<br><br><span class="hljs-keyword">return</span> userRepo.saveUser(user);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到在使用了 DP 之后，所有的数据验证逻辑和非业务流程的逻辑都消失了，剩下都是核心业务逻辑，可以一目了然。我们重新用上面的四个维度评估一下：</p><h3 id="评估1-接口的清晰度"><a href="#评估1-接口的清晰度" class="headerlink" title="评估1 - 接口的清晰度"></a>评估1 - 接口的清晰度</h3><p>重构后的方法签名变成了很清晰的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(Name, PhoneNumber, Address)</span><br></code></pre></td></tr></table></figure><p>而之前容易出现的bug，如果按照现在的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">service.register(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Name</span>(<span class="hljs-string">&quot;殷浩&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;浙江省杭州市余杭区文三西路969号&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneNumber</span>(<span class="hljs-string">&quot;0571-12345678&quot;</span>));<br></code></pre></td></tr></table></figure><p>让接口 API 变得很干净，易拓展。</p><h3 id="评估2-数据验证和错误处理"><a href="#评估2-数据验证和错误处理" class="headerlink" title="评估2 - 数据验证和错误处理"></a>评估2 - 数据验证和错误处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(</span><br><span class="hljs-params">  <span class="hljs-meta">@NotNull</span> Name name,</span><br><span class="hljs-params">  <span class="hljs-meta">@NotNull</span> PhoneNumber phone,</span><br><span class="hljs-params">  <span class="hljs-meta">@NotNull</span> Address address</span><br><span class="hljs-params">)</span> <span class="hljs-comment">// no throws</span><br></code></pre></td></tr></table></figure><p>如前文代码展示的，重构后的方法里，完全没有了任何数据验证的逻辑，也不会抛 ValidationException 。原因是因为 DP 的特性，只要是能够带到入参里的一定是正确的或 null（Bean Validation 或 lombok 的注解能解决 null 的问题）。所以我们把数据验证的工作量前置到了调用方，而调用方本来就是应该提供合法数据的，所以更加合适。</p><p>再展开来看，使用DP的另一个好处就是代码遵循了 DRY 原则和单一性原则，如果未来需要修改 PhoneNumber 的校验逻辑，只需要在一个文件里修改即可，所有使用到了 PhoneNumber 的地方都会生效。</p><h3 id="评估3-业务代码的清晰度"><a href="#评估3-业务代码的清晰度" class="headerlink" title="评估3 - 业务代码的清晰度"></a>评估3 - 业务代码的清晰度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SalesRep</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> salesRepRepo.findRep(phone.getAreaCode());<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> xxx;<br><span class="hljs-keyword">return</span> userRepo.save(user);<br></code></pre></td></tr></table></figure><p>除了在业务方法里不需要校验数据之外，原来的一段胶水代码 findAreaCode 被改为了 PhoneNumber 类的一个计算属性 getAreaCode ，让代码清晰度大大提升。而且胶水代码通常都不可复用，但是使用了 DP 后，变成了可复用、可测试的代码。我们能看到，在刨除了数据验证代码、胶水代码之后，剩下的都是核心业务逻辑。（ Entity 相关的重构在后面文章会谈到，这次先忽略）</p><h3 id="评估4-可测试性"><a href="#评估4-可测试性" class="headerlink" title="评估4 - 可测试性"></a>评估4 - 可测试性</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/24/172e4116df8686e8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>当我们将 PhoneNumber 抽取出来之后，在来看测试的 TC：</p><ul><li>首先 PhoneNumber 本身还是需要 M 个测试用例，但是由于我们只需要测试单一对象，每个用例的代码量会大大降低，维护成本降低。</li><li>每个方法里的每个参数，现在只需要覆盖为 null 的情况就可以了，其他的 case 不可能发生（因为只要不是 null 就一定是合法的）<br>所以，单个方法的 TC 从原来的 N * M 变成了今天的 N + M 。同样的，多个方法的 TC 数量变成了<br><strong>N + M + P</strong></li></ul><p>这个数量一般来说要远低于原来的数量 N* M * P ，让测试成本极大的降低。</p><h3 id="评估总结"><a href="#评估总结" class="headerlink" title="评估总结"></a>评估总结</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/24/172e40bb52306b9d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>在上文我介绍了 DP 的第一个原则：将隐性的概念显性化。在这里我将介绍 DP 的另外两个原则，用一个新的案例。</p><h3 id="案例-1-转账"><a href="#案例-1-转账" class="headerlink" title="案例 1 - 转账"></a>案例 1 - 转账</h3><p>假设现在要实现一个功能，让A用户可以支付 x 元给用户 B ，可能的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(BigDecimal money, Long recipientId)</span> &#123;<br>    BankService.transfer(money, <span class="hljs-string">&quot;CNY&quot;</span>, recipientId);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这个是境内转账，并且境内的货币永远不变，该方法貌似没啥问题，但如果有一天货币变更了（比如欧元区曾经出现的问题），或者我们需要做跨境转账，该方法是明显的 bug ，因为 money 对应的货币不一定是 CNY 。</p><p>在这个 case 里，当我们说“支付 x 元”时，除了 x 本身的数字之外，实际上是有一个隐含的概念那就是货币“元”。但是在原始的入参里，之所以只用了 BigDecimal 的原因是我们认为 CNY 货币是默认的，是一个隐含的条件，但是在我们写代码时，需要把所有隐性的条件显性化，而这些条件整体组成当前的上下文。所以 DP 的第二个原则是：<br><strong>Make Implicit Context Explicit  将 隐性的 上下文 显性化</strong></p><p>所以当我们做这个支付功能时，实际上需要的一个入参是支付金额 + 支付货币。我们可以把这两个概念组合成为一个独立的完整概念：Money。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Money</span> &#123;<br>    <span class="hljs-keyword">private</span> BigDecimal amount;<br>    <span class="hljs-keyword">private</span> Currency currency;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Money</span><span class="hljs-params">(BigDecimal amount, Currency currency)</span> &#123;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>        <span class="hljs-built_in">this</span>.currency = currency;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而原有的代码则变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Money money, Long recipientId)</span> &#123;<br>    BankService.transfer(money, recipientId);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过将默认货币这个隐性的上下文概念显性化，并且和金额合并为 Money ，我们可以避免很多当前看不出来，但未来可能会暴雷的 bug。</p><h3 id="案例2-跨境转账"><a href="#案例2-跨境转账" class="headerlink" title="案例2 - 跨境转账"></a>案例2 - 跨境转账</h3><p>前面的案例升级一下，假设用户可能要做跨境转账从 CNY 到 USD ，并且货币汇率随时在波动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Money money, Currency targetCurrency, Long recipientId)</span> &#123;<br>    <span class="hljs-keyword">if</span> (money.getCurrency().equals(targetCurrency)) &#123;<br>        BankService.transfer(money, recipientId);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">rate</span> <span class="hljs-operator">=</span> ExchangeService.getRate(money.getCurrency(), targetCurrency);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">targetAmount</span> <span class="hljs-operator">=</span> money.getAmount().multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(rate));<br>        <span class="hljs-type">Money</span> <span class="hljs-variable">targetMoney</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Money</span>(targetAmount, targetCurrency);<br>        BankService.transfer(targetMoney, recipientId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个case里，由于 targetCurrency 不一定和 money 的 Curreny 一致，需要调用一个服务去取汇率，然后做计算。最后用计算后的结果做转账。</p><p>这个case最大的问题在于，金额的计算被包含在了支付的服务中，涉及到的对象也有2个 Currency ，2 个 Money ，1 个 BigDecimal ，总共 5 个对象。这种涉及到多个对象的业务逻辑，需要用 DP 包装掉，所以这里引出 DP 的第三个原则：<br><strong>Encapsulate Multi-Object Behavior  封装 多对象 行为</strong></p><p>在这个 case 里，可以将转换汇率的功能，封装到一个叫做 ExchangeRate 的 DP 里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangeRate</span> &#123;<br>    <span class="hljs-keyword">private</span> BigDecimal rate;<br>    <span class="hljs-keyword">private</span> Currency from;<br>    <span class="hljs-keyword">private</span> Currency to;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ExchangeRate</span><span class="hljs-params">(BigDecimal rate, Currency from, Currency to)</span> &#123;<br>        <span class="hljs-built_in">this</span>.rate = rate;<br>        <span class="hljs-built_in">this</span>.from = from;<br>        <span class="hljs-built_in">this</span>.to = to;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Money <span class="hljs-title function_">exchange</span><span class="hljs-params">(Money fromMoney)</span> &#123;<br>        notNull(fromMoney);<br>        isTrue(<span class="hljs-built_in">this</span>.from.equals(fromMoney.getCurrency()));<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">targetAmount</span> <span class="hljs-operator">=</span> fromMoney.getAmount().multiply(rate);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Money</span>(targetAmount, to);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ExchangeRate 汇率对象，通过封装金额计算逻辑以及各种校验逻辑，让原始代码变得极其简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Money money, Currency targetCurrency, Long recipientId)</span> &#123;<br>    <span class="hljs-type">ExchangeRate</span> <span class="hljs-variable">rate</span> <span class="hljs-operator">=</span> ExchangeService.getRate(money.getCurrency(), targetCurrency);<br>    <span class="hljs-type">Money</span> <span class="hljs-variable">targetMoney</span> <span class="hljs-operator">=</span> rate.exchange(money);<br>    BankService.transfer(targetMoney, recipientId);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="讨论和总结"><a href="#讨论和总结" class="headerlink" title="讨论和总结"></a>讨论和总结</h2><h3 id="Domain-Primitive-的定义"><a href="#Domain-Primitive-的定义" class="headerlink" title="Domain Primitive 的定义"></a>Domain Primitive 的定义</h3><p>让我们重新来定义一下 Domain Primitive ：Domain Primitive 是一个在特定领域里，拥有精准定义的、可自我验证的、拥有行为的 Value Object 。</p><ol><li>DP是一个传统意义上的Value Object，拥有Immutable的特性</li><li>DP是一个完整的概念整体，拥有精准定义</li><li>DP使用业务域中的原生语言</li><li>DP可以是业务域的最小组成部分、也可以构建复杂组合</li></ol><p>注：Domain Primitive的概念和命名来自于Dan Bergh Johnsson &amp; Daniel Deogun的书 Secure by Design。</p><h3 id="使用-Domain-Primitive-的三原则"><a href="#使用-Domain-Primitive-的三原则" class="headerlink" title="使用 Domain Primitive 的三原则"></a>使用 Domain Primitive 的三原则</h3><ul><li>让隐性的概念显性化</li><li>让隐性的上下文显性化</li><li>封装多对象行为</li></ul><h3 id="Domain-Primitive-和-DDD-里-Value-Object-的区别"><a href="#Domain-Primitive-和-DDD-里-Value-Object-的区别" class="headerlink" title="Domain Primitive 和 DDD 里 Value Object 的区别"></a>Domain Primitive 和 DDD 里 Value Object 的区别</h3><p>在 DDD 中，Value Object 这个概念其实已经存在：</p><ul><li>在 Evans 的 DDD 蓝皮书中，Value Object 更多的是一个非 Entity 的值对象</li><li>在Vernon的IDDD红皮书中，作者更多的关注了Value Object的Immutability、Equals方法、Factory方法等</li></ul><p>Domain Primitive 是 Value Object 的进阶版，在原始 VO 的基础上要求每个 DP 拥有概念的整体，而不仅仅是值对象。在 VO 的 Immutable 基础上增加了 Validity 和行为。当然同样的要求无副作用（side-effect free）。</p><h3 id="Domain-Primitive-和-Data-Transfer-Object-DTO-的区别"><a href="#Domain-Primitive-和-Data-Transfer-Object-DTO-的区别" class="headerlink" title="Domain Primitive 和 Data Transfer Object (DTO) 的区别"></a>Domain Primitive 和 Data Transfer Object (DTO) 的区别</h3><p>在日常开发中经常会碰到的另一个数据结构是 DTO ，比如方法的入参和出参。DP 和 DTO 的区别如下：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/24/172e40e778dd45fd~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h3 id="什么情况下应该用-Domain-Primitive"><a href="#什么情况下应该用-Domain-Primitive" class="headerlink" title="什么情况下应该用 Domain Primitive"></a>什么情况下应该用 Domain Primitive</h3><p>常见的 DP 的使用场景包括：</p><ol><li>有格式限制的 String：比如Name，PhoneNumber，OrderNumber，ZipCode，Address等</li><li>有限制的Integer：比如OrderId（&gt;0），Percentage（0-100%），Quantity（&gt;&#x3D;0）等</li><li>可枚举的 int ：比如 Status（一般不用Enum因为反序列化问题）</li><li>Double 或 BigDecimal：一般用到的 Double 或 BigDecimal 都是有业务含义的，比如 Temperature、Money、Amount、ExchangeRate、Rating 等</li><li>复杂的数据结构：比如 Map&lt;String, List&gt; 等，尽量能把 Map 的所有操作包装掉，仅暴露必要行为</li></ol><h2 id="实战-老应用重构的流程"><a href="#实战-老应用重构的流程" class="headerlink" title="实战 - 老应用重构的流程"></a>实战 - 老应用重构的流程</h2><p>在新应用中使用 DP 是比较简单的，但在老应用中使用 DP 是可以遵循以下流程按部就班的升级。在此用本文的第一个 case 为例。</p><h3 id="第一步-创建-Domain-Primitive，收集所有-DP-行为"><a href="#第一步-创建-Domain-Primitive，收集所有-DP-行为" class="headerlink" title="第一步 - 创建 Domain Primitive，收集所有 DP 行为"></a>第一步 - 创建 Domain Primitive，收集所有 DP 行为</h3><p>在前文中，我们发现取电话号的区号这个是一个可以独立出来的、可以放入 PhoneNumber 这个 Class 的逻辑。类似的，在真实的项目中，以前散落在各个服务或工具类里面的代码，可以都抽出来放在 DP 里，成为 DP 自己的行为或属性。这里面的原则是：所有抽离出来的方法要做到无状态，比如原来是 static 的方法。如果原来的方法有状态变更，需要将改变状态的部分和不改状态的部分分离，然后将无状态的部分融入 DP 。因为 DP 本身不能带状态，所以一切需要改变状态的代码都不属于 DP 的范畴。<br>(代码参考 PhoneNumber 的代码，这里不再重复)</p><h3 id="第二步-替换数据校验和无状态逻辑"><a href="#第二步-替换数据校验和无状态逻辑" class="headerlink" title="第二步 - 替换数据校验和无状态逻辑"></a>第二步 - 替换数据校验和无状态逻辑</h3><p>为了保障现有方法的兼容性，在第二步不会去修改接口的签名，而是通过代码替换原有的校验逻辑和根 DP 相关的业务逻辑。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(String name, String phone, String address)</span><br>        <span class="hljs-keyword">throws</span> ValidationException &#123;<br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span> || name.length() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;name&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (phone == <span class="hljs-literal">null</span> || !isValidPhoneNumber(phone)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationException</span>(<span class="hljs-string">&quot;phone&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">areaCode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    String[] areas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;0571&quot;</span>, <span class="hljs-string">&quot;021&quot;</span>, <span class="hljs-string">&quot;010&quot;</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; phone.length(); i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> phone.substring(<span class="hljs-number">0</span>, i);<br>        <span class="hljs-keyword">if</span> (Arrays.asList(areas).contains(prefix)) &#123;<br>            areaCode = prefix;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">SalesRep</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> salesRepRepo.findRep(areaCode);<br>    <span class="hljs-comment">// 其他代码...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过 DP 替换代码后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(String name, String phone, String address)</span><br>        <span class="hljs-keyword">throws</span> ValidationException &#123;<br>    <br>    <span class="hljs-type">Name</span> <span class="hljs-variable">_name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Name</span>(name);<br>    <span class="hljs-type">PhoneNumber</span> <span class="hljs-variable">_phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneNumber</span>(phone);<br>    <span class="hljs-type">Address</span> <span class="hljs-variable">_address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(address);<br>    <br>    <span class="hljs-type">SalesRep</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> salesRepRepo.findRep(_phone.getAreaCode());<br>    <span class="hljs-comment">// 其他代码...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过 new PhoneNumber(phone) 这种代码，替代了原有的校验代码。<br>通过  phone. getAreaCode() 替换了原有的无状态的业务逻辑</p><h3 id="第三步-创建新接口"><a href="#第三步-创建新接口" class="headerlink" title="第三步 - 创建新接口"></a>第三步 - 创建新接口</h3><p>创建新接口，将 DP 的代码提升到接口参数层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(Name name, PhoneNumber phone, Address address)</span> &#123;<br>    <span class="hljs-type">SalesRep</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> salesRepRepo.findRep(phone.getAreaCode());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四步-修改外部调用"><a href="#第四步-修改外部调用" class="headerlink" title="第四步 - 修改外部调用"></a>第四步 - 修改外部调用</h3><p>外部调用方需要修改调用链路，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">service.register(<span class="hljs-string">&quot;殷浩&quot;</span>, <span class="hljs-string">&quot;0571-12345678&quot;</span>, <span class="hljs-string">&quot;浙江省杭州市余杭区文三西路969号&quot;</span>);<br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">service.register(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Name</span>(<span class="hljs-string">&quot;殷浩&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneNumber</span>(<span class="hljs-string">&quot;0571-12345678&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;浙江省杭州市余杭区文三西路969号&quot;</span>));<br></code></pre></td></tr></table></figure><p>通过以上 4 步，就能让你的代码变得更加简洁、优雅、健壮、安全。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>一切皆服务<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Test Case 测试用例<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>DDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>转载</tag>
      
      <tag>DDD详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD详解-第五讲[转载]</title>
    <link href="/posts/817307754/"/>
    <url>/posts/817307754/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文为转载，原文链接为: <a href="https://juejin.cn/post/6953141151931039758">https://juejin.cn/post/6953141151931039758</a></p>          </div><h1 id="DDD-详解-聊聊如何避免写流水账代码"><a href="#DDD-详解-聊聊如何避免写流水账代码" class="headerlink" title="DDD 详解-聊聊如何避免写流水账代码"></a>DDD 详解-聊聊如何避免写流水账代码</h1><h2 id="案例简介"><a href="#案例简介" class="headerlink" title="案例简介"></a>案例简介</h2><p>这里举一个简单的常见案例：下单链路。假设我们在做一个checkout接口，需要做各种校验、查询商品信息、调用库存服务扣库存、然后生成订单：<br><img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927180137.png" alt=""></p><p>一个比较典型的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckoutController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ItemService itemService;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> InventoryService inventoryService;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> OrderRepository orderRepository;<br><br>    <span class="hljs-meta">@PostMapping(&quot;checkout&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;OrderDO&gt; <span class="hljs-title function_">checkout</span><span class="hljs-params">(Long itemId, Integer quantity)</span> &#123;<br>        <span class="hljs-comment">// 1) Session管理</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> SessionUtils.getLoggedInUserId();<br>        <span class="hljs-keyword">if</span> (userId &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;Not Logged In&quot;</span>);<br>        &#125;<br><br>      <span class="hljs-comment">// 2）参数校验</span><br>        <span class="hljs-keyword">if</span> (itemId &lt;= <span class="hljs-number">0</span> || quantity &lt;= <span class="hljs-number">0</span> || quantity &gt;= <span class="hljs-number">1000</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;Invalid Args&quot;</span>);<br>        &#125;<br><br>      <span class="hljs-comment">// 3）外部数据补全</span><br>        <span class="hljs-type">ItemDO</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> itemService.getItem(itemId);<br>        <span class="hljs-keyword">if</span> (item == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;Item Not Found&quot;</span>);<br>        &#125;<br><br>      <span class="hljs-comment">// 4）调用外部服务</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">withholdSuccess</span> <span class="hljs-operator">=</span> inventoryService.withhold(itemId, quantity);<br>        <span class="hljs-keyword">if</span> (!withholdSuccess) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;Inventory not enough&quot;</span>);<br>        &#125;<br>      <br>      <span class="hljs-comment">// 5）领域计算</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> item.getPriceInCents() * quantity;<br><br>        <span class="hljs-comment">// 6）领域对象操作</span><br>        <span class="hljs-type">OrderDO</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDO</span>();<br>        order.setItemId(itemId);<br>        order.setBuyerId(userId);<br>        order.setSellerId(item.getSellerId());<br>        order.setCount(quantity);<br>        order.setTotalCost(cost);<br><br>        <span class="hljs-comment">// 7）数据持久化</span><br>        orderRepository.createOrder(order);<br><br>        <span class="hljs-comment">// 8）返回</span><br>        <span class="hljs-keyword">return</span> Result.success(order);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么这种典型的流水账代码在实际应用中会有问题呢？其本质问题是违背了SRP（Single Responsbility Principle）单一职责原则。这段代码里混杂了业务计算、校验逻辑、基础设施、和通信协议等，在未来无论哪一部分的逻辑变更都会直接影响到这段代码，长期当后人不断的在上面叠加新的逻辑时，会造成代码复杂度增加、逻辑分支越来越多，最终造成bug或者没人敢重构的历史包袱。</p><p>所以我们才需要用DDD的分层思想去重构一下以上的代码，通过不同的代码分层和规范，拆分出逻辑清晰，职责明确的分层和模块，也便于一些通用能力的沉淀。</p><p>主要的几个步骤分为：</p><ol><li>分离出独立的Interface接口层，负责处理网络协议相关的逻辑</li><li>从真实业务场景中，找出具体用例（Use Cases），然后将具体用例通过专用的Command指令、Query查询、和Event事件对象来承接</li><li>分离出独立的Application应用层，负责业务流程的编排，响应Command、Query和Event。每个应用层的方法应该代表整个业务流程中的一个节点</li><li>处理一些跨层的横切关注点，如鉴权、异常处理、校验、缓存、日志等</li></ol><p>下面会针对每个点做详细的解释。</p><h2 id="Interface接口层"><a href="#Interface接口层" class="headerlink" title="Interface接口层"></a>Interface接口层</h2><p>随着REST和MVC架构的普及，经常能看到开发同学直接在Controller中写业务逻辑，如上面的典型案例，但实际上MVC Controller不是唯一的重灾区。以下的几种常见的代码写法通常都可能包含了同样的问题：</p><ul><li>HTTP 框架：如Spring MVC框架，Spring Cloud等</li><li>RPC 框架：如Dubbo、HSF、gRPC等</li><li>消息队列MQ的“消费者”：比如JMS的 onMessage，RocketMQ的MessageListener等</li><li>Socket通信：Socket通信的receive、WebSocket的onMessage等</li><li>文件系统：WatcherService等</li><li>分布式任务调度：SchedulerX等<br>这些的方法都有一个共同的点就是都有自己的网络协议，而如果我们的业务代码和网络协议混杂在一起，则会直接导致代码跟网络协议绑定，无法被复用。 所以，在DDD的分层架构中，我们单独会抽取出来Interface接口层，作为所有对外的门户，将网络协议和业务逻辑解耦。</li></ul><h3 id="接口层的组成"><a href="#接口层的组成" class="headerlink" title="接口层的组成"></a>接口层的组成</h3><p>接口层主要由以下几个功能组成：</p><ol><li>网络协议的转化：通常这个已经由各种框架给封装掉了，我们需要构建的类要么是被注解的bean，要么是继承了某个接口的bean。</li><li>统一鉴权：比如在一些需要AppKey+Secret的场景，需要针对某个租户做鉴权的，包括一些加密串的校验</li><li>Session管理：一般在面向用户的接口或者有登陆态的，通过Session或者RPC上下文可以拿到当前调用的用户，以便传递给下游服务。</li><li>限流配置：对接口做限流避免大流量打到下游服务</li><li>前置缓存：针对变更不是很频繁的只读场景，可以前置结果缓存到接口层</li><li>异常处理：通常在接口层要避免将异常直接暴露给调用端，所以需要在接口层做统一的异常捕获，转化为调用端可以理解的数据格式</li><li>日志：在接口层打调用日志，用来做统计和debug等。一般微服务框架可能都直接包含了这些功能。<br>当然，如果有一个独立的网关设施&#x2F;应用，则可以抽离出鉴权、Session、限流、日志等逻辑，但是目前来看API网关也只能解决一部分的功能，即使在有API网关的场景下，应用里独立的接口层还是有必要的。 在interface层，鉴权、Session、限流、缓存、日志等都比较直接，只有一个异常处理的点需要重点说下。</li></ol><h3 id="返回值和异常处理规范，Result-vs-Exception"><a href="#返回值和异常处理规范，Result-vs-Exception" class="headerlink" title="返回值和异常处理规范，Result vs Exception"></a>返回值和异常处理规范，Result vs Exception</h3><p>注：这部分主要还是面向REST和RPC接口，其他的协议需要根据协议的规范产生返回值。</p><p>在我见过的一些代码里，接口的返回值比较多样化，有些直接返回DTO甚至DO，另一些返回Result。 接口层的核心价值是对外，所以如果只是返回DTO或DO会不可避免的面临异常和错误栈泄漏到使用方的情况，包括错误栈被序列化反序列化的消耗。所以，这里提出一个规范：</p><blockquote><p>规范：Interface层的HTTP和RPC接口，返回值为Result，捕捉所有异常<br>规范：Application层的所有接口返回值为DTO，不负责处理异常</p></blockquote><p>Application层的具体规范等下再讲，在这里先展示Interface层的逻辑。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;checkout&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;OrderDTO&gt; <span class="hljs-title function_">checkout</span><span class="hljs-params">(Long itemId, Integer quantity)</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">CheckoutCommand</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckoutCommand</span>();<br><span class="hljs-type">OrderDTO</span> <span class="hljs-variable">orderDTO</span> <span class="hljs-operator">=</span> checkoutService.checkout(cmd);    <br><span class="hljs-keyword">return</span> Result.success(orderDTO);<br>  &#125; <span class="hljs-keyword">catch</span> (ConstraintViolationException cve) &#123;<br>        <span class="hljs-comment">// 捕捉一些特殊异常，比如Validation异常</span><br>      <span class="hljs-keyword">return</span> Result.fail(cve.getMessage());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 兜底异常捕获</span><br>    <span class="hljs-keyword">return</span> Result.fail(e.getMessage());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，每个接口都要写异常处理逻辑会比较烦，所以可以用AOP做个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ResultHandler &#123;<br><br>&#125;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultAspect</span> &#123;<br>    <span class="hljs-meta">@Around(&quot;@annotation(ResultHandler)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">logExecutionTime</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            proceed = joinPoint.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (ConstraintViolationException cve) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(cve.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(e.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后最终代码则简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;checkout&quot;)</span><br><span class="hljs-meta">@ResultHandler</span><br><span class="hljs-keyword">public</span> Result&lt;OrderDTO&gt; <span class="hljs-title function_">checkout</span><span class="hljs-params">(Long itemId, Integer quantity)</span> &#123;<br>    <span class="hljs-type">CheckoutCommand</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckoutCommand</span>();<br>    <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">orderDTO</span> <span class="hljs-operator">=</span> checkoutService.checkout(cmd);<br>    <span class="hljs-keyword">return</span> Result.success(orderDTO);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口层的接口的数量和业务间的隔离"><a href="#接口层的接口的数量和业务间的隔离" class="headerlink" title="接口层的接口的数量和业务间的隔离"></a>接口层的接口的数量和业务间的隔离</h3><p>在传统REST和RPC的接口规范中，通常一个领域的接口，无论是REST的Resource资源的GET&#x2F;POST&#x2F;DELETE，还是RPC的方法，是追求相对固定的，统一的，而且会追求统一个领域的方法放在一个领域的服务或Controller中。</p><p>但是我发现在实际做业务的过程中，特别是当支撑的上游业务比较多时，刻意去追求接口的统一通常会导致方法中的参数膨胀，或者导致方法的膨胀。举个例子：假设有一个宠物卡和一个亲子卡的业务公用一个开卡服务，但是宠物需要传入宠物类型，亲子的需要传入宝宝年龄。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以是RPC Provider 或者 Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CardService</span> &#123;<br><br>    <span class="hljs-comment">// 1）统一接口，参数膨胀</span><br>    Result <span class="hljs-title function_">openCard</span><span class="hljs-params">(<span class="hljs-type">int</span> petType, <span class="hljs-type">int</span> babyAge)</span>;<br><br>    <span class="hljs-comment">// 2）统一泛化接口，参数语意丢失</span><br>    Result <span class="hljs-title function_">openCardV2</span><span class="hljs-params">(Map&lt;String, Object&gt; params)</span>;<br><br>    <span class="hljs-comment">// 3）不泛化，同一个类里的接口膨胀</span><br>    Result <span class="hljs-title function_">openPetCard</span><span class="hljs-params">(<span class="hljs-type">int</span> petType)</span>;<br>    Result <span class="hljs-title function_">openBabyCard</span><span class="hljs-params">(<span class="hljs-type">int</span> babyAge)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出来，无论是怎么操作，都有可能导致CardService这个服务未来越来越难以维护，方法越来越多，一个业务的变更有可能会导致整个服务&#x2F;Controller的变更，最终变得无法维护。我曾经参与过的一个服务，提供了几十个方法，上万行代码，可想而知无论是使用方对接口的理解成本还是对代码的维护成本都是极高的。 所以，这里提出另一个规范：</p><blockquote><p>规范：一个Interface层的类应该是“小而美”的，应该是面向“一个单一的业务”或“一类同样需求的业务”，需要尽量避免用同一个类承接不同类型业务的需求。</p></blockquote><p>基于上面的这个规范，可以发现宠物卡和亲子卡虽然看起来像是类似的需求，但并非是“同样需求”的，可以预见到在未来的某个时刻，这两个业务的需求和需要提供的接口会越走越远，所以需要将这两个接口类拆分开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PetCardService</span> &#123;<br>    Result <span class="hljs-title function_">openPetCard</span><span class="hljs-params">(<span class="hljs-type">int</span> petType)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BabyCardService</span> &#123;<br>    Result <span class="hljs-title function_">openBabyCard</span><span class="hljs-params">(<span class="hljs-type">int</span> babyAge)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个的好处是符合了Single Responsibility Principle单一职责原则，也就是说一个接口类仅仅会因为一个（或一类）业务的变化而变化。一个建议是当一个现有的接口类过度膨胀时，可以考虑对接口类做拆分，拆分原则和SRP一致。</p><p>也许会有人问，如果按照这种做法，会不会产生大量的接口类，导致代码逻辑重复？答案是不会，因为在DDD分层架构里，接口类的核心作用仅仅是协议层，每类业务的协议可以是不同的，而真实的业务逻辑会沉淀到应用层。也就是说Interface和Application的关系是多对多的：<br><img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927180357.png" alt=""></p><p>因为业务需求是快速变化的，所以接口层也要跟着快速变化，通过独立的接口层可以避免业务间相互影响，但我们希望相对稳定的是Application层的逻辑。所以我们接下来看一下Application层的一些规范。</p><h2 id="Application层"><a href="#Application层" class="headerlink" title="Application层"></a>Application层</h2><h3 id="Application层的组成部分"><a href="#Application层的组成部分" class="headerlink" title="Application层的组成部分"></a>Application层的组成部分</h3><p>Application层的几个核心类：</p><ul><li>ApplicationService应用服务：最核心的类，负责业务流程的编排，但本身不负责任何业务逻辑</li><li>DTO Assembler：负责将内部领域模型转化为可对外的DTO</li><li>Command、Query、Event对象：作为ApplicationService的入参</li><li>返回的DTO：作为ApplicationService的出参<br>Application层最核心的对象是ApplicationService，它的核心功能是承接“业务流程“。但是在讲ApplicationService的规范之前，必须要先重点的讲几个特殊类型的对象，即Command、Query和Event。</li></ul><h3 id="Command、Query、Event对象"><a href="#Command、Query、Event对象" class="headerlink" title="Command、Query、Event对象"></a>Command、Query、Event对象</h3><p>从本质上来看，这几种对象都是Value Object，但是从语义上来看有比较大的差异：</p><ul><li>Command指令：指调用方明确想让系统操作的指令，其预期是对一个系统有影响，也就是写操作。通常来讲指令需要有一个明确的返回值（如同步的操作结果，或异步的指令已经被接受）。</li><li>Query查询：指调用方明确想查询的东西，包括查询参数、过滤、分页等条件，其预期是对一个系统的数据完全不影响的，也就是只读操作。</li><li>Event事件：指一件已经发生过的既有事实，需要系统根据这个事实作出改变或者响应的，通常事件处理都会有一定的写操作。事件处理器不会有返回值。这里需要注意一下的是，Application层的Event概念和Domain层的DomainEvent是类似的概念，但不一定是同一回事，这里的Event更多是外部一种通知机制而已。</li></ul><p>简单总结下：</p><table><thead><tr><th></th><th align="center">Command</th><th>Query</th><th>Event</th></tr></thead><tbody><tr><td>语义</td><td align="center">“希望”能出发的操作</td><td>各种条件查询</td><td>已经发生过的事情</td></tr><tr><td>读&#x2F;写</td><td align="center">写</td><td>只读</td><td>通常是写</td></tr><tr><td>返回值</td><td align="center">DTO或Boolean</td><td>DTO或Collection</td><td>Void</td></tr></tbody></table><h4 id="为什么要用CQE对象？"><a href="#为什么要用CQE对象？" class="headerlink" title="为什么要用CQE对象？"></a>为什么要用CQE对象？</h4><p>通常在很多代码里，能看到接口上有多个参数，比如上文中的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Result&lt;OrderDO&gt; <span class="hljs-title function_">checkout</span><span class="hljs-params">(Long itemId, Integer quantity)</span>;<br></code></pre></td></tr></table></figure><p>如果需要在接口上增加参数，考虑到向前兼容，则需要增加一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Result&lt;OrderDO&gt; <span class="hljs-title function_">checkout</span><span class="hljs-params">(Long itemId, Integer quantity)</span>;<br>Result&lt;OrderDO&gt; <span class="hljs-title function_">checkout</span><span class="hljs-params">(Long itemId, Integer quantity, Integer channel)</span>;<br></code></pre></td></tr></table></figure><p>或者常见的查询方法，由于条件的不同导致多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;OrderDO&gt; <span class="hljs-title function_">queryByItemId</span><span class="hljs-params">(Long itemId)</span>;<br>List&lt;OrderDO&gt; <span class="hljs-title function_">queryBySellerId</span><span class="hljs-params">(Long sellerId)</span>;<br>List&lt;OrderDO&gt; <span class="hljs-title function_">queryBySellerIdWithPage</span><span class="hljs-params">(Long sellerId, <span class="hljs-type">int</span> currentPage, <span class="hljs-type">int</span> pageSize)</span>;<br></code></pre></td></tr></table></figure><p>可以看出来，传统的接口写法有几个问题：</p><ol><li>接口膨胀：一个查询条件一个方法</li><li>难以扩展：每新增一个参数都有可能需要调用方升级</li><li>难以测试：接口一多，职责随之变得繁杂，业务场景各异，测试用例难以维护 但是另外一个最重要的问题是：这种类型的参数罗列，本身没有任何业务上的”语意“，只是一堆参数而已，无法明确的表达出来意图。</li></ol><h4 id="CQE的规范："><a href="#CQE的规范：" class="headerlink" title="CQE的规范："></a>CQE的规范：</h4><p>所以在Application层的接口里，强力建议的一个规范是：</p><blockquote><p>规范：ApplicationService的接口入参只能是一个Command、Query或Event对象，CQE对象需要能代表当前方法的语意。唯一可以的例外是根据单一ID查询的情况，可以省略掉一个Query对象的创建</p></blockquote><p>按照上面的规范，实现案例是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CheckoutService</span> &#123;<br>    OrderDTO <span class="hljs-title function_">checkout</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> CheckoutCommand cmd)</span>;<br>    List&lt;OrderDTO&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(OrderQuery query)</span>;<br>    OrderDTO <span class="hljs-title function_">getOrder</span><span class="hljs-params">(Long orderId)</span>; <span class="hljs-comment">// 注意单一ID查询可以不用Query</span><br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckoutCommand</span> &#123;<br>    <span class="hljs-keyword">private</span> Long userId;<br>    <span class="hljs-keyword">private</span> Long itemId;<br>    <span class="hljs-keyword">private</span> Integer quantity;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderQuery</span> &#123;<br>    <span class="hljs-keyword">private</span> Long sellerId;<br>    <span class="hljs-keyword">private</span> Long itemId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> currentPage;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pageSize;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个规范的好处是：提升了接口的稳定性、降低低级的重复，并且让接口入参更加语意化。</p><h4 id="CQE-vs-DTO"><a href="#CQE-vs-DTO" class="headerlink" title="CQE vs DTO"></a>CQE vs DTO</h4><p>从上面的代码能看出来，ApplicationService的入参是CQE对象，但是出参却是一个DTO，从代码格式上来看都是简单的POJO对象，那么他们之间有什么区别呢？</p><ul><li>CQE：CQE对象是ApplicationService的输入，是有明确的”意图“的，所以这个对象必须保证其”正确性“。</li><li>DTO：DTO对象只是数据容器，只是为了和外部交互，所以本身不包含任何逻辑，只是贫血对象。<br>但可能最重要的一点：因为CQE是”意图“，所以CQE对象在理论上可以有”无限“个，每个代表不同的意图；但是DTO作为模型数据容器，和模型一一对应，所以是有限的。</li></ul><h4 id="CQE的校验"><a href="#CQE的校验" class="headerlink" title="CQE的校验"></a>CQE的校验</h4><p>CQE作为ApplicationService的输入，必须保证其正确性，那么这个校验是放在哪里呢？ 在最早的代码里，曾经有这样的校验逻辑，当时写在了服务里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (itemId &lt;= <span class="hljs-number">0</span> || quantity &lt;= <span class="hljs-number">0</span> || quantity &gt;= <span class="hljs-number">1000</span>) &#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;Invalid Args&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种代码在日常非常常见，但其最大的问题就是大量的非业务代码混杂在业务代码中，很明显的违背了单一职责原则。但因为当时入参仅仅是简单的int，所以这个逻辑只能出现在服务里。现在当入参改为了CQE之后，我们可以利用java标准JSR303或JSR380的Bean Validation来前置这个校验逻辑。</p><blockquote><p>规范：CQE对象的校验应该前置，避免在ApplicationService里做参数的校验。可以通过JSR303&#x2F;380和Spring Validation来实现</p></blockquote><p>前面的例子可以改造为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Validated</span> <span class="hljs-comment">// Spring的注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckoutServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CheckoutService</span> &#123;<br>    OrderDTO <span class="hljs-title function_">checkout</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> CheckoutCommand cmd)</span> &#123; <span class="hljs-comment">// 这里@Valid是JSR-303/380的注解</span><br>        <span class="hljs-comment">// 如果校验失败会抛异常，在interface层被捕捉</span><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckoutCommand</span> &#123;<br><br>    <span class="hljs-meta">@NotNull(message = &quot;用户未登陆&quot;)</span><br>    <span class="hljs-keyword">private</span> Long userId;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Positive(message = &quot;需要是合法的itemId&quot;)</span><br>    <span class="hljs-keyword">private</span> Long itemId;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Min(value = 1, message = &quot;最少1件&quot;)</span><br>    <span class="hljs-meta">@Max(value = 1000, message = &quot;最多不能超过1000件&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer quantity;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种做法的好处是，让ApplicationService更加清爽，同时各种错误信息可以通过Bean Validation的API做各种个性化定制。</p><h4 id="避免复用CQE"><a href="#避免复用CQE" class="headerlink" title="避免复用CQE"></a>避免复用CQE</h4><p>因为CQE是有“意图”和“语意”的，我们需要尽量避免CQE对象的复用，哪怕所有的参数都一样，只要他们的语意不同，尽量还是要用不同的对象。</p><blockquote><p>规范：针对于不同语意的指令，要避免CQE对象的复用</p></blockquote><p>❌ 反例：一个常见的场景是“Create创建”和“Update更新”，一般来说这两种类型的对象唯一的区别是一个ID，创建没有ID，而更新则有。所以经常能看见有的同学用同一个对象来作为两个方法的入参，唯一区别是ID是否赋值。这个是错误的用法，因为这两个操作的语意完全不一样，他们的校验条件可能也完全不一样，所以不应该复用同一个对象。正确的做法是产出两个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CheckoutService</span> &#123;<br>    OrderDTO <span class="hljs-title function_">checkout</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> CheckoutCommand cmd)</span>;<br>    OrderDTO <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> UpdateOrderCommand cmd)</span>;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateOrderCommand</span> &#123;<br><br>    <span class="hljs-meta">@NotNull(message = &quot;用户未登陆&quot;)</span><br>    <span class="hljs-keyword">private</span> Long userId;<br><br>    <span class="hljs-meta">@NotNull(message = &quot;必须要有OrderID&quot;)</span><br>    <span class="hljs-keyword">private</span> Long orderId;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Positive(message = &quot;需要是合法的itemId&quot;)</span><br>    <span class="hljs-keyword">private</span> Long itemId;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Min(value = 1, message = &quot;最少1件&quot;)</span><br>    <span class="hljs-meta">@Max(value = 1000, message = &quot;最多不能超过1000件&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer quantity;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ApplicationService"><a href="#ApplicationService" class="headerlink" title="ApplicationService"></a>ApplicationService</h3><p>ApplicationService负责了业务流程的编排，是将原有业务流水账代码剥离了校验逻辑、领域计算、持久化等逻辑之后剩余的流程，是“胶水层”代码。</p><p>参考一个简易的交易流程：<br><img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927181018.png" alt=""><br>在这个案例里可以看出来，交易这个领域一共有5个用例：下单、支付成功、支付失败关单、物流信息更新、关闭订单。这5个用例可以用5个Command&#x2F;Event对象代替，也就是对应了5个方法。</p><p>我见过3种ApplicationService的组织形态：</p><ol><li><p>一个ApplicationService类是一个完整的业务流程，其中每个方法负责处理一个Use Case。这种的好处是可以完整的收敛整个业务逻辑，从接口类即可对业务逻辑有一定的掌握，适合相对简单的业务流程。坏处就是对于复杂的业务流程会导致一个类的方法过多，有可能代码量过大。这种类型的具体案例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CheckoutService</span> &#123;<br><br>    <span class="hljs-comment">// 下单</span><br>    OrderDTO <span class="hljs-title function_">checkout</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> CheckoutCommand cmd)</span>;<br><br>    <span class="hljs-comment">// 支付成功</span><br>    OrderDTO <span class="hljs-title function_">payReceived</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> PaymentReceivedEvent event)</span>;<br><br>    <span class="hljs-comment">// 支付取消</span><br>    OrderDTO <span class="hljs-title function_">payCanceled</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> PaymentCanceledEvent event)</span>;<br><br>    <span class="hljs-comment">// 发货</span><br>    OrderDTO <span class="hljs-title function_">packageSent</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> PackageSentEvent event)</span>;<br><br>    <span class="hljs-comment">// 收货</span><br>    OrderDTO <span class="hljs-title function_">delivered</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> DeliveredEvent event)</span>;<br><br>    <span class="hljs-comment">// 批量查询</span><br>    List&lt;OrderDTO&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(OrderQuery query)</span>;<br><br>    <span class="hljs-comment">// 单个查询</span><br>    OrderDTO <span class="hljs-title function_">getOrder</span><span class="hljs-params">(Long orderId)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>针对于比较复杂的业务流程，可以通过增加独立的CommandHandler、EventHandler来降低一个类中的代码量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckoutCommandHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandHandler</span>&lt;CheckoutCommand, OrderDTO&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">handle</span><span class="hljs-params">(CheckoutCommand cmd)</span> &#123;<br>    <span class="hljs-comment">//</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckoutServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CheckoutService</span> &#123;<br>  <span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> CheckoutCommandHandler checkoutCommandHandler;<br>  <br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">checkout</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> CheckoutCommand cmd)</span> &#123;<br>        <span class="hljs-keyword">return</span> checkoutCommandHandler.handle(cmd);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>比较激进一点，通过CommandBus、EventBus，直接将指令或事件抛给对应的Handler，EventBus比较常见。具体案例代码如下，通过消息队列收到MQ消息后，生成Event，然后由EventBus做路由到对应的Handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Application层</span><br><span class="hljs-comment">// 在这里框架通常可以根据接口识别到这个负责处理PaymentReceivedEvent</span><br><span class="hljs-comment">// 也可以通过增加注解识别</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentReceivedHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventHandler</span>&lt;PaymentReceivedEvent&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(PaymentReceivedEvent event)</span> &#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Interface层，这个是RocketMQ的Listener</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderMessageListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MessageListenerOrderly</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> EventBus eventBus;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ConsumeOrderlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;<br>      <br>        <span class="hljs-type">PaymentReceivedEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaymentReceivedEvent</span>();<br>        eventBus.dispatch(event); <span class="hljs-comment">// 不需要指定消费者</span><br>        <br>        <span class="hljs-keyword">return</span> ConsumeOrderlyStatus.SUCCESS;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure></li></ol><p>⚠️ 不建议：这种做法可以实现Interface层和某个具体的ApplicationService或Handler的完全静态解藕，在运行时动态dispatch，做的比较好的框架如AxonFramework。虽然看起来很便利，但是根据我们自己业务的实践和踩坑发现，当代码中的CQE对象越来越多，handler越来越复杂时，运行时的dispatch缺乏了静态代码间的关联关系，导致代码很难读懂，特别是当你需要trace一个复杂调用链路时，因为dispatch是运行时的，很难摸清楚具体调用到的对象。所以我们虽然曾经有过这种尝试，但现在已经不建议这么做了。</p><h4 id="Application-Service-是业务流程的封装，不处理业务逻辑"><a href="#Application-Service-是业务流程的封装，不处理业务逻辑" class="headerlink" title="Application Service 是业务流程的封装，不处理业务逻辑"></a>Application Service 是业务流程的封装，不处理业务逻辑</h4><p>虽然之前曾经无数次重复ApplicationService只负责业务流程串联，不负责业务逻辑，但如何判断一段代码到底是业务流程还是逻辑呢？ 举个之前的例子，最初的代码重构后： 判断是否业务流程的几个点：</p><ol><li><p>不要有if&#x2F;else分支逻辑：也就是说代码的Cyclomatic Complexity（循环复杂度）应该尽量等于1 通常有分支逻辑的，都代表一些业务判断，应该将逻辑封装到DomainService或者Entity里。但这不代表完全不能有if逻辑，比如，在这段代码里： boolean withholdSuccess &#x3D; inventoryService.withhold(cmd.getItemId(), cmd.getQuantity()); if (!withholdSuccess) { throw new IllegalArgumentException(“Inventory not enough”); } 虽然CC &gt; 1，但是仅仅代表了中断条件，具体的业务逻辑处理并没有受影响。可以把它看作为Precondition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckoutServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CheckoutService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">OrderDtoAssembler</span> <span class="hljs-variable">orderDtoAssembler</span> <span class="hljs-operator">=</span> OrderDtoAssembler.INSTANCE;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ItemService itemService;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> InventoryService inventoryService;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> OrderRepository orderRepository;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">checkout</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> CheckoutCommand cmd)</span> &#123;<br>        <span class="hljs-type">ItemDO</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> itemService.getItem(cmd.getItemId());<br>        <span class="hljs-keyword">if</span> (item == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Item not found&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">withholdSuccess</span> <span class="hljs-operator">=</span> inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());<br>        <span class="hljs-keyword">if</span> (!withholdSuccess) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Inventory not enough&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        order.setBuyerId(cmd.getUserId());<br>        order.setSellerId(item.getSellerId());<br>        order.setItemId(item.getItemId());<br>        order.setItemTitle(item.getTitle());<br>        order.setItemUnitPrice(item.getPriceInCents());<br>        order.setCount(cmd.getQuantity());<br><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">savedOrder</span> <span class="hljs-operator">=</span> orderRepository.save(order);<br><br>        <span class="hljs-keyword">return</span> orderDtoAssembler.orderToDTO(savedOrder);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不要有任何计算： 在最早的代码里有这个计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 5）领域计算</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> item.getPriceInCents() * quantity;<br>order.setTotalCost(cost);<br></code></pre></td></tr></table></figure></li></ol><p>通过将这个计算逻辑封装到实体里，避免在ApplicationService里做计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Long itemUnitPrice;<br>    <span class="hljs-keyword">private</span> Integer count;<br><br>    <span class="hljs-comment">// 把原来一个在ApplicationService的计算迁移到Entity里</span><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getTotalCost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> itemUnitPrice * count;<br>    &#125;<br>&#125;<br><br>order.setItemUnitPrice(item.getPriceInCents());<br>order.setCount(cmd.getQuantity());<br></code></pre></td></tr></table></figure><ol start="3"><li>一些数据的转化可以交给其他对象来做： 比如DTO Assembler，将对象间转化的逻辑沉淀在单独的类中，降低ApplicationService的复杂度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OrderDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> orderDtoAssembler.orderToDTO(savedOrder);<br></code></pre></td></tr></table></figure></li></ol><h4 id="常用的ApplicationService“套路”"><a href="#常用的ApplicationService“套路”" class="headerlink" title="常用的ApplicationService“套路”"></a>常用的ApplicationService“套路”</h4><p>我们可以看出来，ApplicationService的代码通常有类似的结构：AppService通常不做任何决策（Precondition除外），仅仅是把所有决策交给DomainService或Entity，把跟外部交互的交给Infrastructure接口，如Repository或防腐层。</p><p>一般的“套路”如下：</p><ul><li>准备数据：包括从外部服务或持久化源取出相对应的Entity、VO以及外部服务返回的DTO。</li><li>执行操作：包括新对象的创建、赋值，以及调用领域对象的方法对其进行操作。需要注意的是这个时候通常都是纯内存操作，非持久化。</li><li>持久化：将操作结果持久化，或操作外部系统产生相应的影响，包括发消息等异步操作。</li></ul><p>如果涉及到对多个外部系统（包括自身的DB）都有变更的情况，这个时候通常处在“分布式事务”的场景里，无论是用分布式TX、TCC、还是Saga模式，取决于具体场景的设计，在此处暂时略过。</p><h3 id="DTO-Assembler"><a href="#DTO-Assembler" class="headerlink" title="DTO Assembler"></a>DTO Assembler</h3><p>一个经常被忽视的问题是 ApplicationService应该返回 Entity 还是 DTO？这里提出一个规范，在DDD分层架构中：</p><blockquote><p>ApplicationService应该永远返回DTO而不是Entity</p></blockquote><p>为什么呢？</p><ol><li>构建领域边界：ApplicationService的入参是CQE对象，出参是DTO，这些基本上都属于简单的POJO，来确保Application层的内外互相不影响。</li><li>降低规则依赖：Entity里面通常会包含业务规则，如果ApplicationService返回Entity，则会导致调用方直接依赖业务规则。如果内部规则变更可能直接影响到外部。</li><li>通过DTO组合降低成本：Entity是有限的，DTO可以是多个Entity、VO的自由组合，一次性封装成复杂DTO，或者有选择的抽取部分参数封装成DTO可以降低对外的成本。</li></ol><p>因为我们操作的对象是Entity，但是输出的对象是DTO，这里就需要一个专属类型的对象叫DTO Assembler。DTO Assembler的唯一职责是将一个或多个Entity&#x2F;VO，转化为DTO。注意：DTO Assembler通常不建议有反操作，也就是不会从DTO到Entity，因为通常一个DTO转化为Entity时是无法保证Entity的准确性的。</p><p>通常，Entity转DTO是有成本的，无论是代码量还是运行时的操作。手写转换代码容易出错，为了节省代码量用Reflection会造成极大的性能损耗。所以这里我还是不遗余力的推荐MapStruct这个库。MapStruct通过静态编译时代码生成，通过写接口和配置注解就可以生成对应的代码，且因为生成的代码是直接赋值，其性能损耗基本可以忽略不计。</p><p>通过MapStruct，代码即可简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.mapstruct.Mapper;<br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderDtoAssembler</span> &#123;<br>    <span class="hljs-type">OrderDtoAssembler</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> Mappers.getMapper(OrderDtoAssembler.class);<br>    OrderDTO <span class="hljs-title function_">orderToDTO</span><span class="hljs-params">(Order order)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckoutServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CheckoutService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">OrderDtoAssembler</span> <span class="hljs-variable">orderDtoAssembler</span> <span class="hljs-operator">=</span> OrderDtoAssembler.INSTANCE;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">checkout</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> CheckoutCommand cmd)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>      <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">savedOrder</span> <span class="hljs-operator">=</span> orderRepository.save(order);<br>        <span class="hljs-keyword">return</span> orderDtoAssembler.orderToDTO(savedOrder);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合之前的Data Mapper，DTO、Entity和DataObject之间的关系如下图：<br><img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927181216.png" alt=""></p><h3 id="Result-vs-Exception"><a href="#Result-vs-Exception" class="headerlink" title="Result vs Exception"></a>Result vs Exception</h3><p>最后，上文曾经提及在Interface层应该返回Result，在Application层应该返回DTO，在这里再次重复提出规范：</p><blockquote><p>Application层只返回DTO，可以直接抛异常，不用统一处理。所有调用到的服务也都可以直接抛异常，除非需要特殊处理，否则不需要刻意捕捉异常</p></blockquote><p>异常的好处是能明确的知道错误的来源，堆栈等，在Interface层统一捕捉异常是为了避免异常堆栈信息泄漏到API之外，但是在Application层，异常机制仍然是信息量最大，代码结构最清晰的方法，避免了Result的一些常见且繁杂的Result.isSuccess判断。所以在Application层、Domain层，以及Infrastructure层，遇到错误直接抛异常是最合理的方法。</p><h3 id="简单讲一下Anti-Corruption-Layer防腐层"><a href="#简单讲一下Anti-Corruption-Layer防腐层" class="headerlink" title="简单讲一下Anti-Corruption Layer防腐层"></a>简单讲一下Anti-Corruption Layer防腐层</h3><p>本文仅仅简单描述一下ACL的原理和作用，具体的实施规范可能要等到另外一篇文章。</p><p>在ApplicationService中，经常会依赖外部服务，从代码层面对外部系统产生了依赖。比如上文中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ItemDO</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> itemService.getItem(cmd.getItemId());<br><span class="hljs-type">boolean</span> <span class="hljs-variable">withholdSuccess</span> <span class="hljs-operator">=</span> inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());<br></code></pre></td></tr></table></figure><p>会发现我们的ApplicationService会强依赖ItemService、InventoryService以及ItemDO这个对象。如果任何一个服务的方法变更，或者ItemDO字段变更，都会有可能影响到ApplicationService的代码。也就是说，我们自己的代码会因为强依赖了外部系统的变化而变更，这个在复杂系统中应该是尽量避免的。那么如何做到对外部系统的隔离呢？需要加入ACL防腐层。</p><p>ACL防腐层的简单原理如下：</p><ul><li>对于依赖的外部对象，我们抽取出所需要的字段，生成一个内部所需的VO或DTO类</li><li>构建一个新的Facade，在Facade中封装调用链路，将外部类转化为内部类</li><li>针对外部系统调用，同样的用Facade方法封装外部调用链路</li></ul><p>无防腐层的情况：<br><img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927181250.png" alt=""></p><p>有防腐层的情况：<br><img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927181305.png" alt=""></p><p>具体简单实现，假设所有外部依赖都命名为ExternalXXXService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义的内部值类</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemDTO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long itemId;<br>    <span class="hljs-keyword">private</span> Long sellerId;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> Long priceInCents;<br>&#125;<br><br><span class="hljs-comment">// 商品Facade接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemFacade</span> &#123;<br>    ItemDTO <span class="hljs-title function_">getItem</span><span class="hljs-params">(Long itemId)</span>;<br>&#125;<br><span class="hljs-comment">// 商品facade实现</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemFacadeImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ItemFacade</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ExternalItemService externalItemService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ItemDTO <span class="hljs-title function_">getItem</span><span class="hljs-params">(Long itemId)</span> &#123;<br>        <span class="hljs-type">ItemDO</span> <span class="hljs-variable">itemDO</span> <span class="hljs-operator">=</span> externalItemService.getItem(itemId);<br>        <span class="hljs-keyword">if</span> (itemDO != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ItemDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemDTO</span>();<br>            dto.setItemId(itemDO.getItemId());<br>            dto.setTitle(itemDO.getTitle());<br>            dto.setPriceInCents(itemDO.getPriceInCents());<br>            dto.setSellerId(itemDO.getSellerId());<br>            <span class="hljs-keyword">return</span> dto;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 库存Facade</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InventoryFacade</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">withhold</span><span class="hljs-params">(Long itemId, Integer quantity)</span>;<br>&#125;<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryFacadeImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InventoryFacade</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ExternalInventoryService externalInventoryService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">withhold</span><span class="hljs-params">(Long itemId, Integer quantity)</span> &#123;<br>        <span class="hljs-keyword">return</span> externalInventoryService.withhold(itemId, quantity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过ACL改造之后，我们ApplicationService的代码改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckoutServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CheckoutService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ItemFacade itemFacade;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> InventoryFacade inventoryFacade;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">checkout</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> CheckoutCommand cmd)</span> &#123;<br>        <span class="hljs-type">ItemDTO</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> itemFacade.getItem(cmd.getItemId());<br>        <span class="hljs-keyword">if</span> (item == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Item not found&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">withholdSuccess</span> <span class="hljs-operator">=</span> inventoryFacade.withhold(cmd.getItemId(), cmd.getQuantity());<br>        <span class="hljs-keyword">if</span> (!withholdSuccess) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Inventory not enough&quot;</span>);<br>        &#125;<br><br>    <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很显然，这么做的好处是ApplicationService的代码已经完全不再直接依赖外部的类和方法，而是依赖了我们自己内部定义的值类和接口。如果未来外部服务有任何的变更，需要修改的是Facade类和数据转化逻辑，而不需要修改ApplicationService的逻辑。</p><p>Repository可以认为是一种特殊的ACL，屏蔽了具体数据操作的细节，即使底层数据库结构变更，数据库类型变更，或者加入其他的持久化方式，Repository的接口保持稳定，ApplicationService就能保持不变。</p><p>在一些理论框架里ACL Facade也被叫做Gateway，含义是一样的。</p><h2 id="Orchestration-vs-Choreography"><a href="#Orchestration-vs-Choreography" class="headerlink" title="Orchestration vs Choreography"></a>Orchestration vs Choreography</h2><p>在本文最后想聊一下复杂业务流程的设计规范。在复杂的业务流程里，我们通常面临两种模式：Orchestration 和 Choreography。很无奈，这两个英文单词的百度翻译&#x2F;谷歌翻译，都是“编排”，但实际上这两种模式是完全不一样的设计模式。Orchestration的编排（比如SOA&#x2F;微服务的服务编排Service Orchestration）是我们通常熟悉的用法，Choreography是最近出现了事件驱动架构EDA才慢慢流行起来。网上可能会有其他的翻译，比如编制、编舞、协作等，但感觉都没有真正的把英文单词的意思表达出来，所以为了避免误解，在下文我尽量还是用英文原词。如果谁有更好的翻译方法欢迎联系我。</p><h3 id="模式简介"><a href="#模式简介" class="headerlink" title="模式简介"></a>模式简介</h3><p>Orchestration：通常出现在脑海里的是一个交响乐团（Orchestra，注意这两个词的相似性），如下图。交响乐团的核心是一个唯一的指挥家Conductor，在一个交响乐中，所有的音乐家必须听从Conductor的指挥做操作，不可以独自发挥。所以在Orchestration模式中，所有的流程都是由一个节点或服务触发的。我们常见的业务流程代码，包括调用外部服务，就是Orchestration，由我们的服务统一触发。<br><img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927181350.png" alt=""></p><p>Choreography：通常会出现在脑海的场景是一个舞剧（来自于希腊文的舞蹈，Choros），如下图。其中每个不同的舞蹈家都在做自己的事，但是没有一个中心化的指挥。通过协作配合，每个人做好自己的事，整个舞蹈可以展现出一个完整的、和谐的画面。所以在Choreography模式中，每个服务都是独立的个体，可能会响应外部的一些事件，但整个系统是一个整体。<br><img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927181411.png" alt=""></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>用一个常见的例子：下单后支付并发货 如果这个案例是Orchestration，则业务逻辑为：下单时从一个预存的账户里扣取资金，并且生成物流单发货，从图上看是这样的：</p><p>如果这个案例是Choreography，则业务逻辑为：下单，然后等支付成功事件，然后再发货，类似这样</p><h3 id="模式的区别和选择"><a href="#模式的区别和选择" class="headerlink" title="模式的区别和选择"></a>模式的区别和选择</h3><p>虽然看起来这两种模式都能达到一样的业务目的，但是在实际开发中他们有巨大的差异：</p><p>从代码依赖关系来看：</p><ul><li>Orchestration：涉及到一个服务调用到另外的服务，对于调用方来说，是强依赖的服务提供方。</li><li>Choreography：每一个服务只是做好自己的事，然后通过事件触发其他的服务，服务之间没有直接调用上的依赖。但要注意的是下游还是会依赖上游的代码（比如事件类），所以可以认为是下游对上游有依赖。</li></ul><p>从代码灵活性来看：</p><ul><li>Orchestration：因为服务间的依赖关系是写死的，增加新的业务流程必然需要修改代码。</li><li>Choreography：因为服务间没有直接调用关系，可以增加或替换服务，而不需要改上游代码。</li></ul><p>从调用链路来看：</p><ul><li>Orchestration：是从一个服务主动调用另一个服务，所以是Command-Driven指令驱动的。</li><li>Choreography：是每个服务被动的被外部事件触发，所以是Event-Driven事件驱动的。</li></ul><p>从业务职责来看：</p><ul><li>Orchestration：有主动的调用方（比如：下单服务）。无论下游的依赖是谁，主动的调用方都需要为整个业务流程和结果负责。</li><li>Choreography：没有主动调用方，每个服务只关心自己的触发条件和结果，没有任何一个服务会为整个业务链路负责</li></ul><p>总结下来一个比较：</p><table><thead><tr><th>dd</th><th>Orchestration</th><th align="center">Choreography</th></tr></thead><tbody><tr><td>驱动力</td><td>指令驱动 Command-Driven</td><td align="center">事件驱动 Event-Driven</td></tr><tr><td>调用依赖</td><td>上游强依赖下游</td><td align="center">无直接调用依赖，但是有代码依赖，可以认为是下游依赖上游</td></tr><tr><td>灵活性</td><td>较差</td><td align="center">较高</td></tr><tr><td>业务职责</td><td>上游为业务负责</td><td align="center">无全局负责人</td></tr></tbody></table><p>另外需要重点明确的：“指令驱动”和“事件驱动”的区别不是“同步”和“异步”。指令可以是同步调用，也可以是异步消息触发（但异步指令不是事件）；反过来事件可以是异步消息，但也完全可以是进程内的同步调用。所以指令驱动和事件驱动差异的本质不在于调用方式，而是一件事情是否“已经”发生。</p><h3 id="所以在日常业务中当你碰到一个需求时，该如何选择是用Orchestration还是Choreography？"><a href="#所以在日常业务中当你碰到一个需求时，该如何选择是用Orchestration还是Choreography？" class="headerlink" title="所以在日常业务中当你碰到一个需求时，该如何选择是用Orchestration还是Choreography？"></a>所以在日常业务中当你碰到一个需求时，该如何选择是用Orchestration还是Choreography？</h3><p>这里给出两个判断方法：</p><ol><li>明确依赖的方向：<img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927181847.png" alt=""></li></ol><p>在代码中的依赖是比较明确的：如果你是下游，上游对你无感知，则只能走事件驱动；如果上游必须要对你有感知，则可以走指令驱动。反过来，如果你是上游，需要对下游强依赖，则是指令驱动；如果下游是谁无所谓，则可以走事件驱动。</p><ol start="2"><li>找出业务中的“负责人”：<img src="/posts/817307754/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%94%E8%AE%B2-20220927181903.png" alt=""></li></ol><p>第二种方法是根据业务场景找出其中的“负责人”。比如，如果业务需要通知卖家，下单系统的单一职责不应该为消息通知负责，但订单管理系统需要根据订单状态的推进主动触发消息，所以是这个功能的负责人。 在一个复杂业务流程里，通常两个模式都要有，但也很容易设计错误。如果出现依赖关系很奇怪，或者代码里调用链路&#x2F;负责人梳理不清楚的情况，可以尝试转换一下模式，可能会好很多。</p><h3 id="哪个模式更好？"><a href="#哪个模式更好？" class="headerlink" title="哪个模式更好？"></a>哪个模式更好？</h3><p>很显然，没有最好的模式，只有最合适自己业务场景的模式。<br>❌ 反例：最近几年比较流行的Event-Driven Architecture（EDA）事件驱动架构，以及Reactive-Programming响应式编程（比如RxJava），虽然有很多创新，但在一定程度上是“当你有把锤子，所有问题都是钉子”的典型案例。他们对一些基于事件的、流处理的问题有奇效，但如果拿这些框架硬套指令驱动的业务，就会感到代码极其“不协调”，认知成本提高。所以在日常选型中，还是要先根据业务场景梳理出来是哪些流程中的部分是Orchestration，哪些是Choreography，然后再选择相对应的框架。</p><h3 id="跟DDD分层架构的关系"><a href="#跟DDD分层架构的关系" class="headerlink" title="跟DDD分层架构的关系"></a>跟DDD分层架构的关系</h3><p>最后，讲了这么多O vs C，跟DDD有啥关系？很简单：</p><ul><li>O&amp;C其实是Interface层的关注点，Orchestration &#x3D; 对外的API，而Choreography &#x3D; 消息或事件。当你决策了O还是C之后，需要在interface层承接这些“驱动力”。</li><li>无论O&amp;C如何设计，Application层都“无感知”，因为ApplicationService天生就可以处理Command、Query和Event，至于这些对象怎么来，是Interface层的决策。</li></ul><p>所以，虽然Orchestration 和 Choreography是两种完全不同的业务设计模式，但最终落到Application层的代码应该是一致的，这也是为什么Application层是“用例”而不是“接口”，是相对稳定的存在。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要是做业务的，一定会需要写业务流程和服务编排，但不代表这种代码一定质量差。通过DDD的分层架构里的Interface层和Application层的合理拆分，代码可以变得优雅、灵活，能更快的响应业务但同时又能更好的沉淀。本文主要介绍了一些代码的设计规范，帮助大家掌握一定的技巧。</p><h3 id="Interface层"><a href="#Interface层" class="headerlink" title="Interface层"></a>Interface层</h3><ul><li>职责：主要负责承接网络协议的转化、Session管理等</li><li>接口数量：避免所谓的统一API，不必人为限制接口类的数量，每个&#x2F;每类业务对应一套接口即可，接口参数应该符合业务需求，避免大而全的入参</li><li>接口出参：统一返回Result</li><li>异常处理：应该捕捉所有异常，避免异常信息的泄漏。可以通过AOP统一处理，避免代码里有大量重复代码。</li></ul><h3 id="Application层-1"><a href="#Application层-1" class="headerlink" title="Application层"></a>Application层</h3><ul><li>入参：具像化Command、Query、Event对象作为ApplicationService的入参，唯一可以的例外是单ID查询的场景。</li><li>CQE的语意化：CQE对象有语意，不同用例之间语意不同，即使参数一样也要避免复用。</li><li>入参校验：基础校验通过Bean Validation api解决。Spring Validation自带Validation的AOP，也可以自己写AOP。</li><li>出参：统一返回DTO，而不是Entity或DO。</li><li>DTO转化：用DTO Assembler负责Entity&#x2F;VO到DTO的转化。</li><li>异常处理：不统一捕捉异常，可以随意抛异常。</li></ul><h3 id="部分Infra层"><a href="#部分Infra层" class="headerlink" title="部分Infra层"></a>部分Infra层</h3><ul><li>用ACL防腐层将外部依赖转化为内部代码，隔离外部的影响</li></ul><h3 id="业务流程设计模式"><a href="#业务流程设计模式" class="headerlink" title="业务流程设计模式"></a>业务流程设计模式</h3><ul><li>没有最好的模式，取决于业务场景、依赖关系、以及是否有业务“负责人”。避免拿着锤子找钉子。</li></ul><h2 id="前瞻预告"><a href="#前瞻预告" class="headerlink" title="前瞻预告"></a>前瞻预告</h2><ul><li>CQRS是Application层的一种设计模式，是基于Command和Query分离的一种设计理念，从最简单的对象分离，到目前最复杂的Event-Sourcing。这个topic有很多需要深入的点，也经常可以被用到，特别是结合复杂的Aggregate。后面单独会拉出来讲，标题暂定为《CQRS的7层境界》</li><li>在当今复杂的微服务开发环境下，依赖外部团队开发的服务是不可避免的，但强耦合带来的成本（无论是变更、代码依赖、甚至Maven Jar包间接依赖）是一个复杂系统长期不可忽视的点。ACL防腐层是一种隔离理念，将外部耦合去除，让内部代码更加纯粹。ACL防腐层可以有很多种，Repository是一种特殊的面相数据持久化的ACL，K8S-sidecar-istio 可以说是一种网络层的ACL，但在Java&#x2F;Spring里可以有比Istio更高效、更通用的方法，待后文介绍。</li><li>当你开始用起来DDD时，会发现很多代码模式都非常类似，比如主子订单就是总分模式、类目体系的CPV模式也可以用到一些活动上，ECS模式可以在互动业务上发挥作用等等。后面会尝试总结出一些通用的领域设计模式，他们的设计思路、可以解决的问题类型、以及实践落地的方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>DDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>转载</tag>
      
      <tag>DDD详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD详解-第四讲[转载]</title>
    <link href="/posts/2982464541/"/>
    <url>/posts/2982464541/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文为转载，原文链接为: <a href="https://zhuanlan.zhihu.com/p/356518017">https://zhuanlan.zhihu.com/p/356518017</a></p>          </div><h1 id="DDD-详解-领域层设计规范"><a href="#DDD-详解-领域层设计规范" class="headerlink" title="DDD 详解-领域层设计规范"></a>DDD 详解-领域层设计规范</h1><h2 id="初探龙与魔法的世界架构"><a href="#初探龙与魔法的世界架构" class="headerlink" title="初探龙与魔法的世界架构"></a>初探龙与魔法的世界架构</h2><h3 id="背景和规则"><a href="#背景和规则" class="headerlink" title="背景和规则"></a>背景和规则</h3><p>平日里看了好多严肃的业务代码，今天找一个轻松的话题，如何用代码实现一个龙与魔法的游戏世界的（极简）规则？</p><p>基础配置如下：</p><ul><li>玩家（Player）可以是战士（Fighter）、法师（Mage）、龙骑（Dragoon）</li></ul><ul><li>怪物（Monster）可以是兽人（Orc）、精灵（Elf）、龙（Dragon），怪物有血量</li><li>武器（Weapon）可以是剑（Sword）、法杖（Staff），武器有攻击力</li><li>玩家可以装备一个武器，武器攻击可以是物理类型（0），火（1），冰（2）等，武器类型决定伤害类型</li></ul><p>攻击规则如下：</p><ol><li>兽人对物理攻击伤害减半</li><li>精灵对魔法攻击伤害减半</li><li>龙对物理和魔法攻击免疫，除非玩家是龙骑，则伤害加倍</li></ol><h3 id="OOP实现"><a href="#OOP实现" class="headerlink" title="OOP实现"></a>OOP实现</h3><p>对于熟悉Object-Oriented Programming的同学，一个比较简单的实现是通过类的继承关系（此处省略部分非核心代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>      Weapon weapon<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fighter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Player</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Player</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dragoon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Player</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> &#123;<br>    Long health;<br>&#125;<br><span class="hljs-keyword">public</span> Orc <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Monster</span> &#123;&#125;<br><span class="hljs-keyword">public</span> Elf <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Monster</span> &#123;&#125;<br><span class="hljs-keyword">public</span> Dragoon <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Monster</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Weapon</span> &#123;<br>    <span class="hljs-type">int</span> damage;<br>    <span class="hljs-type">int</span> damageType; <span class="hljs-comment">// 0 - physical, 1 - fire, 2 - ice etc.</span><br>&#125;<br><span class="hljs-keyword">public</span> Sword <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Weapon</span> &#123;&#125;<br><span class="hljs-keyword">public</span> Staff <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Weapon</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>而实现规则代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">(Monster monster)</span> &#123;<br>        monster.receiveDamageBy(weapon, <span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDamageBy</span><span class="hljs-params">(Weapon weapon, Player player)</span> &#123;<br>        <span class="hljs-built_in">this</span>.health -= weapon.getDamage(); <span class="hljs-comment">// 基础规则</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Monster</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDamageBy</span><span class="hljs-params">(Weapon weapon, Player player)</span> &#123;<br>        <span class="hljs-keyword">if</span> (weapon.getDamageType() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.setHealth(<span class="hljs-built_in">this</span>.getHealth() - weapon.getDamage() / <span class="hljs-number">2</span>); <span class="hljs-comment">// Orc的物理防御规则</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">super</span>.receiveDamageBy(weapon, player);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dragon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Monster</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDamageBy</span><span class="hljs-params">(Weapon weapon, Player player)</span> &#123;<br>        <span class="hljs-keyword">if</span> (player <span class="hljs-keyword">instanceof</span> Dragoon) &#123;<br>            <span class="hljs-built_in">this</span>.setHealth(<span class="hljs-built_in">this</span>.getHealth() - weapon.getDamage() * <span class="hljs-number">2</span>); <span class="hljs-comment">// 龙骑伤害规则</span><br>        &#125;<br>        <span class="hljs-comment">// else no damage, 龙免疫力规则</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后跑几个单测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BattleTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@DisplayName(&quot;Dragon is immune to attacks&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDragonImmunity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Given</span><br>        <span class="hljs-type">Fighter</span> <span class="hljs-variable">fighter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fighter</span>(<span class="hljs-string">&quot;Hero&quot;</span>);<br>        <span class="hljs-type">Sword</span> <span class="hljs-variable">sword</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword</span>(<span class="hljs-string">&quot;Excalibur&quot;</span>, <span class="hljs-number">10</span>);<br>        fighter.setWeapon(sword);<br>        <span class="hljs-type">Dragon</span> <span class="hljs-variable">dragon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dragon</span>(<span class="hljs-string">&quot;Dragon&quot;</span>, <span class="hljs-number">100L</span>);<br><br>        <span class="hljs-comment">// When</span><br>        fighter.attack(dragon);<br><br>        <span class="hljs-comment">// Then</span><br>        assertThat(dragon.getHealth()).isEqualTo(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@DisplayName(&quot;Dragoon attack dragon doubles damage&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDragoonSpecial</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Given</span><br>        <span class="hljs-type">Dragoon</span> <span class="hljs-variable">dragoon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dragoon</span>(<span class="hljs-string">&quot;Dragoon&quot;</span>);<br>        <span class="hljs-type">Sword</span> <span class="hljs-variable">sword</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword</span>(<span class="hljs-string">&quot;Excalibur&quot;</span>, <span class="hljs-number">10</span>);<br>        dragoon.setWeapon(sword);<br>        <span class="hljs-type">Dragon</span> <span class="hljs-variable">dragon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dragon</span>(<span class="hljs-string">&quot;Dragon&quot;</span>, <span class="hljs-number">100L</span>);<br><br>        <span class="hljs-comment">// When</span><br>        dragoon.attack(dragon);<br><br>        <span class="hljs-comment">// Then</span><br>        assertThat(dragon.getHealth()).isEqualTo(<span class="hljs-number">100</span> - <span class="hljs-number">10</span> * <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@DisplayName(&quot;Orc should receive half damage from physical weapons&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFighterOrc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Given</span><br>        <span class="hljs-type">Fighter</span> <span class="hljs-variable">fighter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fighter</span>(<span class="hljs-string">&quot;Hero&quot;</span>);<br>        <span class="hljs-type">Sword</span> <span class="hljs-variable">sword</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword</span>(<span class="hljs-string">&quot;Excalibur&quot;</span>, <span class="hljs-number">10</span>);<br>        fighter.setWeapon(sword);<br>        <span class="hljs-type">Orc</span> <span class="hljs-variable">orc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orc</span>(<span class="hljs-string">&quot;Orc&quot;</span>, <span class="hljs-number">100L</span>);<br><br>        <span class="hljs-comment">// When</span><br>        fighter.attack(orc);<br><br>        <span class="hljs-comment">// Then</span><br>        assertThat(orc.getHealth()).isEqualTo(<span class="hljs-number">100</span> - <span class="hljs-number">10</span> / <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@DisplayName(&quot;Orc receive full damage from magic attacks&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMageOrc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Given</span><br>        <span class="hljs-type">Mage</span> <span class="hljs-variable">mage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mage</span>(<span class="hljs-string">&quot;Mage&quot;</span>);<br>        <span class="hljs-type">Staff</span> <span class="hljs-variable">staff</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Staff</span>(<span class="hljs-string">&quot;Fire Staff&quot;</span>, <span class="hljs-number">10</span>);<br>        mage.setWeapon(staff);<br>        <span class="hljs-type">Orc</span> <span class="hljs-variable">orc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orc</span>(<span class="hljs-string">&quot;Orc&quot;</span>, <span class="hljs-number">100L</span>);<br><br>        <span class="hljs-comment">// When</span><br>        mage.attack(orc);<br><br>        <span class="hljs-comment">// Then</span><br>        assertThat(orc.getHealth()).isEqualTo(<span class="hljs-number">100</span> - <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码和单测都比较简单，不做多余的解释了。</p><h3 id="分析OOP代码的设计缺陷"><a href="#分析OOP代码的设计缺陷" class="headerlink" title="分析OOP代码的设计缺陷"></a>分析OOP代码的设计缺陷</h3><p><strong>编程语言的强类型无法承载业务规则</strong><br>以上的OOP代码可以跑得通，直到我们加一个限制条件：</p><ul><li>战士只能装备剑</li><li>法师只能装备法杖<br>这个规则在Java语言里无法通过强类型来实现，虽然Java有Variable Hiding（或者C#的new class variable），但实际上只是在子类上加了一个新变量，所以会导致以下的问题：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fighter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-keyword">private</span> Sword weapon;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testEquip</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Fighter</span> <span class="hljs-variable">fighter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fighter</span>(<span class="hljs-string">&quot;Hero&quot;</span>);<br><br>    <span class="hljs-type">Sword</span> <span class="hljs-variable">sword</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword</span>(<span class="hljs-string">&quot;Sword&quot;</span>, <span class="hljs-number">10</span>);<br>    fighter.setWeapon(sword);<br><br>    <span class="hljs-type">Staff</span> <span class="hljs-variable">staff</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Staff</span>(<span class="hljs-string">&quot;Staff&quot;</span>, <span class="hljs-number">10</span>);<br>    fighter.setWeapon(staff);<br><br>    assertThat(fighter.getWeapon()).isInstanceOf(Staff.class); <span class="hljs-comment">// 错误了</span><br>&#125;<br></code></pre></td></tr></table></figure>在最后，虽然代码感觉是setWeapon(Staff)，但实际上只修改了父类的变量，并没有修改子类的变量，所以实际不生效，也不抛异常，但结果是错的。<br>当然，可以在父类限制setter为protected，但这样就限制了父类的API，极大的降低了灵活性，同时也违背了Liskov substitution principle，即一个父类必须要cast成子类才能使用：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-meta">@Setter(AccessLevel.PROTECTED)</span><br>    <span class="hljs-keyword">private</span> Weapon weapon;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCastEquip</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Fighter</span> <span class="hljs-variable">fighter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fighter</span>(<span class="hljs-string">&quot;Hero&quot;</span>);<br><br>    <span class="hljs-type">Sword</span> <span class="hljs-variable">sword</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword</span>(<span class="hljs-string">&quot;Sword&quot;</span>, <span class="hljs-number">10</span>);<br>    fighter.setWeapon(sword);<br><br>    <span class="hljs-type">Player</span> <span class="hljs-variable">player</span> <span class="hljs-operator">=</span> fighter;<br>    <span class="hljs-type">Staff</span> <span class="hljs-variable">staff</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Staff</span>(<span class="hljs-string">&quot;Staff&quot;</span>, <span class="hljs-number">10</span>);<br>    player.setWeapon(staff); <span class="hljs-comment">// 编译不过，但从API层面上应该开放可用</span><br>&#125;<br></code></pre></td></tr></table></figure>最后，如果规则增加一条：</li><li>战士和法师都能装备匕首（dagger）<br>BOOM，之前写的强类型代码都废了，需要重构。</li></ul><p><strong>对象继承导致代码强依赖父类逻辑，违反开闭原则Open-Closed Principle（OCP）</strong></p><p>开闭原则（OCP）规定“对象应该对于扩展开放，对于修改封闭“，继承虽然可以通过子类扩展新的行为，但因为子类可能直接依赖父类的实现，导致一个变更可能会影响所有对象。在这个例子里，如果增加任意一种类型的玩家、怪物或武器，或增加一种规则，都有可能需要修改从父类到子类的所有方法。</p><p>比如，如果要增加一个武器类型：狙击枪，能够无视所有防御一击必杀，需要修改的代码包括：</p><ul><li>Weapon</li><li>Player和所有的子类（是否能装备某个武器的判断）</li><li>Monster和所有的子类（伤害计算逻辑）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDamageBy</span><span class="hljs-params">(Weapon weapon, Player player)</span> &#123;<br>        <span class="hljs-built_in">this</span>.health -= weapon.getDamage(); <span class="hljs-comment">// 老的基础规则</span><br>        <span class="hljs-keyword">if</span> (Weapon <span class="hljs-keyword">instanceof</span> Gun) &#123; <span class="hljs-comment">// 新的逻辑</span><br>            <span class="hljs-built_in">this</span>.setHealth(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dragon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Monster</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDamageBy</span><span class="hljs-params">(Weapon weapon, Player player)</span> &#123;<br>        <span class="hljs-keyword">if</span> (Weapon <span class="hljs-keyword">instanceof</span> Gun) &#123; <span class="hljs-comment">// 新的逻辑</span><br>                      <span class="hljs-built_in">super</span>.receiveDamageBy(weapon, player);<br>        &#125;<br>        <span class="hljs-comment">// 老的逻辑省略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在一个复杂的软件中为什么会建议“尽量”不要违背OCP？最核心的原因就是一个现有逻辑的变更可能会影响一些原有的代码，导致一些无法预见的影响。这个风险只能通过完整的单元测试覆盖来保障，但在实际开发中很难保障单测的覆盖率。OCP的原则能尽可能的规避这种风险，当新的行为只能通过新的字段&#x2F;方法来实现时，老代码的行为自然不会变。</li></ul><p>继承虽然能Open for extension，但很难做到Closed for modification。所以今天解决OCP的主要方法是通过Composition-over-inheritance，即通过组合来做到扩展性，而不是通过继承。</p><p><strong>Player.attack(monster) 还是 Monster.receiveDamage(Weapon, Player)？</strong></p><p>在这个例子里，其实业务规则的逻辑到底应该写在哪里是有异议的：当我们去看一个对象和另一个对象之间的交互时，到底是Player去攻击Monster，还是Monster被Player攻击？目前的代码主要将逻辑写在Monster的类中，主要考虑是Monster会受伤降低Health，但如果是Player拿着一把双刃剑会同时伤害自己呢？是不是发现写在Monster类里也有问题？代码写在哪里的原则是什么？</p><p><strong>多对象行为类似，导致代码重复</strong></p><p>当我们有不同的对象，但又有相同或类似的行为时，OOP会不可避免的导致代码的重复。在这个例子里，如果我们去增加一个“可移动”的行为，需要在Player和Monster类中都增加类似的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> targetX, <span class="hljs-type">int</span> targetY)</span> &#123;<br>        <span class="hljs-comment">// logic</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> targetX, <span class="hljs-type">int</span> targetY)</span> &#123;<br>        <span class="hljs-comment">// logic</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个可能的解法是有个通用的父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Movable</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> targetX, <span class="hljs-type">int</span> targetY)</span> &#123;<br>        <span class="hljs-comment">// logic</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Movable</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Movable</span>;<br></code></pre></td></tr></table></figure><p>但如果再增加一个跳跃能力Jumpable呢？一个跑步能力Runnable呢？如果Player可以Move和Jump，Monster可以Move和Run，怎么处理继承关系？要知道Java（以及绝大部分语言）是不支持多父类继承的，所以只能通过重复代码来实现。</p><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>在这个案例里虽然从直觉来看OOP的逻辑很简单，但如果你的业务比较复杂，未来会有大量的业务规则变更时，简单的OOP代码会在后期变成复杂的一团浆糊，逻辑分散在各地，缺少全局视角，各种规则的叠加会触发bug。有没有感觉似曾相识？对的，电商体系里的优惠、交易等链路经常会碰到类似的坑。而这类问题的核心本质在于：</p><ul><li>业务规则的归属到底是对象的“行为”还是独立的”规则对象“？</li><li>业务规则之间的关系如何处理？</li><li>通用“行为”应该如何复用和维护？</li></ul><p>在讲DDD的解法前，我们先去看看一套游戏里最近比较火的架构设计，Entity-Component-System（ECS）是如何实现的。  </p><h2 id="Entity-Component-System（ECS）架构简介"><a href="#Entity-Component-System（ECS）架构简介" class="headerlink" title="Entity-Component-System（ECS）架构简介"></a>Entity-Component-System（ECS）架构简介</h2><h3 id="ECS介绍"><a href="#ECS介绍" class="headerlink" title="ECS介绍"></a>ECS介绍</h3><p>ECS架构模式是其实是一个很老的游戏架构设计，最早应该能追溯到《地牢围攻》的组件化设计，但最近因为Unity的加入而开始变得流行（比如《守望先锋》就是用的ECS）。要很快的理解ECS架构的价值，我们需要理解一个游戏代码的核心问题：</p><ul><li>性能：游戏必须要实现一个高的渲染率（60FPS），也就是说整个游戏世界需要在1&#x2F;60s（大概16ms）内完整更新一次（包括物理引擎、游戏状态、渲染、AI等）。而在一个游戏中，通常有大量的（万级、十万级）游戏对象需要更新状态，除了渲染可以依赖GPU之外，其他的逻辑都需要由CPU完成，甚至绝大部分只能由单线程完成，导致绝大部分时间复杂场景下CPU（主要是内存到CPU的带宽）会成为瓶颈。在CPU单核速度几乎不再增加的时代，如何能让CPU处理的效率提升，是提升游戏性能的核心。</li><li>代码组织：如同第一章讲的案例一样，当我们用传统OOP的模式进行游戏开发时，很容易就会陷入代码组织上的问题，最终导致代码难以阅读，维护和优化。</li><li>可扩展性：这个跟上一条类似，但更多的是游戏的特性导致：需要快速更新，加入新的元素。一个游戏的架构需要能通过低代码、甚至0代码的方式增加游戏元素，从而通过快速更新而留住用户。如果每次变更都需要开发新的代码，测试，然后让用户重新下载客户端，可想而知这种游戏很难在现在的竞争环境下活下来。</li></ul><p>而ECS架构能很好的解决上面的几个问题，ECS架构主要分为：</p><ul><li>Entity：用来代表任何一个游戏对象，但是在ECS里一个Entity最重要的仅仅是他的EntityID，一个Entity里包含多个Component</li><li>Component：是真正的数据，ECS架构把一个个的实体对象拆分为更加细化的组件，比如位置、素材、状态等，也就是说一个Entity实际上只是一个Bag of Components。</li><li>System（或者ComponentSystem，组件系统）：是真正的行为，一个游戏里可以有很多个不同的组件系统，每个组件系统都只负责一件事，可以依次处理大量的相同组件，而不需要去理解具体的Entity。所以一个ComponentSystem理论上可以有更加高效的组件处理效率，甚至可以实现并行处理，从而提升CPU利用率。</li></ul><p>ECS的一些核心性能优化包括将同类型组件放在同一个Array中，然后Entity仅保留到各自组件的pointer，这样能更好的利用CPU的缓存，减少数据的加载成本，以及SIMD的优化等。</p><p>一个ECS案例的伪代码如下：<br>由于本文不是讲解ECS架构的，感兴趣的同学可以搜索Entity-Component-System或者看看Unity的ECS文档等。</p><h3 id="ECS架构分析"><a href="#ECS架构分析" class="headerlink" title="ECS架构分析"></a>ECS架构分析</h3><p>重新回来分析ECS，其实它的本源还是几个很老的概念：</p><p><strong>组件化</strong><br>在软件系统里，我们通常将复杂的大系统拆分为独立的组件，来降低复杂度。比如网页里通过前端组件化降低重复开发成本，微服务架构通过服务和数据库的拆分降低服务复杂度和系统影响面等。但是ECS架构把这个走到了极致，即每个对象内部都实现了组件化。通过将一个游戏对象的数据和行为拆分为多个组件和组件系统，能实现组件的高度复用性，降低重复开发成本。</p><p><strong>行为抽离</strong><br>这个在游戏系统里有个比较明显的优势。如果按照OOP的方式，一个游戏对象里可能会包括移动代码、战斗代码、渲染代码、AI代码等，如果都放在一个类里会很长，且很难去维护。通过将通用逻辑抽离出来为单独的System类，可以明显提升代码的可读性。另一个好处则是抽离了一些和对象代码无关的依赖，比如上文的delta，这个delta如果是放在Entity的update方法，则需要作为入参注入，而放在System里则可以统一管理。在第一章的有个问题，到底是应该Player.attack(monster) 还是 Monster.receiveDamage(Weapon, Player)。在ECS里这个问题就变的很简单，放在CombatSystem里就可以了。</p><p><strong>数据驱动</strong><br>即一个对象的行为不是写死的而是通过其参数决定，通过参数的动态修改，就可以快速改变一个对象的具体行为。在ECS的游戏架构里，通过给Entity注册相应的Component，以及改变Component的具体参数的组合，就可以改变一个对象的行为和玩法，比如创建一个水壶+爆炸属性就变成了“爆炸水壶”、给一个自行车加上风魔法就变成了飞车等。在有些Rougelike游戏中，可能有超过1万件不同类型、不同功能的物品，如果这些不同功能的物品都去单独写代码，可能永远都写不完，但是通过数据驱动+组件化架构，所有物品的配置最终就是一张表，修改也极其简单。这个也是组合胜于继承原则的一次体现。</p><h3 id="ECS的缺陷"><a href="#ECS的缺陷" class="headerlink" title="ECS的缺陷"></a>ECS的缺陷</h3><p>虽然ECS在游戏界已经开始崭露头角，我发现ECS架构目前还没有在哪个大型商业应用中被使用过。原因可能很多，包括ECS比较新大家还不了解、缺少商业成熟可用的框架、程序员们还不够能适应从写逻辑脚本到写组件的思维转变等，但我认为其最大的一个问题是ECS为了提升性能，强调了数据&#x2F;状态（State）和行为（Behaivor）分离，并且为了降低GC成本，直接操作数据，走到了一个极端。而在商业应用中，数据的正确性、一致性和健壮性应该是最高的优先级，而性能只是锦上添花的东西，所以ECS很难在商业场景里带来特别大的好处。但这不代表我们不能借鉴一些ECS的突破性思维，包括组件化、跨对象行为的抽离、以及数据驱动模式，而这些在DDD里也能很好的用起来。</p><h2 id="基于DDD架构的一种解法"><a href="#基于DDD架构的一种解法" class="headerlink" title="基于DDD架构的一种解法"></a>基于DDD架构的一种解法</h2><h3 id="领域对象"><a href="#领域对象" class="headerlink" title="领域对象"></a>领域对象</h3><p>回到我们原来的问题域上面，我们从领域层拆分一下各种对象：</p><p><strong>实体类</strong><br>在DDD里，实体类包含ID和内部状态，在这个案例里实体类包含Player、Monster和Weapon。Weapon被设计成实体类是因为两把同名的Weapon应该可以同时存在，所以必须要有ID来区分，同时未来也可以预期Weapon会包含一些状态，比如升级、临时的buff、耐久等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Movable</span> &#123;<br>    <span class="hljs-keyword">private</span> PlayerId id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> PlayerClass playerClass; <span class="hljs-comment">// enum</span><br>    <span class="hljs-keyword">private</span> WeaponId weaponId; <span class="hljs-comment">// （Note 1）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Transform</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> Transform.ORIGIN;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Vector</span> <span class="hljs-variable">velocity</span> <span class="hljs-operator">=</span> Vector.ZERO;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Movable</span> &#123;<br>    <span class="hljs-keyword">private</span> MonsterId id;<br>    <span class="hljs-keyword">private</span> MonsterClass monsterClass; <span class="hljs-comment">// enum</span><br>    <span class="hljs-keyword">private</span> Health health;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Transform</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> Transform.ORIGIN;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Vector</span> <span class="hljs-variable">velocity</span> <span class="hljs-operator">=</span> Vector.ZERO;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Weapon</span> &#123;<br>    <span class="hljs-keyword">private</span> WeaponId id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> WeaponType weaponType; <span class="hljs-comment">// enum</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> damage;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> damageType; <span class="hljs-comment">// 0 - physical, 1 - fire, 2 - ice</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个简单的案例里，我们可以利用enum的PlayerClass、MonsterClass来代替继承关系，后续也可以利用Type Object设计模式来做到数据驱动。<br>Note 1: 因为 Weapon 是实体类，但是Weapon能独立存在，Player不是聚合根，所以Player只能保存WeaponId，而不能直接指向Weapon。</p><p><strong>值对象的组件化</strong><br>在前面的ECS架构里，有个MovementSystem的概念是可以复用的，虽然不应该直接去操作Component或者继承通用的父类，但是可以通过接口的方式对领域对象做组件化处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Movable</span> &#123;<br>    <span class="hljs-comment">// 相当于组件</span><br>    Transform <span class="hljs-title function_">getPosition</span><span class="hljs-params">()</span>;<br>    Vector <span class="hljs-title function_">getVelocity</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 行为</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveTo</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">startMove</span><span class="hljs-params">(<span class="hljs-type">long</span> velX, <span class="hljs-type">long</span> velY)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopMove</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMoving</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具体实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Movable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveTo</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span> &#123;<br>        <span class="hljs-built_in">this</span>.position = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>(x, y);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startMove</span><span class="hljs-params">(<span class="hljs-type">long</span> velocityX, <span class="hljs-type">long</span> velocityY)</span> &#123;<br>        <span class="hljs-built_in">this</span>.velocity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>(velocityX, velocityY);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopMove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.velocity = Vector.ZERO;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMoving</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.velocity.getX() != <span class="hljs-number">0</span> || <span class="hljs-built_in">this</span>.velocity.getY() != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transform</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Transform</span> <span class="hljs-variable">ORIGIN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">long</span> x;<br>    <span class="hljs-type">long</span> y;<br>&#125;<br><br><span class="hljs-meta">@Value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Vector</span> <span class="hljs-variable">ZERO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">long</span> x;<br>    <span class="hljs-type">long</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意两点：</p><ul><li>Moveable的接口没有Setter。一个Entity的规则是不能直接变更其属性，必须通过Entity的方法去对内部状态做变更。这样能保证数据的一致性。</li><li>抽象Movable的好处是如同ECS一样，一些特别通用的行为（如在大地图里移动）可以通过统一的System代码去处理，避免了重复劳动。</li></ul><h3 id="装备行为"><a href="#装备行为" class="headerlink" title="装备行为"></a>装备行为</h3><p>因为我们已经不会用Player的子类来决定什么样的Weapon可以装备，所以这段逻辑应该被拆分到一个单独的类里。这种类在DDD里被叫做领域服务（Domain Service）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EquipmentService</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">canEquip</span><span class="hljs-params">(Player player, Weapon weapon)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在DDD里，一个Entity不应该直接参考另一个Entity或服务，也就是说以下的代码是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    EquipmentService equipmentService; <span class="hljs-comment">// BAD: 不可以直接依赖</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">equip</span><span class="hljs-params">(Weapon weapon)</span> &#123;<br>       <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的问题是Entity只能保留自己的状态（或非聚合根的对象）。任何其他的对象，无论是否通过依赖注入的方式弄进来，都会破坏Entity的Invariance，并且还难以单测。</p><p>正确的引用方式是通过方法参数引入（Double Dispatch）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">equip</span><span class="hljs-params">(Weapon weapon, EquipmentService equipmentService)</span> &#123;<br>        <span class="hljs-keyword">if</span> (equipmentService.canEquip(<span class="hljs-built_in">this</span>, weapon)) &#123;<br>            <span class="hljs-built_in">this</span>.weaponId = weapon.getId();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot Equip: &quot;</span> + weapon);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，无论是Weapon还是EquipmentService都是通过方法参数传入，确保不会污染Player的自有状态。<br>Double Dispatch是一个使用Domain Service经常会用到的方法，类似于调用反转。<br>然后在EquipmentService里实现相关的逻辑判断，这里我们用了另一个常用的Strategy（或者叫Policy）设计模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EquipmentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EquipmentService</span> &#123;<br>    <span class="hljs-keyword">private</span> EquipmentManager equipmentManager; <br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canEquip</span><span class="hljs-params">(Player player, Weapon weapon)</span> &#123;<br>        <span class="hljs-keyword">return</span> equipmentManager.canEquip(player, weapon);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 策略优先级管理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EquipmentManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;EquipmentPolicy&gt; POLICIES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FighterEquipmentPolicy</span>());<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MageEquipmentPolicy</span>());<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DragoonEquipmentPolicy</span>());<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEquipmentPolicy</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canEquip</span><span class="hljs-params">(Player player, Weapon weapon)</span> &#123;<br>        <span class="hljs-keyword">for</span> (EquipmentPolicy policy : POLICIES) &#123;<br>            <span class="hljs-keyword">if</span> (!policy.canApply(player, weapon)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> policy.canEquip(player, weapon);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 策略案例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FighterEquipmentPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EquipmentPolicy</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canApply</span><span class="hljs-params">(Player player, Weapon weapon)</span> &#123;<br>        <span class="hljs-keyword">return</span> player.getPlayerClass() == PlayerClass.Fighter;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Fighter能装备Sword和Dagger</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canEquip</span><span class="hljs-params">(Player player, Weapon weapon)</span> &#123;<br>        <span class="hljs-keyword">return</span> weapon.getWeaponType() == WeaponType.Sword<br>                || weapon.getWeaponType() == WeaponType.Dagger;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 其他策略省略，见源码</span><br></code></pre></td></tr></table></figure><p>这样设计的最大好处是未来的规则增加只需要添加新的Policy类，而不需要去改变原有的类。</p><h3 id="攻击行为"><a href="#攻击行为" class="headerlink" title="攻击行为"></a>攻击行为</h3><p>在上文中曾经有提起过，到底应该是Player.attack(Monster)还是Monster.receiveDamage(Weapon, Player)？在DDD里，因为这个行为可能会影响到Player、Monster和Weapon，所以属于跨实体的业务逻辑。在这种情况下需要通过一个第三方的领域服务（Domain Service）来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CombatService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAttack</span><span class="hljs-params">(Player player, Monster monster)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombatServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CombatService</span> &#123;<br>    <span class="hljs-keyword">private</span> WeaponRepository weaponRepository;<br>    <span class="hljs-keyword">private</span> DamageManager damageManager;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAttack</span><span class="hljs-params">(Player player, Monster monster)</span> &#123;<br>        <span class="hljs-type">Weapon</span> <span class="hljs-variable">weapon</span> <span class="hljs-operator">=</span> weaponRepository.find(player.getWeaponId());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">damage</span> <span class="hljs-operator">=</span> damageManager.calculateDamage(player, weapon, monster);<br>        <span class="hljs-keyword">if</span> (damage &gt; <span class="hljs-number">0</span>) &#123;<br>            monster.takeDamage(damage); <span class="hljs-comment">// （Note 1）在领域服务里变更Monster</span><br>        &#125;<br>        <span class="hljs-comment">// 省略掉Player和Weapon可能受到的影响</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的在这个案例里，可以通过Strategy设计模式来解决damage的计算问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 策略优先级管理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DamageManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;DamagePolicy&gt; POLICIES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DragoonPolicy</span>());<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DragonImmunityPolicy</span>());<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrcResistancePolicy</span>());<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElfResistancePolicy</span>());<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PhysicalDamagePolicy</span>());<br>        POLICIES.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultDamagePolicy</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateDamage</span><span class="hljs-params">(Player player, Weapon weapon, Monster monster)</span> &#123;<br>        <span class="hljs-keyword">for</span> (DamagePolicy policy : POLICIES) &#123;<br>            <span class="hljs-keyword">if</span> (!policy.canApply(player, weapon, monster)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> policy.calculateDamage(player, weapon, monster);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 策略案例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DragoonPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DamagePolicy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateDamage</span><span class="hljs-params">(Player player, Weapon weapon, Monster monster)</span> &#123;<br>        <span class="hljs-keyword">return</span> weapon.getDamage() * <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canApply</span><span class="hljs-params">(Player player, Weapon weapon, Monster monster)</span> &#123;<br>        <span class="hljs-keyword">return</span> player.getPlayerClass() == PlayerClass.Dragoon &amp;&amp;<br>                monster.getMonsterClass() == MonsterClass.Dragon;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特别需要注意的是这里的CombatService领域服务和3.2的EquipmentService领域服务，虽然都是领域服务，但实质上有很大的差异。上文的EquipmentService更多的是提供只读策略，且只会影响单个对象，所以可以在Player.equip方法上通过参数注入。但是CombatService有可能会影响多个对象，所以不能直接通过参数注入的方式调用。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;Dragoon attack dragon doubles damage&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDragoonSpecial</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Given</span><br>    <span class="hljs-type">Player</span> <span class="hljs-variable">dragoon</span> <span class="hljs-operator">=</span> playerFactory.createPlayer(PlayerClass.Dragoon, <span class="hljs-string">&quot;Dart&quot;</span>);<br>    <span class="hljs-type">Weapon</span> <span class="hljs-variable">sword</span> <span class="hljs-operator">=</span> weaponFactory.createWeaponFromPrototype(swordProto, <span class="hljs-string">&quot;Soul Eater&quot;</span>, <span class="hljs-number">60</span>);<br>    ((WeaponRepositoryMock)weaponRepository).cache(sword);<br>    dragoon.equip(sword, equipmentService);<br>    <span class="hljs-type">Monster</span> <span class="hljs-variable">dragon</span> <span class="hljs-operator">=</span> monsterFactory.createMonster(MonsterClass.Dragon, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// When</span><br>    combatService.performAttack(dragoon, dragon);<br><br>    <span class="hljs-comment">// Then</span><br>    assertThat(dragon.getHealth()).isEqualTo(Health.ZERO);<br>    assertThat(dragon.isAlive()).isFalse();<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;Orc should receive half damage from physical weapons&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFighterOrc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Given</span><br>    <span class="hljs-type">Player</span> <span class="hljs-variable">fighter</span> <span class="hljs-operator">=</span> playerFactory.createPlayer(PlayerClass.Fighter, <span class="hljs-string">&quot;MyFighter&quot;</span>);<br>    <span class="hljs-type">Weapon</span> <span class="hljs-variable">sword</span> <span class="hljs-operator">=</span> weaponFactory.createWeaponFromPrototype(swordProto, <span class="hljs-string">&quot;My Sword&quot;</span>);<br>    ((WeaponRepositoryMock)weaponRepository).cache(sword);<br>    fighter.equip(sword, equipmentService);<br>    <span class="hljs-type">Monster</span> <span class="hljs-variable">orc</span> <span class="hljs-operator">=</span> monsterFactory.createMonster(MonsterClass.Orc, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// When</span><br>    combatService.performAttack(fighter, orc);<br><br>    <span class="hljs-comment">// Then</span><br>    assertThat(orc.getHealth()).isEqualTo(Health.of(<span class="hljs-number">100</span> - <span class="hljs-number">10</span> / <span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的代码比较简单，解释省略  </p><h3 id="移动系统"><a href="#移动系统" class="headerlink" title="移动系统"></a>移动系统</h3><p>最后还有一种Domain Service，通过组件化，我们其实可以实现ECS一样的System，来降低一些重复性的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovementSystem</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">X_FENCE_MIN</span> <span class="hljs-operator">=</span> -<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">X_FENCE_MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">Y_FENCE_MIN</span> <span class="hljs-operator">=</span> -<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">Y_FENCE_MAX</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">private</span> List&lt;Movable&gt; entities = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Movable movable)</span> &#123;<br>        entities.add(movable);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Movable entity : entities) &#123;<br>            <span class="hljs-keyword">if</span> (!entity.isMoving()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">Transform</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> entity.getPosition();<br>            <span class="hljs-type">Vector</span> <span class="hljs-variable">vel</span> <span class="hljs-operator">=</span> entity.getVelocity();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> Math.max(Math.min(old.getX() + vel.getX(), X_FENCE_MAX), X_FENCE_MIN);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">newY</span> <span class="hljs-operator">=</span> Math.max(Math.min(old.getY() + vel.getY(), Y_FENCE_MAX), Y_FENCE_MIN);<br>            entity.moveTo(newX, newY);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;Moving player and monster at the same time&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMovement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Given</span><br>    <span class="hljs-type">Player</span> <span class="hljs-variable">fighter</span> <span class="hljs-operator">=</span> playerFactory.createPlayer(PlayerClass.Fighter, <span class="hljs-string">&quot;MyFighter&quot;</span>);<br>    fighter.moveTo(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br>    fighter.startMove(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">Monster</span> <span class="hljs-variable">orc</span> <span class="hljs-operator">=</span> monsterFactory.createMonster(MonsterClass.Orc, <span class="hljs-number">100</span>);<br>    orc.moveTo(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>    orc.startMove(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>    movementSystem.register(fighter);<br>    movementSystem.register(orc);<br><br>    <span class="hljs-comment">// When</span><br>    movementSystem.update();<br><br>    <span class="hljs-comment">// Then</span><br>    assertThat(fighter.getPosition().getX()).isEqualTo(<span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    assertThat(orc.getPosition().getX()).isEqualTo(<span class="hljs-number">10</span> - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里MovementSystem就是一个相对独立的Domain Service，通过对Movable的组件化，实现了类似代码的集中化、以及一些通用依赖&#x2F;配置的中心化（如X、Y边界等）。</p><h2 id="DDD领域层的一些设计规范"><a href="#DDD领域层的一些设计规范" class="headerlink" title="DDD领域层的一些设计规范"></a>DDD领域层的一些设计规范</h2><p>上面我主要针对同一个例子对比了OOP、ECS和DDD的3种实现，比较如下：</p><ul><li>基于继承关系的OOP代码：OOP的代码最好写，也最容易理解，所有的规则代码都写在对象里，但是当领域规则变得越来越复杂时，其结构会限制它的发展。新的规则有可能会导致代码的整体重构。</li><li>基于组件化的ECS代码：ECS代码有最高的灵活性、可复用性、及性能，但极具弱化了实体类的内聚，所有的业务逻辑都写在了服务里，会导致业务的一致性无法保障，对商业系统会有较大的影响。</li><li>基于领域对象 + 领域服务的DDD架构：DDD的规则其实最复杂，同时要考虑到实体类的内聚和保证不变性（Invariants），也要考虑跨对象规则代码的归属，甚至要考虑到具体领域服务的调用方式，理解成本比较高。<br>所以下面，我会尽量通过一些设计规范，来降低DDD领域层的设计成本。领域层里的Value Object（Domain Primitive）设计规范请参考我之前的文章。</li></ul><h3 id="实体类（Entity）"><a href="#实体类（Entity）" class="headerlink" title="实体类（Entity）"></a>实体类（Entity）</h3><p>大多数DDD架构的核心都是实体类，实体类包含了一个领域里的状态、以及对状态的直接操作。Entity最重要的设计原则是保证实体的不变性（Invariants），也就是说要确保无论外部怎么操作，一个实体内部的属性都不能出现相互冲突，状态不一致的情况。所以几个设计原则如下：</p><p><strong>创建即一致</strong><br>在贫血模型里，通常见到的代码是一个模型通过手动new出来之后，由调用方一个参数一个参数的赋值，这就很容易产生遗漏，导致实体状态不一致。所以DDD里实体创建的方法有两种：</p><p><strong>constructor参数要包含所有必要属性，或者在constructor里有合理的默认值。</strong><br>比如，账号的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> String accountNumber;<br>    <span class="hljs-keyword">private</span> Long amount;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    account.setAmount(<span class="hljs-number">100L</span>);<br>    TransferService.transfer(account); <span class="hljs-comment">// 报错了，因为Account缺少必要的AccountNumber</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果缺少一个强校验的constructor，就无法保障创建的实体的一致性。所以需要增加一个强校验的constructor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">(String accountNumber, Long amount)</span> &#123;<br>        <span class="hljs-keyword">assert</span> StringUtils.isNotBlank(accountNumber);<br>        <span class="hljs-keyword">assert</span> amount &gt;= <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.accountNumber = accountNumber;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">100L</span>); <span class="hljs-comment">// 确保对象的有效性</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用Factory模式来降低调用方复杂度</strong><br>另一种方法是通过Factory模式来创建对象，降低一些重复性的入参。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeaponFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Weapon <span class="hljs-title function_">createWeaponFromPrototype</span><span class="hljs-params">(WeaponPrototype proto, String newName)</span> &#123;<br>        <span class="hljs-type">Weapon</span> <span class="hljs-variable">weapon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weapon</span>(<span class="hljs-literal">null</span>, newName, proto.getWeaponType(), proto.getDamage(), proto.getDamageType());<br>        <span class="hljs-keyword">return</span> weapon;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过传入一个已经存在的Prototype，可以快速的创建新的实体。还有一些其他的如Builder等设计模式就不一一指出了。</p><p><strong>尽量避免public setter</strong><br>一个最容易导致不一致性的原因是实体暴露了public的setter方法，特别是set单一参数会导致状态不一致的情况。比如，一个订单可能包含订单状态（下单、已支付、已发货、已收货）、支付单、物流单等子实体，如果一个调用方能随意去set订单状态，就有可能导致订单状态和子实体匹配不上，导致业务流程走不通的情况。所以在实体里，需要通过行为方法来修改内部状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span> <span class="hljs-meta">@Setter(AccessLevel.PRIVATE)</span> <span class="hljs-comment">// 确保不生成public setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> status; <span class="hljs-comment">// 0 - 创建，1 - 支付，2 - 发货，3 - 收货</span><br>    <span class="hljs-keyword">private</span> Payment payment; <span class="hljs-comment">// 支付单</span><br>    <span class="hljs-keyword">private</span> Shipping shipping; <span class="hljs-comment">// 物流单</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Long userId, Long amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (status != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.status = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.payment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payment</span>(userId, amount);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">(String trackingNumber)</span> &#123;<br>        <span class="hljs-keyword">if</span> (status != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.status = <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">this</span>.shipping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shipping</span>(trackingNumber);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【建议】在有些简单场景里，有时候确实可以比较随意的设置一个值而不会导致不一致性，也建议将方法名重新写为比较“行为化”的命名，会增强其语意。比如setPosition(x, y)可以叫做moveTo(x, y)，setAddress可以叫做assignAddress等。</p><p><strong>通过聚合根保证主子实体的一致性</strong><br>在稍微复杂一点的领域里，通常主实体会包含子实体，这时候主实体就需要起到聚合根的作用，即：</p><ul><li>子实体不能单独存在，只能通过聚合根的方法获取到。任何外部的对象都不能直接保留子实体的引用</li><li>子实体没有独立的Repository，不可以单独保存和取出，必须要通过聚合根的Repository实例化</li><li>子实体可以单独修改自身状态，但是多个子实体之间的状态一致性需要聚合根来保障</li></ul><p>常见的电商域中聚合的案例如主子订单模型、商品&#x2F;SKU模型、跨子订单优惠、跨店优惠模型等。很多聚合根和Repository的设计规范在我前面一篇关于Repository的文章中已经详细解释过，可以拿来参考。</p><p> <strong>不可以强依赖其他聚合根实体或领域服务</strong><br>一个实体的原则是高内聚、低耦合，即一个实体类不能直接在内部直接依赖一个外部的实体或服务。这个原则和绝大多数ORM框架都有比较严重的冲突，所以是一个在开发过程中需要特别注意的。这个原则的必要原因包括：对外部对象的依赖性会直接导致实体无法被单测；以及一个实体无法保证外部实体变更后不会影响本实体的一致性和正确性。<br>所以，正确的对外部依赖的方法有两种：</p><ol><li>只保存外部实体的ID：这里我再次强烈建议使用强类型的ID对象，而不是Long型ID。强类型的ID对象不单单能自我包含验证代码，保证ID值的正确性，同时还能确保各种入参不会因为参数顺序变化而出bug。具体可以参考我的Domain Primitive文章。</li><li>针对于“无副作用”的外部依赖，通过方法入参的方式传入。比如上文中的equip(Weapon，EquipmentService）方法。<br>如果方法对外部依赖有副作用，不能通过方法入参的方式，只能通过Domain Service解决，见下文。</li></ol><p><strong>任何实体的行为只能直接影响到本实体（和其子实体）</strong><br>这个原则更多是一个确保代码可读性、可理解的原则，即任何实体的行为不能有“直接”的”副作用“，即直接修改其他的实体类。这么做的好处是代码读下来不会产生意外。<br>另一个遵守的原因是可以降低未知的变更的风险。在一个系统里一个实体对象的所有变更操作应该都是预期内的，如果一个实体能随意被外部直接修改的话，会增加代码bug的风险。</p><h3 id="领域服务（Domain-Service）"><a href="#领域服务（Domain-Service）" class="headerlink" title="领域服务（Domain Service）"></a>领域服务（Domain Service）</h3><p>在上文讲到，领域服务其实也分很多种，在这里根据上文总结出来三种常见的：  </p><p><strong>单对象策略型</strong><br>这种领域对象主要面向的是单个实体对象的变更，但涉及到多个领域对象或外部依赖的一些规则。在上文中，EquipmentService即为此类：</p><ul><li>变更的对象是Player的参数</li><li>读取的是Player和Weapon的数据，可能还包括从外部读取一些数据</li></ul><p>在这种类型下，实体应该通过方法入参的方式传入这种领域服务，然后通过Double Dispatch来反转调用领域服务的方法，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Player.equip(Weapon, EquipmentService) &#123;<br>    EquipmentService.canEquip(<span class="hljs-built_in">this</span>, Weapon);<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么这种情况下不能先调用领域服务，再调用实体对象的方法，从而减少实体对领域服务的入参型依赖呢？比如，下面这个方法是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">canEquip</span> <span class="hljs-operator">=</span> EquipmentService.canEquip(Player, Weapon);<br><span class="hljs-keyword">if</span> (canEquip) &#123;<br>    Player.equip(Weapon); <span class="hljs-comment">// ❌，这种方法不可行，因为这个方法有不一致的可能性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其错误的主要原因是缺少了领域服务入参会导致方法有可能产生不一致的情况。</p><p> <strong>跨对象事务型</strong><br>当一个行为会直接修改多个实体时，不能再通过单一实体的方法作处理，而必须直接使用领域服务的方法来做操作。在这里，领域服务更多的起到了跨对象事务的作用，确保多个实体的变更之间是有一致性的。</p><p>在上文里，虽然以下的代码虽然可以跑到通，但是是不建议的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">(Monster, CombatService)</span> &#123;<br>        CombatService.performAttack(<span class="hljs-built_in">this</span>, Monster); <span class="hljs-comment">// ❌，不要这么写，会导致副作用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而我们真实调用应该直接调用CombatService的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    combatService.performAttack(mage, orc);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个原则也映射了4.1.5 的原则，即Player.attack会直接影响到Monster，但这个调用Monster又没有感知。</p><p><strong>通用组件型</strong><br>这种类型的领域服务更像ECS里的System，提供了组件化的行为，但本身又不直接绑死在一种实体类上。具体案例可以参考上文中的MovementSystem实现。</p><h3 id="策略对象（Domain-Policy）"><a href="#策略对象（Domain-Policy）" class="headerlink" title="策略对象（Domain Policy）"></a>策略对象（Domain Policy）</h3><p>Policy或者Strategy设计模式是一个通用的设计模式，但是在DDD架构中会经常出现，其核心就是封装领域规则。<br>一个Policy是一个无状态的单例对象，通常需要至少2个方法：canApply 和 一个业务方法。其中，canApply方法用来判断一个Policy是否适用于当前的上下文，如果适用则调用方会去触发业务方法。通常，为了降低一个Policy的可测试性和复杂度，Policy不应该直接操作对象，而是通过返回计算后的值，在Domain Service里对对象进行操作。<br>在上文案例里，DamagePolicy只负责计算应该受到的伤害，而不是直接对Monster造成伤害。这样除了可测试外，还为未来的多Policy叠加计算做了准备。<br>除了本文里静态注入多个Policy以及手动排优先级之外，在日常开发中经常能见到通过Java的SPI机制或类SPI机制注册Policy，以及通过不同的Priority方案对Policy进行排序，在这里就不作太多的展开了。</p><h2 id="加餐-副作用的处理方法-领域事件"><a href="#加餐-副作用的处理方法-领域事件" class="headerlink" title="加餐 - 副作用的处理方法 - 领域事件"></a>加餐 - 副作用的处理方法 - 领域事件</h2><p>在上文中，有一种类型的领域规则被我刻意忽略了，那就是”副作用“。一般的副作用发生在核心领域模型状态变更后，同步或者异步对另一个对象的影响或行为。在这个案例里，我们可以增加一个副作用规则：</p><ul><li>当Monster的生命值降为0后，给Player奖励经验值<br>这种问题有很多种解法，比如直接把副作用写在CombatService里：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombatService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAttack</span><span class="hljs-params">(Player player, Monster monster)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        monster.takeDamage(damage);<br>        <span class="hljs-keyword">if</span> (!monster.isAlive()) &#123;<br>            player.receiveExp(<span class="hljs-number">10</span>); <span class="hljs-comment">// 收到经验</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>但是这样写的问题是：很快CombatService的代码就会变得很复杂，比如我们再加一个副作用：</li><li>当Player的exp达到100时，升一级<br>这时我们的代码就会变成：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombatService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAttack</span><span class="hljs-params">(Player player, Monster monster)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        monster.takeDamage(damage);<br>        <span class="hljs-keyword">if</span> (!monster.isAlive()) &#123;<br>            player.receiveExp(<span class="hljs-number">10</span>); <span class="hljs-comment">// 收到经验</span><br>            <span class="hljs-keyword">if</span> (player.canLevelUp()) &#123;<br>                player.levelUp(); <span class="hljs-comment">// 升级</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>如果再加上“升级后奖励XXX”呢？“更新XXX排行”呢？依此类推，后续这种代码将无法维护。所以我们需要介绍一下领域层最后一个概念：领域事件（Domain Event）。</li></ul><p><strong>领域事件介绍</strong><br>领域事件是一个在领域里发生了某些事后，希望领域里其他对象能够感知到的通知机制。在上面的案例里，代码之所以会越来越复杂，其根本的原因是反应代码（比如升级）直接和上面的事件触发条件（比如收到经验）直接耦合，而且这种耦合性是隐性的。领域事件的好处就是将这种隐性的副作用“显性化”，通过一个显性的事件，将事件触发和事件处理解耦，最终起到代码更清晰、扩展性更好的目的。<br>所以，领域事件是在DDD里，比较推荐使用的跨实体“副作用”传播机制。  </p><p><strong>领域事件实现</strong><br>和消息队列中间件不同的是，领域事件通常是立即执行的、在同一个进程内、可能是同步或异步。我们可以通过一个EventBus来实现进程内的通知机制，简单实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现者：瑜进 2019/11/28</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventBus</span> &#123;<br><br>    <span class="hljs-comment">// 注册器</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EventRegistry</span> <span class="hljs-variable">invokerRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventRegistry</span>(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">// 事件分发器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EventDispatcher</span> <span class="hljs-variable">dispatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventDispatcher</span>(ExecutorFactory.getDirectExecutor());<br><br>    <span class="hljs-comment">// 异步事件分发器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EventDispatcher</span> <span class="hljs-variable">asyncDispatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventDispatcher</span>(ExecutorFactory.getThreadPoolExecutor());<br><br>    <span class="hljs-comment">// 事件分发</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-keyword">return</span> dispatch(event, dispatcher);<br>    &#125;<br><br>    <span class="hljs-comment">// 异步事件分发</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchAsync</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-keyword">return</span> dispatch(event, asyncDispatcher);<br>    &#125;<br><br>    <span class="hljs-comment">// 内部事件分发</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(Event event, EventDispatcher dispatcher)</span> &#123;<br>        checkEvent(event);<br>        <span class="hljs-comment">// 1.获取事件数组</span><br>        Set&lt;Invoker&gt; invokers = invokerRegistry.getInvokers(event);<br>        <span class="hljs-comment">// 2.一个事件可以被监听N次，不关心调用结果</span><br>        dispatcher.dispatch(event, invokers);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 事件总线注册</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Object listener)</span> &#123;<br>        <span class="hljs-keyword">if</span> (listener == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;listener can not be null!&quot;</span>);<br>        &#125;<br>        invokerRegistry.register(listener);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkEvent</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (event == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;event&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(event <span class="hljs-keyword">instanceof</span> Event)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Event type must by &quot;</span> + Event.class);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LevelUpEvent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Event</span> &#123;<br>    <span class="hljs-keyword">private</span> Player player;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LevelUpHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Player player)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveExp</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.exp += value;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.exp &gt;= <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-type">LevelUpEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LevelUpEvent</span>(<span class="hljs-built_in">this</span>);<br>            EventBus.dispatch(event);<br>            <span class="hljs-built_in">this</span>.exp = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    EventBus.register(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LevelUpHandler</span>());<br>    player.setLevel(<span class="hljs-number">1</span>);<br>    player.receiveExp(<span class="hljs-number">100</span>);<br>    assertThat(player.getLevel()).equals(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>目前领域事件的缺陷和展望</strong><br>从上面代码可以看出来，领域事件的很好的实施依赖EventBus、Dispatcher、Invoker这些属于框架级别的支持。同时另一个问题是因为Entity不能直接依赖外部对象，所以EventBus目前只能是一个全局的Singleton，而大家都应该知道全局Singleton对象很难被单测。这就容易导致Entity对象无法被很容易的被完整单测覆盖全。</p><p>另一种解法是侵入Entity，对每个Entity增加一个List:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>  List&lt;Event&gt; events;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveExp</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.exp += value;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.exp &gt;= <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-type">LevelUpEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LevelUpEvent</span>(<span class="hljs-built_in">this</span>);<br>            events.add(event); <span class="hljs-comment">// 把event加进去</span><br>            <span class="hljs-built_in">this</span>.exp = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    EventBus.register(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LevelUpHandler</span>());<br>    player.setLevel(<span class="hljs-number">1</span>);<br>    player.receiveExp(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">for</span>(Event event: player.getEvents()) &#123; <span class="hljs-comment">// 在这里显性的dispatch事件</span><br>        EventBus.dispatch(event);<br>    &#125;<br><br>    assertThat(player.getLevel()).equals(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是能看出来这种解法不但会侵入实体本身，同时也需要比较啰嗦的显性在调用方dispatch事件，也不是一个好的解决方案。</p><p>也许未来会有一个框架能让我们既不依赖全局Singleton，也不需要显性去处理事件，但目前的方案基本都有或多或少的缺陷，大家在使用中可以注意。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在真实的业务逻辑里，我们的领域模型或多或少的都有一定的“特殊性”，如果100%的要符合DDD规范可能会比较累，所以最主要的是梳理一个对象行为的影响面，然后作出设计决策，即：</p><ul><li>是仅影响单一对象还是多个对象，</li><li>规则未来的拓展性、灵活性，</li><li>性能要求，</li><li>副作用的处理，等等<br>当然，很多时候一个好的设计是多种因素的取舍，需要大家有一定的积累，真正理解每个架构背后的逻辑和优缺点。一个好的架构师不是有一个正确答案，而是能从多个方案中选出一个最平衡的方案。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>DDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>转载</tag>
      
      <tag>DDD详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD详解-第三讲[转载]</title>
    <link href="/posts/3260840243/"/>
    <url>/posts/3260840243/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文为转载，原文链接为: <a href="https://juejin.cn/post/6845166890554228744">https://juejin.cn/post/6845166890554228744</a></p>          </div><h1 id="DDD-详解-Repository模式"><a href="#DDD-详解-Repository模式" class="headerlink" title="DDD 详解-Repository模式"></a>DDD 详解-Repository模式</h1><h2 id="为什么要用-Repository"><a href="#为什么要用-Repository" class="headerlink" title="为什么要用 Repository"></a>为什么要用 Repository</h2><h3 id="实体模型-vs-贫血模型"><a href="#实体模型-vs-贫血模型" class="headerlink" title="实体模型 vs. 贫血模型"></a>实体模型 vs. 贫血模型</h3><p>Entity（实体）这个词在计算机领域的最初应用可能是来自于Peter Chen在1976年的“The Entity-Relationship Model - Toward a Unified View of Data”（ER模型），用来描述实体之间的关系，而ER模型后来逐渐的演变成为一个数据模型，在关系型数据库中代表了数据的储存方式。<br>而2006年的JPA标准，通过@Entity等注解，以及Hibernate等ORM框架的实现，让很多Java开发对Entity的理解停留在了数据映射层面，忽略了Entity实体的本身行为，造成今天很多的模型仅包含了实体的数据和属性，而所有的业务逻辑都被分散在多个服务、Controller、Utils工具类中，这个就是Martin Fowler所说的的Anemic Domain Model（贫血领域模型）。</p><p>如何知道你的模型是贫血的呢？<br>可以看一下你代码中是否有以下的几个特征：</p><ol><li>有大量的XxxDO对象：这里DO虽然有时候代表了Domain Object，但实际上仅仅是数据库表结构的映射，里面没有包含（或包含了很少的）业务逻辑；</li><li>服务和Controller里有大量的业务逻辑：比如校验逻辑、计算逻辑、格式转化逻辑、对象关系逻辑、数据存储逻辑等； 大量的Utils工具类等。</li></ol><p>而贫血模型的缺陷是非常明显的：</p><ol><li>无法保护模型对象的完整性和一致性：因为对象的所有属性都是公开的，只能由调用方来维护模型的一致性，而这个是没有保障的；之前曾经出现的案例就是调用方没有能维护模型数据的一致性，导致脏数据使用时出现bug，这一类的 bug还特别隐蔽，很难排查到。</li><li>对象操作的可发现性极差：单纯从对象的属性上很难看出来都有哪些业务逻辑，什么时候可以被调用，以及可以赋值的边界是什么；比如说，Long类型的值是否可以是0或者负数？</li><li>代码逻辑重复：比如校验逻辑、计算逻辑，都很容易出现在多个服务、多个代码块里，提升维护成本和bug出现的概率；一类常见的bug就是当贫血模型变更后，校验逻辑由于出现在多个地方，没有能跟着变，导致校验失败或失效。</li><li>代码的健壮性差：比如一个数据模型的变化可能导致从上到下的所有代码的变更。<br>5、强依赖底层实现：业务代码里强依赖了底层数据库、网络&#x2F;中间件协议、第三方服务等，造成核心逻辑代码的僵化且维护成本高。</li></ol><p>虽然贫血模型有很大的缺陷，但是在我们日常的代码中，我见过的99%的代码都是基于贫血模型，为什么呢？我总结了以下几点：</p><ol><li>数据库思维：从有了数据库的那一天起，开发人员的思考方式就逐渐从“写业务逻辑“转变为了”写数据库逻辑”，也就是我们经常说的在写CRUD代码。</li><li>贫血模型简单：贫血模型的优势在于“简单”，仅仅是对数据库表的字段映射，所以可以从前到后用统一格式串通。这里简单打了引号，是因为它只是表面上的简单，实际上当未来有模型变更时，你会发现其实并不简单，每次变更都是非常复杂的事情</li><li>脚本思维：很多常见的代码都属于“脚本”或“胶水代码”，也就是流程式代码。脚本代码的好处就是比较容易理解，但长久来看缺乏健壮性，维护成本会越来越高。</li></ol><p>但是可能最核心的原因在于，实际上我们在日常开发中，混淆了两个概念：</p><ol><li>数据模型（Data Model）：指业务数据该如何持久化，以及数据之间的关系，也就是传统的ER模型； </li><li>业务模型&#x2F;领域模型（Domain Model）：指业务逻辑中，相关联的数据该如何联动。</li></ol><p>所以，解决这个问题的根本方案，就是要在代码里严格区分Data Model和Domain Model，具体的规范会在后文详细描述。在真实代码结构中，Data Model和 Domain Model实际上会分别在不同的层里，Data Model只存在于数据层，而Domain Model在领域层，而链接了这两层的关键对象，就是Repository。</p><h3 id="Repository的价值"><a href="#Repository的价值" class="headerlink" title="Repository的价值"></a>Repository的价值</h3><p>在传统的数据库驱动开发中，我们会对数据库操作做一个封装，一般叫做Data Access Object（DAO）。DAO的核心价值是封装了拼接SQL、维护数据库连接、事务等琐碎的底层逻辑，让业务开发可以专注于写代码。但是在本质上，DAO的操作还是数据库操作，DAO的某个方法还是在直接操作数据库和数据模型，只是少写了部分代码。在Uncle Bob的《代码整洁之道》一书里，作者用了一个非常形象的描述：</p><ol><li>硬件（Hardware）：指创造了之后不可（或者很难）变更的东西。数据库对于开发来说，就属于”硬件“，数据库选型后基本上后面不会再变，比如：用了MySQL就很难再改为MongoDB，改造成本过高。</li><li>软件（Software）：指创造了之后可以随时修改的东西。对于开发来说，业务代码应该追求做”软件“，因为业务流程、规则在不停的变化，我们的代码也应该能随时变化。</li><li>固件（Firmware）：即那些强烈依赖了硬件的软件。我们常见的是路由器里的固件或安卓的固件等等。固件的特点是对硬件做了抽象，但仅能适配某款硬件，不能通用。所以今天不存在所谓的通用安卓固件，而是每个手机都需要有自己的固件。</li></ol><p>从上面的描述我们能看出来，数据库在本质上属于”硬件“，DAO 在本质上属于”固件“，而我们自己的代码希望是属于”软件“。但是，固件有个非常不好的特性，那就是会传播，也就是说当一个软件强依赖了固件时，由于固件的限制，会导致软件也变得难以变更，最终让软件变得跟固件一样难以变更。<br>举个软件很容易被“固化”的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> OrderDAO orderDAO;<br><br><span class="hljs-keyword">public</span> Long <span class="hljs-title function_">addOrder</span><span class="hljs-params">(RequestDTO request)</span> &#123;<br>    <span class="hljs-comment">// 此处省略很多拼装逻辑</span><br>    <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDO</span>();<br>    orderDAO.insertOrder(orderDO);<br>    <span class="hljs-keyword">return</span> orderDO.getId();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(OrderDO orderDO, RequestDTO updateRequest)</span> &#123;<br>    orderDO.setXXX(XXX); <span class="hljs-comment">// 省略很多</span><br>    orderDAO.updateOrder(orderDO);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeBusiness</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> orderDAO.getOrderById(id);<br>    <span class="hljs-comment">// 此处省略很多业务逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的这段简单代码里，该对象依赖了DAO，也就是依赖了DB。虽然乍一看感觉并没什么毛病，但是假设未来要加一个缓存逻辑，代码则需要改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> OrderDAO orderDAO;<br><span class="hljs-keyword">private</span> Cache cache;<br><br><span class="hljs-keyword">public</span> Long <span class="hljs-title function_">addOrder</span><span class="hljs-params">(RequestDTO request)</span> &#123;<br>    <span class="hljs-comment">// 此处省略很多拼装逻辑</span><br>    <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDO</span>();<br>    orderDAO.insertOrder(orderDO);<br>    cache.put(orderDO.getId(), orderDO);<br>    <span class="hljs-keyword">return</span> orderDO.getId();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(OrderDO orderDO, RequestDTO updateRequest)</span> &#123;<br>    orderDO.setXXX(XXX); <span class="hljs-comment">// 省略很多</span><br>    orderDAO.updateOrder(orderDO);<br>    cache.put(orderDO.getId(), orderDO);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeBusiness</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> cache.get(id);<br>    <span class="hljs-keyword">if</span> (orderDO == <span class="hljs-literal">null</span>) &#123;<br>        orderDO = orderDAO.getOrderById(id);<br>    &#125;<br>    <span class="hljs-comment">// 此处省略很多业务逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时，你会发现因为插入的逻辑变化了，导致在所有的使用数据的地方，都需要从1行代码改为至少3行。而当你的代码量变得比较大，然后如果在某个地方你忘记了查缓存，或者在某个地方忘记了更新缓存，轻则需要查数据库，重则是缓存和数据库不一致，导致bug。当你的代码量变得越来越多，直接调用DAO、缓存的地方越来越多时，每次底层变更都会变得越来越难，越来越容易导致bug。这就是软件被“固化”的后果。 所以，我们需要一个模式，能够隔离我们的软件（业务逻辑）和固件&#x2F;硬件（DAO、DB），让我们的软件变得更加健壮，而这个就是Repository的核心价值。</p><h2 id="模型对象代码规范"><a href="#模型对象代码规范" class="headerlink" title="模型对象代码规范"></a>模型对象代码规范</h2><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>在讲Repository规范之前，我们需要先讲清楚3种模型的区别，Entity、Data Object (DO)和Data Transfer Object (DTO)：</p><ol><li>Data Object （DO、数据对象）：实际上是我们在日常工作中最常见的数据模型。但是在DDD的规范里，DO应该仅仅作为数据库物理表格的映射，不能参与到业务逻辑中。为了简单明了，DO的字段类型和名称应该和数据库物理表格的字段类型和名称一一对应，这样我们不需要去跑到数据库上去查一个字段的类型和名称。（当然，实际上也没必要一摸一样，只要你在Mapper那一层做到字段映射）</li><li>Entity（实体对象）：实体对象是我们正常业务应该用的业务模型，它的字段和方法应该和业务语言保持一致，和持久化方式无关。也就是说，Entity和DO很可能有着完全不一样的字段命名和字段类型，甚至嵌套关系。Entity的生命周期应该仅存在于内存中，不需要可序列化和可持久化。</li><li>DTO（传输对象）：主要作为Application层的入参和出参，比如CQRS里的Command、Query、Event，以及Request、Response等都属于DTO的范畴。DTO的价值在于适配不同的业务场景的入参和出参，避免让业务对象变成一个万能大对象。</li></ol><h3 id="模型对象之间的关系"><a href="#模型对象之间的关系" class="headerlink" title="模型对象之间的关系"></a>模型对象之间的关系</h3><p>在实际开发中DO、Entity和DTO不一定是1:1:1的关系。一些常见的非1:1关系如下：</p><p>复杂的Entity拆分多张数据库表：常见的原因在于字段过多，导致查询性能降低，需要将非检索、大字段等单独存为一张表，提升基础信息表的检索效率。常见的案例如商品模型，将商品详细描述等大字段单独保存，提升查询性能：<br><img src="/posts/3260840243/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%B8%89%E8%AE%B2-20220927172755.png" alt=""><br>多个关联的Entity合并一张数据库表：这种情况通常出现在拥有复杂的Aggregate Root - Entity关系的情况下，且需要分库分表，为了避免多次查询和分库分表带来的不一致性，牺牲了单表的简洁性，提升查询和插入性能。常见的案例如主子订单模型：<br><img src="/posts/3260840243/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%B8%89%E8%AE%B2-20220927172814.png" alt=""><br>从复杂Entity里抽取部分信息形成多个DTO：这种情况通常在Entity复杂，但是调用方只需要部分核心信息的情况下，通过一个小的DTO降低信息传输成本。同样拿商品模型举例，基础DTO可能出现在商品列表里，这个时候不需要复杂详情：<br><img src="/posts/3260840243/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%B8%89%E8%AE%B2-20220927172831.png" alt=""><br>合并多个Entity为一个DTO：这种情况通常为了降低网络传输成本，降低服务端请求次数，将多个Entity、DP等对象合并序列化，并且让DTO可以嵌套其他DTO。同样常见的案例是在订单详情里需要展示商品信息：<br><img src="/posts/3260840243/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%B8%89%E8%AE%B2-20220927172900.png" alt=""></p><h3 id="模型所在模块和转化器"><a href="#模型所在模块和转化器" class="headerlink" title="模型所在模块和转化器"></a>模型所在模块和转化器</h3><p>由于现在从一个对象变为3+个对象，对象间需要通过转化器（Converter&#x2F;Mapper）来互相转化。而这三种对象在代码中所在的位置也不一样，简单总结如下：<br><img src="/posts/3260840243/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%B8%89%E8%AE%B2-20220927172919.png" alt=""></p><p>DTO Assembler：在Application层，Entity到DTO的转化器有一个标准的名称叫DTO Assembler。Martin Fowler在P of EAA一书里对于DTO 和 Assembler的描述：<a href="https://link.juejin.cn/?target=https://martinfowler.com/eaaCatalog/dataTransferObject.html?spm=ata.13261165.0.0.590a62fcaM6bCk" title="https://martinfowler.com/eaaCatalog/dataTransferObject.html?spm=ata.13261165.0.0.590a62fcaM6bCk">Data Transfer Object</a>。DTO Assembler的核心作用就是将1个或多个相关联的Entity转化为1个或多个DTO。</p><p>Data Converter：在Infrastructure层，Entity到DO的转化器没有一个标准名称，但是为了区分Data Mapper，我们叫这种转化器Data Converter。这里要注意Data Mapper通常情况下指的是DAO，比如Mybatis的Mapper。Data Mapper的出处也在P of EAA一书里：<a href="https://link.juejin.cn/?target=https://martinfowler.com/eaaCatalog/dataMapper.html?spm=ata.13261165.0.0.590a62fcaM6bCk" title="https://martinfowler.com/eaaCatalog/dataMapper.html?spm=ata.13261165.0.0.590a62fcaM6bCk">Data Mapper</a></p><p>如果是手写一个Assembler，通常我们会去实现2种类型的方法，如下；Data Converter的逻辑和此类似，略过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DtoAssembler</span> &#123;<br>    <span class="hljs-comment">// 通过各种实体，生成DTO</span><br>    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">toDTO</span><span class="hljs-params">(Order order, Item item)</span> &#123;<br>        <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();<br>        dto.setId(order.getId());<br>        dto.setItemTitle(item.getTitle()); <span class="hljs-comment">// 从多个对象里取值，且字段名称不一样</span><br>        dto.setDetailAddress(order.getAddress.getDetail()); <span class="hljs-comment">// 可以读取复杂嵌套字段</span><br>        <span class="hljs-comment">// 省略N行</span><br>        <span class="hljs-keyword">return</span> dto;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过DTO，生成实体</span><br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">toEntity</span><span class="hljs-params">(ItemDTO itemDTO)</span> &#123;<br>        <span class="hljs-type">Item</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>();<br>        entity.setId(itemDTO.getId());<br>        <span class="hljs-comment">// 省略N行</span><br>        <span class="hljs-keyword">return</span> entity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们能看出来通过抽象出一个Assembler&#x2F;Converter对象，我们能把复杂的转化逻辑都收敛到一个对象中，并且可以很好的单元测试。这个也很好的收敛了常见代码里的转化逻辑。 在调用方使用时是非常方便的（请忽略各种异常逻辑）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">private</span> DtoAssembler assembler;<br>    <span class="hljs-keyword">private</span> OrderRepository orderRepository;<br>    <span class="hljs-keyword">private</span> ItemRepository itemRepository;<br><br>    <span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title function_">getOrderDetail</span><span class="hljs-params">(Long orderId)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderRepository.find(orderId);<br>        <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> itemRepository.find(order.getItemId());<br>        <span class="hljs-keyword">return</span> assembler.toDTO(order, item); <span class="hljs-comment">// 原来的很多复杂转化逻辑都收敛到一行代码了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然Assembler&#x2F;Converter是非常好用的对象，但是当业务复杂时，手写Assembler&#x2F;Converter是一件耗时且容易出bug的事情，所以业界会有多种Bean Mapping的解决方案，从本质上分为动态和静态映射。</p><p>动态映射方案包括比较原始的 BeanUtils.copyProperties、能通过xml配置的Dozer等，其核心是在运行时根据反射动态赋值。动态方案的缺陷在于大量的反射调用，性能比较差，内存占用多，不适合特别高并发的应用场景。</p><p>所以在这里我给用Java的同学推荐一个库叫MapStruct（<a href="https://link.juejin.cn/?target=https://mapstruct.org/?spm=ata.13261165.0.0.590a62fcaM6bCk" title="https://mapstruct.org/?spm=ata.13261165.0.0.590a62fcaM6bCk">MapStruct官网</a>）。MapStruct通过注解，在编译时静态生成映射代码，其最终编译出来的代码和手写的代码在性能上完全一致，且有强大的注解等能力。如果你的IDE支持，甚至可以在编译后看到编译出来的映射代码，用来做check。在这里我就不细讲MapStruct的用法了，具体细节请见官网。</p><p>用了MapStruct之后，会节省大量的成本，让代码变得简洁如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.mapstruct.Mapper<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DtoAssembler</span> &#123; <span class="hljs-comment">// 注意这里变成了一个接口，MapStruct会生成实现类</span><br>    <span class="hljs-type">DtoAssembler</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> Mappers.getMapper(DtoAssembler.class);<br><br>    <span class="hljs-comment">// 在这里只需要指出字段不一致的情况，支持复杂嵌套</span><br>    <span class="hljs-meta">@Mapping(target = &quot;itemTitle&quot;, source = &quot;item.title&quot;)</span><br>    <span class="hljs-meta">@Mapping(target = &quot;detailAddress&quot;, source = &quot;order.address.detail&quot;)</span><br>    OrderDTO <span class="hljs-title function_">toDTO</span><span class="hljs-params">(Order order, Item item)</span>;<br><br>    <span class="hljs-comment">// 如果字段没有不一致，一行注解都不需要</span><br>    Item <span class="hljs-title function_">toEntity</span><span class="hljs-params">(ItemDTO itemDTO)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用了MapStruct后，你只需要标注出字段不一致的情况，其他的情况都通过Convention over Configuration帮你解决了。还有很多复杂的用法我就不一一指出了。</p><h3 id="模型规范总结"><a href="#模型规范总结" class="headerlink" title="模型规范总结"></a>模型规范总结</h3><img src="/posts/3260840243/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%B8%89%E8%AE%B2-20220927173022.png" alt=""><p>从使用复杂度角度来看，区分了DO、Entity、DTO带来了代码量的膨胀（从1个变成了3+2+N个）。但是在实际复杂业务场景下，通过功能来区分模型带来的价值是功能性的单一和可测试、可预期，最终反而是逻辑复杂性的降低。</p><h2 id="Repository代码规范"><a href="#Repository代码规范" class="headerlink" title="Repository代码规范"></a>Repository代码规范</h2><h3 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h3><p>上文曾经讲过，传统Data Mapper（DAO）属于“固件”，和底层实现（DB、Cache、文件系统等）强绑定，如果直接使用会导致代码“固化”。所以为了在Repository的设计上体现出“软件”的特性，主要需要注意以下三点：</p><ol><li>接口名称不应该使用底层实现的语法：我们常见的insert、select、update、delete都属于SQL语法，使用这几个词相当于和DB底层实现做了绑定。相反，我们应该把 Repository 当成一个中性的类 似Collection 的接口，使用语法如 find、save、remove。在这里特别需要指出的是区分 insert&#x2F;add 和 update 本身也是一种和底层强绑定的逻辑，一些储存如缓存实际上不存在insert和update的差异，在这个 case 里，使用中性的 save 接口，然后在具体实现上根据情况调用 DAO 的 insert 或 update 接口。</li><li>出参入参不应该使用底层数据格式：需要记得的是 Repository 操作的是 Entity 对象（实际上应该是Aggregate Root），而不应该直接操作底层的 DO 。更近一步，Repository 接口实际上应该存在于Domain层，根本看不到 DO 的实现。这个也是为了避免底层实现逻辑渗透到业务代码中的强保障。</li><li>应该避免所谓的“通用”Repository模式：很多 ORM 框架都提供一个“通用”的Repository接口，然后框架通过注解自动实现接口，比较典型的例子是Spring Data、Entity Framework等，这种框架的好处是在简单场景下很容易通过配置实现，但是坏处是基本上无扩展的可能性（比如加定制缓存逻辑），在未来有可能还是会被推翻重做。当然，这里避免通用不代表不能有基础接口和通用的帮助类，具体如下。 我们先定义一个基础的 Repository 基础接口类，以及一些Marker接口类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Repository</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aggregate</span>&lt;ID&gt;, ID <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Identifier</span>&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将一个Aggregate附属到一个Repository，让它变为可追踪。</span><br><span class="hljs-comment">     * Change-Tracking在下文会讲，非必须</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> T aggregate)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解除一个Aggregate的追踪</span><br><span class="hljs-comment">     * Change-Tracking在下文会讲，非必须</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> T aggregate)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过ID寻找Aggregate。</span><br><span class="hljs-comment">     * 找到的Aggregate自动是可追踪的</span><br><span class="hljs-comment">     */</span><br>    T <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> ID id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将一个Aggregate从Repository移除</span><br><span class="hljs-comment">     * 操作后的aggregate对象自动取消追踪</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> T aggregate)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存一个Aggregate</span><br><span class="hljs-comment">     * 保存后自动重置追踪条件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> T aggregate)</span>;<br>&#125;<br><br><span class="hljs-comment">// 聚合根的Marker接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span>&lt;ID <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Identifier</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entity</span>&lt;ID&gt; &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 实体类的Marker接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Entity</span>&lt;ID <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Identifier</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Identifiable</span>&lt;ID&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Identifiable</span>&lt;ID <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Identifier</span>&gt; &#123;<br>    ID <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// ID类型DP的Marker接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Identifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>业务自己的接口只需要在基础接口上进行扩展，举个订单的例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代码在Domain层</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Repository</span>&lt;Order, OrderId&gt; &#123;<br><br>    <span class="hljs-comment">// 自定义Count接口，在这里OrderQuery是一个自定义的DTO</span><br>    Long <span class="hljs-title function_">count</span><span class="hljs-params">(OrderQuery query)</span>;<br><br>    <span class="hljs-comment">// 自定义分页查询接口</span><br>    Page&lt;Order&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(OrderQuery query)</span>;<br><br>    <span class="hljs-comment">// 自定义有多个条件的查询接口</span><br>    Order <span class="hljs-title function_">findInStore</span><span class="hljs-params">(OrderId id, StoreId storeId)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>每个业务需要根据自己的业务场景来定义各种查询逻辑。</p><p>这里需要再次强调的是Repository的接口是在Domain层，但是实现类是在Infrastructure层。</p><h3 id="Repository基础实现"><a href="#Repository基础实现" class="headerlink" title="Repository基础实现"></a>Repository基础实现</h3><p>先举个Repository的最简单实现的例子。注意OrderRepositoryImpl在Infrastructure层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代码在Infrastructure层</span><br><span class="hljs-meta">@Repository</span> <span class="hljs-comment">// Spring的注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderRepositoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderRepository</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderDAO dao; <span class="hljs-comment">// 具体的DAO接口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderDataConverter converter; <span class="hljs-comment">// 转化器</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderRepositoryImpl</span><span class="hljs-params">(OrderDAO dao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dao = dao;<br>        <span class="hljs-built_in">this</span>.converter = OrderDataConverter.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">find</span><span class="hljs-params">(OrderId orderId)</span> &#123;<br>        <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> dao.findById(orderId.getValue());<br>        <span class="hljs-keyword">return</span> converter.fromData(orderDO);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Order aggregate)</span> &#123;<br>        <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> converter.toData(aggregate);<br>        dao.delete(orderDO);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Order aggregate)</span> &#123;<br>        <span class="hljs-keyword">if</span> (aggregate.getId() != <span class="hljs-literal">null</span> &amp;&amp; aggregate.getId().getValue() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// update</span><br>            <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> converter.toData(aggregate);<br>            dao.update(orderDO);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// insert</span><br>            <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> converter.toData(aggregate);<br>            dao.insert(orderDO);<br>            aggregate.setId(converter.fromData(orderDO).getId());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Page&lt;Order&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(OrderQuery query)</span> &#123;<br>        List&lt;OrderDO&gt; orderDOS = dao.queryPaged(query);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> dao.count(query);<br>        List&lt;Order&gt; result = orderDOS.stream().map(converter::fromData).collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> Page.with(result, query, count);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">findInStore</span><span class="hljs-params">(OrderId id, StoreId storeId)</span> &#123;<br>        <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> dao.findInStore(id.getValue(), storeId.getValue());<br>        <span class="hljs-keyword">return</span> converter.fromData(orderDO);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的实现能看出来一些套路：所有的Entity&#x2F;Aggregate会被转化为DO，然后根据业务场景，调用相应的DAO方法进行操作，事后如果需要则把DO转换回Entity。代码基本很简单，唯一需要注意的是save方法，需要根据Aggregate的ID是否存在且大于0来判断一个Aggregate是否需要更新还是插入。</p><h3 id="Repository复杂实现"><a href="#Repository复杂实现" class="headerlink" title="Repository复杂实现"></a>Repository复杂实现</h3><p>针对单一Entity的Repository实现一般比较简单，但是当涉及到多Entity的Aggregate Root时，就会比较麻烦，最主要的原因是在一次操作中，并不是所有Aggregate里的Entity都需要变更，但是如果用简单的写法，会导致大量的无用DB操作。</p><p>举一个常见的例子，在主子订单的场景下，一个主订单Order会包含多个子订单LineItem，假设有个改某个子订单价格的操作，会同时改变主订单价格，但是对其他子订单无影响：<br><img src="/posts/3260840243/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%B8%89%E8%AE%B2-20220927182100.png" alt=""><br>如果用一个非常naive的实现来完成，会导致多出来两个无用的更新操作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderRepositoryImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">implements</span> OrderRepository &#123;<br>    <span class="hljs-keyword">private</span> OrderDAO orderDAO;<br>    <span class="hljs-keyword">private</span> LineItemDAO lineItemDAO;<br>    <span class="hljs-keyword">private</span> OrderDataConverter orderConverter;<br>    <span class="hljs-keyword">private</span> LineItemDataConverter lineItemConverter;<br><br>    <span class="hljs-comment">// 其他逻辑省略</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Order aggregate)</span> &#123;<br>        <span class="hljs-keyword">if</span> (aggregate.getId() != <span class="hljs-literal">null</span> &amp;&amp; aggregate.getId().getValue() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 每次都将Order和所有LineItem全量更新</span><br>            <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> orderConverter.toData(aggregate);<br>            orderDAO.update(orderDO);<br>            <span class="hljs-keyword">for</span> (LineItem lineItem: aggregate.getLineItems()) &#123;<br>                save(lineItem);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 插入逻辑省略</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(LineItem lineItem)</span> &#123;<br>        <span class="hljs-keyword">if</span> (lineItem.getId() != <span class="hljs-literal">null</span> &amp;&amp; lineItem.getId().getValue() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">LineItemDO</span> <span class="hljs-variable">lineItemDO</span> <span class="hljs-operator">=</span> lineItemConverter.toData(lineItem);<br>            lineItemDAO.update(lineItemDO);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">LineItemDO</span> <span class="hljs-variable">lineItemDO</span> <span class="hljs-operator">=</span> lineItemConverter.toData(lineItem);<br>            lineItemDAO.insert(lineItemDO);<br>            lineItem.setId(lineItemConverter.fromData(lineItemDO).getId());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个情况下，会导致4个UPDATE操作，但实际上只需要2个。在绝大部分情况下，这个成本不高，可以接受，但是在极端情况下（当非Aggregate Root的Entity非常多时），会导致大量的无用写操作。</p><h3 id="Change-Tracking-变更追踪"><a href="#Change-Tracking-变更追踪" class="headerlink" title="Change-Tracking 变更追踪"></a>Change-Tracking 变更追踪</h3><p>在上面那个案例里，核心的问题是由于Repository接口规范的限制，让调用方仅能操作Aggregate Root，而无法单独针对某个非Aggregate Root的Entity直接操作。这个和直接调用DAO的方式很不一样。</p><p>这个的解决方案是需要能识别到底哪些Entity有变更，并且只针对那些变更过的Entity做操作，就需要加上变更追踪的能力。换一句话说就是原来很多人为判断的代码逻辑，现在可以通过变更追踪来自动实现，让使用方真正只关心Aggregate的操作。在上一个案例里，通过变更追踪，系统可以判断出来只有LineItem2 和 Order 有变更，所以只需要生成两个UPDATE即可。</p><p>业界有两个主流的变更追踪方案：</p><ol><li>基于Snapshot的方案：当数据从DB里取出来后，在内存中保存一份snapshot，然后在数据写入时和snapshot比较。常见的实现如Hibernate</li><li>基于Proxy的方案：当数据从DB里取出来后，通过weaving的方式将所有setter都增加一个切面来判断setter是否被调用以及值是否变更，如果变更则标记为Dirty。在保存时根据Dirty判断是否需要更新。常见的实现如Entity Framework。</li></ol><p>Snapshot方案的好处是比较简单，成本在于每次保存时全量Diff的操作（一般用Reflection），以及保存Snapshot的内存消耗。 Proxy方案的好处是性能很高，几乎没有增加的成本，但是坏处是实现起来比较困难，且当有嵌套关系存在时不容易发现嵌套对象的变化（比如子List的增加和删除等），有可能导致bug。</p><p>由于Proxy方案的复杂度，业界主流（包括EF Core）都在使用Snapshot方案。这里面还有另一个好处就是通过Diff可以发现哪些字段有变更，然后只更新变更过的字段，再一次降低UPDATE的成本。</p><p>在这里我简单贴一下我们自己Snapshot的实现，代码并不复杂，每个团队自己实现起来也很简单，部分代码仅供参考：</p><p><strong>DbRepositorySupport</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个类是一个通用的支撑类，为了减少开发者的重复劳动。在用的时候需要继承这个类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DbRepositorySupport</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aggregate</span>&lt;ID&gt;, ID <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Identifier</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Repository</span>&lt;T, ID&gt; &#123;<br><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; targetClass;<br><br>    <span class="hljs-comment">// 让AggregateManager去维护Snapshot</span><br>    <span class="hljs-meta">@Getter(AccessLevel.PROTECTED)</span><br>    <span class="hljs-keyword">private</span> AggregateManager&lt;T, ID&gt; aggregateManager;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">DbRepositorySupport</span><span class="hljs-params">(Class&lt;T&gt; targetClass)</span> &#123;<br>        <span class="hljs-built_in">this</span>.targetClass = targetClass;<br>        <span class="hljs-built_in">this</span>.aggregateManager = AggregateManager.newInstance(targetClass);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这几个方法是继承的子类应该去实现的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInsert</span><span class="hljs-params">(T aggregate)</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">onSelect</span><span class="hljs-params">(ID id)</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUpdate</span><span class="hljs-params">(T aggregate, EntityDiff diff)</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDelete</span><span class="hljs-params">(T aggregate)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Attach的操作就是让Aggregate可以被追踪</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> T aggregate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aggregateManager.attach(aggregate);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Detach的操作就是让Aggregate停止追踪</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> T aggregate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aggregateManager.detach(aggregate);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> ID id)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">aggregate</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.onSelect(id);<br>        <span class="hljs-keyword">if</span> (aggregate != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 这里的就是让查询出来的对象能够被追踪。</span><br>            <span class="hljs-comment">// 如果自己实现了一个定制查询接口，要记得单独调用attach。</span><br>            <span class="hljs-built_in">this</span>.attach(aggregate);<br>        &#125;<br>        <span class="hljs-keyword">return</span> aggregate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> T aggregate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.onDelete(aggregate);<br>        <span class="hljs-comment">// 删除停止追踪</span><br>        <span class="hljs-built_in">this</span>.detach(aggregate);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> T aggregate)</span> &#123;<br>        <span class="hljs-comment">// 如果没有ID，直接插入</span><br>        <span class="hljs-keyword">if</span> (aggregate.getId() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.onInsert(aggregate);<br>            <span class="hljs-built_in">this</span>.attach(aggregate);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 做Diff</span><br>        <span class="hljs-type">EntityDiff</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> aggregateManager.detectChanges(aggregate);<br>        <span class="hljs-keyword">if</span> (diff.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 调用UPDATE</span><br>        <span class="hljs-built_in">this</span>.onUpdate(aggregate, diff);<br><br>        <span class="hljs-comment">// 最终将DB带来的变化更新回AggregateManager</span><br>        aggregateManager.merge(aggregate);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用方只需要继承DbRepositorySupport：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderRepositoryImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DbRepositorySupport</span>&lt;Order, OrderId&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderRepository</span> &#123;<br>    <span class="hljs-keyword">private</span> OrderDAO orderDAO;<br>    <span class="hljs-keyword">private</span> LineItemDAO lineItemDAO;<br>    <span class="hljs-keyword">private</span> OrderDataConverter orderConverter;<br>    <span class="hljs-keyword">private</span> LineItemDataConverter lineItemConverter;<br><br>    <span class="hljs-comment">// 部分代码省略，见上文</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUpdate</span><span class="hljs-params">(Order aggregate, EntityDiff diff)</span> &#123;<br>        <span class="hljs-keyword">if</span> (diff.isSelfModified()) &#123;<br>            <span class="hljs-type">OrderDO</span> <span class="hljs-variable">orderDO</span> <span class="hljs-operator">=</span> converter.toData(aggregate);<br>            orderDAO.update(orderDO);<br>        &#125;<br><br>        <span class="hljs-type">Diff</span> <span class="hljs-variable">lineItemDiffs</span> <span class="hljs-operator">=</span> diff.getDiff(<span class="hljs-string">&quot;lineItems&quot;</span>);<br>        <span class="hljs-keyword">if</span> (lineItemDiffs <span class="hljs-keyword">instanceof</span> ListDiff) &#123;<br>            <span class="hljs-type">ListDiff</span> <span class="hljs-variable">diffList</span> <span class="hljs-operator">=</span> (ListDiff) lineItemDiffs;<br>            <span class="hljs-keyword">for</span> (Diff itemDiff : diffList) &#123;<br>                <span class="hljs-keyword">if</span> (itemDiff.getType() == DiffType.Removed) &#123;<br>                    <span class="hljs-type">LineItem</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> (LineItem) itemDiff.getOldValue();<br>                    <span class="hljs-type">LineItemDO</span> <span class="hljs-variable">lineDO</span> <span class="hljs-operator">=</span> lineItemConverter.toData(line);<br>                    lineItemDAO.delete(lineDO);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (itemDiff.getType() == DiffType.Added) &#123;<br>                    <span class="hljs-type">LineItem</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> (LineItem) itemDiff.getNewValue();<br>                    <span class="hljs-type">LineItemDO</span> <span class="hljs-variable">lineDO</span> <span class="hljs-operator">=</span> lineItemConverter.toData(line);<br>                    lineItemDAO.insert(lineDO);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (itemDiff.getType() == DiffType.Modified) &#123;<br>                    <span class="hljs-type">LineItem</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> (LineItem) itemDiff.getNewValue();<br>                    <span class="hljs-type">LineItemDO</span> <span class="hljs-variable">lineDO</span> <span class="hljs-operator">=</span> lineItemConverter.toData(line);<br>                    lineItemDAO.update(lineDO);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AggregateManager实现，主要是通过ThreadLocal避免多线程公用同一个Entity的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalAggregateManager</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aggregate</span>&lt;ID&gt;, ID <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Identifier</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AggregateManager</span>&lt;T, ID&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> ThreadLocal&lt;DbContext&lt;T, ID&gt;&gt; context;<br>    <span class="hljs-keyword">private</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; targetClass;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadLocalAggregateManager</span><span class="hljs-params">(Class&lt;? extends T&gt; targetClass)</span> &#123;<br>        <span class="hljs-built_in">this</span>.targetClass = targetClass;<br>        <span class="hljs-built_in">this</span>.context = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">DbContext</span>&lt;&gt;(targetClass));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(T aggregate)</span> &#123;<br>        context.get().attach(aggregate);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(T aggregate, ID id)</span> &#123;<br>        context.get().setId(aggregate, id);<br>        context.get().attach(aggregate);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(T aggregate)</span> &#123;<br>        context.get().detach(aggregate);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">find</span><span class="hljs-params">(ID id)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.get().find(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EntityDiff <span class="hljs-title function_">detectChanges</span><span class="hljs-params">(T aggregate)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.get().detectChanges(aggregate);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(T aggregate)</span> &#123;<br>        context.get().merge(aggregate);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DbContext</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aggregate</span>&lt;ID&gt;, ID <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Identifier</span>&gt; &#123;<br><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; aggregateClass;<br><br>    <span class="hljs-keyword">private</span> Map&lt;ID, T&gt; aggregateMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DbContext</span><span class="hljs-params">(Class&lt;? extends T&gt; aggregateClass)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aggregateClass = aggregateClass;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(T aggregate)</span> &#123;<br>        <span class="hljs-keyword">if</span> (aggregate.getId() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!aggregateMap.containsKey(aggregate.getId())) &#123;<br>                <span class="hljs-built_in">this</span>.merge(aggregate);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(T aggregate)</span> &#123;<br>        <span class="hljs-keyword">if</span> (aggregate.getId() != <span class="hljs-literal">null</span>) &#123;<br>            aggregateMap.remove(aggregate.getId());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> EntityDiff <span class="hljs-title function_">detectChanges</span><span class="hljs-params">(T aggregate)</span> &#123;<br>        <span class="hljs-keyword">if</span> (aggregate.getId() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> EntityDiff.EMPTY;<br>        &#125;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> aggregateMap.get(aggregate.getId());<br>        <span class="hljs-keyword">if</span> (snapshot == <span class="hljs-literal">null</span>) &#123;<br>            attach(aggregate);<br>        &#125;<br>        <span class="hljs-keyword">return</span> DiffUtils.diff(snapshot, aggregate);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">find</span><span class="hljs-params">(ID id)</span> &#123;<br>        <span class="hljs-keyword">return</span> aggregateMap.get(id);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(T aggregate)</span> &#123;<br>        <span class="hljs-keyword">if</span> (aggregate.getId() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> SnapshotUtils.snapshot(aggregate);<br>            aggregateMap.put(aggregate.getId(), snapshot);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(T aggregate, ID id)</span> &#123;<br>        ReflectionUtils.writeField(<span class="hljs-string">&quot;id&quot;</span>, aggregate, id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>跑个单测（注意在这个case里我把Order和LineItem合并单表了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multiInsert</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">OrderDAO</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockOrderDAO</span>();<br>    <span class="hljs-type">OrderRepository</span> <span class="hljs-variable">repo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderRepositoryImpl</span>(dao);<br><br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>    order.setUserId(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserId</span>(<span class="hljs-number">11L</span>));<br>    order.setStatus(OrderState.ENABLED);<br>    order.addLineItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemId</span>(<span class="hljs-number">13L</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quantity</span>(<span class="hljs-number">5</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Money</span>(<span class="hljs-number">4</span>));<br>    order.addLineItem(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemId</span>(<span class="hljs-number">14L</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quantity</span>(<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Money</span>(<span class="hljs-number">3</span>));<br><br>    System.out.println(<span class="hljs-string">&quot;第一次保存前&quot;</span>);<br>    System.out.println(order);<br><br>    repo.save(order);<br>    System.out.println(<span class="hljs-string">&quot;第一次保存后&quot;</span>);<br>    System.out.println(order);<br><br>    order.getLineItems().get(<span class="hljs-number">0</span>).setQuantity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Quantity</span>(<span class="hljs-number">3</span>));<br>    order.pay();<br>    repo.save(order);<br><br>    System.out.println(<span class="hljs-string">&quot;第二次保存后&quot;</span>);<br>    System.out.println(order);<br>&#125;<br></code></pre></td></tr></table></figure><p>单测结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">第一次保存前<br>Order(id=<span class="hljs-literal">null</span>, userId=<span class="hljs-number">11</span>, lineItems=[LineItem(id=<span class="hljs-literal">null</span>, itemId=<span class="hljs-number">13</span>, quantity=<span class="hljs-number">5</span>, price=<span class="hljs-number">4</span>), LineItem(id=<span class="hljs-literal">null</span>, itemId=<span class="hljs-number">14</span>, quantity=<span class="hljs-number">2</span>, price=<span class="hljs-number">3</span>)], status=ENABLED)<br><br>INSERT OrderDO: OrderDO(id=<span class="hljs-literal">null</span>, parentId=<span class="hljs-literal">null</span>, itemId=<span class="hljs-number">0</span>, userId=<span class="hljs-number">11</span>, quantity=<span class="hljs-number">0</span>, price=<span class="hljs-number">0</span>, status=<span class="hljs-number">2</span>)<br>UPDATE OrderDO: OrderDO(id=<span class="hljs-number">1001</span>, parentId=<span class="hljs-number">1001</span>, itemId=<span class="hljs-number">0</span>, userId=<span class="hljs-number">11</span>, quantity=<span class="hljs-number">0</span>, price=<span class="hljs-number">0</span>, status=<span class="hljs-number">2</span>)<br>INSERT OrderDO: OrderDO(id=<span class="hljs-literal">null</span>, parentId=<span class="hljs-number">1001</span>, itemId=<span class="hljs-number">13</span>, userId=<span class="hljs-number">11</span>, quantity=<span class="hljs-number">5</span>, price=<span class="hljs-number">4</span>, status=<span class="hljs-number">2</span>)<br>INSERT OrderDO: OrderDO(id=<span class="hljs-literal">null</span>, parentId=<span class="hljs-number">1001</span>, itemId=<span class="hljs-number">14</span>, userId=<span class="hljs-number">11</span>, quantity=<span class="hljs-number">2</span>, price=<span class="hljs-number">3</span>, status=<span class="hljs-number">2</span>)<br><br>第一次保存后<br>Order(id=<span class="hljs-number">1001</span>, userId=<span class="hljs-number">11</span>, lineItems=[LineItem(id=<span class="hljs-number">1002</span>, itemId=<span class="hljs-number">13</span>, quantity=<span class="hljs-number">5</span>, price=<span class="hljs-number">4</span>), LineItem(id=<span class="hljs-number">1003</span>, itemId=<span class="hljs-number">14</span>, quantity=<span class="hljs-number">2</span>, price=<span class="hljs-number">3</span>)], status=ENABLED)<br><br>UPDATE OrderDO: OrderDO(id=<span class="hljs-number">1001</span>, parentId=<span class="hljs-number">1001</span>, itemId=<span class="hljs-number">0</span>, userId=<span class="hljs-number">11</span>, quantity=<span class="hljs-number">0</span>, price=<span class="hljs-number">0</span>, status=<span class="hljs-number">3</span>)<br>UPDATE OrderDO: OrderDO(id=<span class="hljs-number">1002</span>, parentId=<span class="hljs-number">1001</span>, itemId=<span class="hljs-number">13</span>, userId=<span class="hljs-number">11</span>, quantity=<span class="hljs-number">3</span>, price=<span class="hljs-number">4</span>, status=<span class="hljs-number">3</span>)<br><br>第二次保存后<br>Order(id=<span class="hljs-number">1001</span>, userId=<span class="hljs-number">11</span>, lineItems=[LineItem(id=<span class="hljs-number">1002</span>, itemId=<span class="hljs-number">13</span>, quantity=<span class="hljs-number">3</span>, price=<span class="hljs-number">4</span>), LineItem(id=<span class="hljs-number">1003</span>, itemId=<span class="hljs-number">14</span>, quantity=<span class="hljs-number">2</span>, price=<span class="hljs-number">3</span>)], status=PAID)<br></code></pre></td></tr></table></figure><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><p><strong>并发乐观锁</strong><br>在高并发情况下，如果使用上面的Change-Tracking方法，由于Snapshot在本地内存的数据_有可能_ 和DB数据不一致，会导致并发冲突的问题，这个时候需要在更新时加入乐观锁。当然，正常数据库操作的Best Practice应该也要有乐观锁，只不过在这个case 里，需要在乐观锁冲突后，记得更新本地Snapshot里的值。</p><p><strong>一个可能的BUG</strong><br>这个其实算不上bug，但是单独指出来希望大家能注意一下，使用Snapshot的一个副作用就是如果没更新Entity然后调用了save方法，这时候实际上是不会去更新DB的。这个逻辑跟Hibernate的逻辑一致，是Snapshot方法的天生特性。如果要强制更新到DB，建议手动更改一个字段如gmtModified，然后再调用save。</p><h2 id="Repository迁移路径"><a href="#Repository迁移路径" class="headerlink" title="Repository迁移路径"></a>Repository迁移路径</h2><p>在我们日常的代码中，使用Repository模式是一个很简单，但是又能得到很多收益的事情。最大的收益就是可以彻底和底层实现解耦，让上层业务可以快速自发展。</p><p>我们假设现有的传统代码包含了以下几个类（还是用订单举例）：</p><ul><li>OrderDO</li><li>OrderDAO</li></ul><p>可以通过以下几个步骤逐渐的实现Repository模式：</p><ol><li>生成Order实体类，初期字段可以和OrderDO保持一致 </li><li>生成OrderDataConverter，通过MapStruct基本上2行代码就能完成 </li><li>写单元测试，确保Order和OrderDO之间的转化100%正确 </li><li>生成OrderRepository接口和实现，通过单测确保OrderRepository的正确性 </li><li>将原有代码里使用了OrderDO的地方改为Order </li><li>将原有代码里使用了OrderDAO的地方都改为用OrderRepository </li><li>通过单测确保业务逻辑的一致性。</li></ol><p>恭喜你！从现在开始Order实体类和其业务逻辑可以随意更改，每次修改你唯一需要做的就是变更一下Converter，已经和底层实现完全解藕了。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>DDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>转载</tag>
      
      <tag>DDD详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD详解-第二讲[转载]</title>
    <link href="/posts/983808872/"/>
    <url>/posts/983808872/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文为转载，原文链接为: <a href="https://juejin.cn/post/6844904201575743495">https://juejin.cn/post/6844904201575743495</a></p>          </div><h1 id="DDD-详解-应用架构"><a href="#DDD-详解-应用架构" class="headerlink" title="DDD 详解-应用架构"></a>DDD 详解-应用架构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>架构这个词源于英文里的“Architecture“，源头是土木工程里的“建筑”和“结构”，而架构里的”架“同时又包含了”架子“（scaffolding）的含义，意指能快速搭建起来的固定结构。而今天的应用架构，意指软件系统中固定不变的代码结构、设计模式、规范和组件间的通信方式。在应用开发中架构之所以是最重要的第一步，因为一个好的架构能让系统安全、稳定、快速迭代。在一个团队内通过规定一个固定的架构设计，可以让团队内能力参差不齐的同学们都能有一个统一的开发规范，降低沟通成本，提升效率和代码质量。</p><p>在做架构设计时，一个好的架构应该需要实现以下几个目标：</p><ol><li>独立于框架：架构不应该依赖某个外部的库或框架，不应该被框架的结构所束缚。</li><li>独立于UI：前台展示的样式可能会随时发生变化（今天可能是网页、明天可能变成console、后天是独立app），但是底层架构不应该随之而变化。</li><li>独立于底层数据源：无论今天你用MySQL、Oracle还是MongoDB、CouchDB，甚至使用文件系统，软件架构不应该因为不同的底层数据储存方式而产生巨大改变。</li><li>独立于外部依赖：无论外部依赖如何变更、升级，业务的核心逻辑不应该随之而大幅变化。</li><li>可测试：无论外部依赖了什么数据库、硬件、UI或者服务，业务的逻辑应该都能够快速被验证正确性。</li></ol><p>这就好像是建筑中的楼宇，一个好的楼宇，无论内部承载了什么人、有什么样的活动、还是外部有什么风雨，一栋楼都应该屹立不倒，而且可以确保它不会倒。但是今天我们在做业务研发时，更多的会去关注一些宏观的架构，比如SOA架构、微服务架构，而忽略了应用内部的架构设计，很容易导致代码逻辑混乱，很难维护，容易产生bug而且很难发现。今天，我希望能够通过案例的分析和重构，来推演出一套高质量的DDD架构。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>我们先看一个简单的案例需求如下：<br>用户可以通过银行网页转账给另一个账号，支持跨币种转账。<br>同时因为监管和对账需求，需要记录本次转账活动。<br>拿到这个需求之后，一个开发可能会经历一些技术选型，最终可能拆解需求如下：</p><ol><li>从MySql数据库中找到转出和转入的账户，选择用 MyBatis 的 mapper 实现 DAO；</li><li>从 Yahoo（或其他渠道）提供的汇率服务获取转账的汇率信息（底层是 http 开放接口）；</li><li>计算需要转出的金额，确保账户有足够余额，并且没超出每日转账上限；</li><li>实现转入和转出操作，扣除手续费，保存数据库；</li><li>发送 Kafka 审计消息，以便审计和对账用；</li></ol><p>而一个简单的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TransferService transferService;<br><br>    <span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title function_">transfer</span><span class="hljs-params">(String targetAccountNumber, BigDecimal amount, HttpSession session)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (Long) session.getAttribute(<span class="hljs-string">&quot;userId&quot;</span>);<br>        <span class="hljs-keyword">return</span> transferService.transfer(userId, targetAccountNumber, amount, <span class="hljs-string">&quot;CNY&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TOPIC_AUDIT_LOG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TOPIC_AUDIT_LOG&quot;</span>;<br>    <span class="hljs-keyword">private</span> AccountMapper accountDAO;<br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;<br>    <span class="hljs-keyword">private</span> YahooForexService yahooForex;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title function_">transfer</span><span class="hljs-params">(Long sourceUserId, String targetAccountNumber, BigDecimal targetAmount, String targetCurrency)</span> &#123;<br>        <span class="hljs-comment">// 1. 从数据库读取数据，忽略所有校验逻辑如账号是否存在等</span><br>        <span class="hljs-type">AccountDO</span> <span class="hljs-variable">sourceAccountDO</span> <span class="hljs-operator">=</span> accountDAO.selectByUserId(sourceUserId);<br>        <span class="hljs-type">AccountDO</span> <span class="hljs-variable">targetAccountDO</span> <span class="hljs-operator">=</span> accountDAO.selectByAccountNumber(targetAccountNumber);<br><br>        <span class="hljs-comment">// 2. 业务参数校验</span><br>        <span class="hljs-keyword">if</span> (!targetAccountDO.getCurrency().equals(targetCurrency)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCurrencyException</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 获取外部数据，并且包含一定的业务逻辑</span><br>        <span class="hljs-comment">// exchange rate = 1 source currency = X target currency</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">exchangeRate</span> <span class="hljs-operator">=</span> BigDecimal.ONE;<br>        <span class="hljs-keyword">if</span> (sourceAccountDO.getCurrency().equals(targetCurrency)) &#123;<br>            exchangeRate = yahooForex.getExchangeRate(sourceAccountDO.getCurrency(), targetCurrency);<br>        &#125;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">sourceAmount</span> <span class="hljs-operator">=</span> targetAmount.divide(exchangeRate, RoundingMode.DOWN);<br><br>        <span class="hljs-comment">// 4. 业务参数校验</span><br>        <span class="hljs-keyword">if</span> (sourceAccountDO.getAvailable().compareTo(sourceAmount) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsufficientFundsException</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (sourceAccountDO.getDailyLimit().compareTo(sourceAmount) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DailyLimitExceededException</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 5. 计算新值，并且更新字段</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">newSource</span> <span class="hljs-operator">=</span> sourceAccountDO.getAvailable().subtract(sourceAmount);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">newTarget</span> <span class="hljs-operator">=</span> targetAccountDO.getAvailable().add(targetAmount);<br>        sourceAccountDO.setAvailable(newSource);<br>        targetAccountDO.setAvailable(newTarget);<br><br>        <span class="hljs-comment">// 6. 更新到数据库</span><br>        accountDAO.update(sourceAccountDO);<br>        accountDAO.update(targetAccountDO);<br><br>        <span class="hljs-comment">// 7. 发送审计消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sourceUserId + <span class="hljs-string">&quot;,&quot;</span> + targetAccountNumber + <span class="hljs-string">&quot;,&quot;</span> + targetAmount + <span class="hljs-string">&quot;,&quot;</span> + targetCurrency;<br>        kafkaTemplate.send(TOPIC_AUDIT_LOG, message);<br><br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，一段业务代码里经常包含了参数校验、数据读取存储、业务计算、调用外部服务、发送消息等多种逻辑。在这个案例里虽然是写在了同一个方法里，在真实代码中经常会被拆分成多个子方法，但实际效果是一样的，而在我们日常的工作中，绝大部分代码都或多或少的接近于此类结构。在Martin Fowler的 P of EAA书中，这种很常见的代码样式被叫做Transaction Script（事务脚本）。虽然这种类似于脚本的写法在功能上没有什么问题，但是长久来看，他有以下几个很大的问题：可维护性差、可扩展性差、可测试性差。</p><h3 id="问题1-可维护性能差"><a href="#问题1-可维护性能差" class="headerlink" title="问题1-可维护性能差"></a>问题1-可维护性能差</h3><p>一个应用最大的成本一般都不是来自于开发阶段，而是应用整个生命周期的总维护成本，所以代码的可维护性代表了最终成本。<br><strong>可维护性 &#x3D; 当依赖变化时，有多少代码需要随之改变</strong></p><p>参考以上的案例代码，事务脚本类的代码很难维护因为以下几点：</p><ol><li>数据结构的不稳定性：AccountDO类是一个纯数据结构，映射了数据库中的一个表。这里的问题是数据库的表结构和设计是应用的外部依赖，长远来看都有可能会改变，比如数据库要做Sharding，或者换一个表设计，或者改变字段名。</li><li>依赖库的升级：AccountMapper依赖MyBatis的实现，如果MyBatis未来升级版本，可能会造成用法的不同（可以参考iBatis升级到基于注解的MyBatis的迁移成本）。同样的，如果未来换一个ORM体系，迁移成本也是巨大的。</li><li>第三方服务依赖的不确定性：第三方服务，比如Yahoo的汇率服务未来很有可能会有变化：轻则API签名变化，重则服务不可用需要寻找其他可替代的服务。在这些情况下改造和迁移成本都是巨大的。同时，外部依赖的兜底、限流、熔断等方案都需要随之改变。</li><li>第三方服务API的接口变化：YahooForexService.getExchangeRate返回的结果是小数点还是百分比？入参是（source, target）还是（target, source）？谁能保证未来接口不会改变？如果改变了，核心的金额计算逻辑必须跟着改，否则会造成资损。</li><li>中间件更换：今天我们用Kafka发消息，明天如果要上阿里云用RocketMQ该怎么办？后天如果消息的序列化方式从String改为Binary该怎么办？如果需要消息分片该怎么改？<br>我们发现案例里的代码对于任何外部依赖的改变都会有比较大的影响。如果你的应用里有大量的此类代码，你每一天的时间基本上会被各种库升级、依赖服务升级、中间件升级、jar包冲突占满，最终这个应用变成了一个不敢升级、不敢部署、不敢写新功能、并且随时会爆发的炸弹，终有一天会给你带来惊喜。</li></ol><h3 id="问题2-可拓展性差"><a href="#问题2-可拓展性差" class="headerlink" title="问题2-可拓展性差"></a>问题2-可拓展性差</h3><p>事务脚本式代码的第二大缺陷是：虽然写单个用例的代码非常高效简单，但是当用例多起来时，其扩展性会变得越来越差。<br><strong>可扩展性 &#x3D; 做新需求或改逻辑时，需要新增&#x2F;修改多少代码</strong></p><p>参考以上的代码，如果今天需要增加一个跨行转账的能力，你会发现基本上需要重新开发，基本上没有任何的可复用性：</p><ol><li>数据来源被固定、数据格式不兼容：原有的AccountDO是从本地获取的，而跨行转账的数据可能需要从一个第三方服务获取，而服务之间数据格式不太可能是兼容的，导致从数据校验、数据读写、到异常处理、金额计算等逻辑都要重写。</li><li>业务逻辑无法复用：数据格式不兼容的问题会导致核心业务逻辑无法复用。每个用例都是特殊逻辑的后果是最终会造成大量的if-else语句，而这种分支多的逻辑会让分析代码非常困难，容易错过边界情况，造成 bug。</li><li>逻辑和数据存储的相互依赖：当业务逻辑增加变得越来越复杂时，新加入的逻辑很有可能需要对数据库schema或消息格式做变更。而变更了数据格式后会导致原有的其他逻辑需要一起跟着动。在最极端的场景下，一个新功能的增加会导致所有原有功能的重构，成本巨大。<br>在事务脚本式的架构下，一般做第一个需求都非常的快，但是做第N个需求时需要的时间很有可能是呈指数级上升的，绝大部分时间花费在老功能的重构和兼容上，最终你的创新速度会跌为0，促使老应用被推翻重构。</li></ol><h3 id="问题3-可测试性能差"><a href="#问题3-可测试性能差" class="headerlink" title="问题3-可测试性能差"></a>问题3-可测试性能差</h3><p>除了部分工具类、框架类和中间件类的代码有比较高的测试覆盖之外，我们在日常工作中很难看到业务代码有比较好的测试覆盖，而绝大部分的上线前的测试属于人肉的“集成测试”。低测试率导致我们对代码质量很难有把控，容易错过边界条件，异常case只有线上爆发了才被动发现。而低测试覆盖率的主要原因是业务代码的可测试性比较差。<br><strong>可测试性 &#x3D; 运行每个测试用例所花费的时间 * 每个需求所需要增加的测试用例数量</strong></p><p>参考以上的一段代码，这种代码有极低的可测试性：</p><ol><li>设施搭建困难：当代码中强依赖了数据库、第三方服务、中间件等外部依赖之后，想要完整跑通一个测试用例需要确保所有依赖都能跑起来，这个在项目早期是及其困难的。在项目后期也会由于各种系统的不稳定性而导致测试无法通过。</li><li>运行耗时长：大多数的外部依赖调用都是I&#x2F;O密集型，如跨网络调用、磁盘调用等，而这种I&#x2F;O调用在测试时需要耗时很久。另一个经常依赖的是笨重的框架如Spring，启动Spring容器通常需要很久。当一个测试用例需要花超过10秒钟才能跑通时，绝大部分开发都不会很频繁的测试。</li><li>耦合度高：假如一段脚本中有A、B、C三个子步骤，而每个步骤有N个可能的状态，当多个子步骤耦合度高时，为了完整覆盖所有用例，最多需要有N * N * N个测试用例。当耦合的子步骤越多时，需要的测试用例呈指数级增长。<br>在事务脚本模式下，当测试用例复杂度远大于真实代码复杂度，当运行测试用例的耗时超出人肉测试时，绝大部分人会选择不写完整的测试覆盖，而这种情况通常就是bug很难被早点发现的原因。</li></ol><h3 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h3><p>我们重新来分析一下为什么以上的问题会出现？因为以上的代码违背了至少以下几个软件设计的原则：</p><ol><li>单一性原则（Single Responsibility Principle）：单一性原则要求一个对象&#x2F;类应该只有一个变更的原因。但是在这个案例里，代码可能会因为任意一个外部依赖或计算逻辑的改变而改变。</li><li>依赖反转原则（Dependency Inversion Principle）：依赖反转原则要求在代码中依赖抽象，而不是具体的实现。在这个案例里外部依赖都是具体的实现，比如YahooForexService虽然是一个接口类，但是它对应的是依赖了Yahoo提供的具体服务，所以也算是依赖了实现。同样的 KafkaTemplate、MyBatis 的 DAO 实现都属于具体实现。</li><li>开放封闭原则（Open Closed Principle）：开放封闭原则指开放扩展，但是封闭修改。在这个案例里的金额计算属于可能会被修改的代码，这个时候该逻辑应该需要被包装成为不可修改的计算类，新功能通过计算类的拓展实现。<br>我们需要对代码重构才能解决这些问题。</li></ol><h2 id="重构方案"><a href="#重构方案" class="headerlink" title="重构方案"></a>重构方案</h2><p>在重构之前，我们先画一张流程图，描述当前代码在做的每个步骤：<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927164246.png" alt=""><br>这是一个传统的三层分层结构：UI层、业务层、和基础设施层。上层对于下层有直接的依赖关系，导致耦合度过高。在业务层中对于下层的基础设施有强依赖，耦合度高。我们需要对这张图上的每个节点做抽象和整理，来降低对外部依赖的耦合度。</p><h3 id="抽象数据存储层"><a href="#抽象数据存储层" class="headerlink" title="抽象数据存储层"></a>抽象数据存储层</h3><p>第一步常见的操作是将Data Access层做抽象，降低系统对数据库的直接依赖。具体的方法如下：</p><ol><li>新建Account实体对象：一个实体（Entity）是拥有ID的域对象，除了拥有数据之外，同时拥有行为。Entity和数据库储存格式无关，在设计中要以该领域的通用严谨语言（Ubiquitous Language）为依据。</li><li>新建对象储存接口类AccountRepository：Repository只负责Entity对象的存储和读取，而Repository的实现类完成数据库存储的细节。通过加入Repository接口，底层的数据库连接可以通过不同的实现类而替换。<br>具体的简单代码实现如下：</li></ol><p><strong>Account 实体类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> AccountId id;<br>    <span class="hljs-keyword">private</span> AccountNumber accountNumber;<br>    <span class="hljs-keyword">private</span> UserId userId;<br>    <span class="hljs-keyword">private</span> Money available;<br>    <span class="hljs-keyword">private</span> Money dailyLimit;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Money money)</span> &#123;<br>        <span class="hljs-comment">// 转出</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deposit</span><span class="hljs-params">(Money money)</span> &#123;<br>        <span class="hljs-comment">// 转入</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>AccountRepository 及 MyBatis 实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> &#123;<br>    Account <span class="hljs-title function_">find</span><span class="hljs-params">(AccountId id)</span>;<br>    Account <span class="hljs-title function_">find</span><span class="hljs-params">(AccountNumber accountNumber)</span>;<br>    Account <span class="hljs-title function_">find</span><span class="hljs-params">(UserId userId)</span>;<br>    Account <span class="hljs-title function_">save</span><span class="hljs-params">(Account account)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountRepositoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountRepository</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountMapper accountDAO;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountBuilder accountBuilder;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Account <span class="hljs-title function_">find</span><span class="hljs-params">(AccountId id)</span> &#123;<br>        <span class="hljs-type">AccountDO</span> <span class="hljs-variable">accountDO</span> <span class="hljs-operator">=</span> accountDAO.selectById(id.getValue());<br>        <span class="hljs-keyword">return</span> accountBuilder.toAccount(accountDO);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Account <span class="hljs-title function_">find</span><span class="hljs-params">(AccountNumber accountNumber)</span> &#123;<br>        <span class="hljs-type">AccountDO</span> <span class="hljs-variable">accountDO</span> <span class="hljs-operator">=</span> accountDAO.selectByAccountNumber(accountNumber.getValue());<br>        <span class="hljs-keyword">return</span> accountBuilder.toAccount(accountDO);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Account <span class="hljs-title function_">find</span><span class="hljs-params">(UserId userId)</span> &#123;<br>        <span class="hljs-type">AccountDO</span> <span class="hljs-variable">accountDO</span> <span class="hljs-operator">=</span> accountDAO.selectByUserId(userId.getId());<br>        <span class="hljs-keyword">return</span> accountBuilder.toAccount(accountDO);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Account <span class="hljs-title function_">save</span><span class="hljs-params">(Account account)</span> &#123;<br>        <span class="hljs-type">AccountDO</span> <span class="hljs-variable">accountDO</span> <span class="hljs-operator">=</span> accountBuilder.fromAccount(account);<br>        <span class="hljs-keyword">if</span> (accountDO.getId() == <span class="hljs-literal">null</span>) &#123;<br>            accountDAO.insert(accountDO);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            accountDAO.update(accountDO);<br>        &#125;<br>        <span class="hljs-keyword">return</span> accountBuilder.toAccount(accountDO);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Account 实体类和 AccountDO 数据类的对比如下：</strong></p><ol><li>Data Object数据类：AccountDO是单纯的和数据库表的映射关系，每个字段对应数据库表的一个column，这种对象叫Data Object。DO只有数据，没有行为。AccountDO的作用是对数据库做快速映射，避免直接在代码里写SQL。无论你用的是MyBatis还是Hibernate这种ORM，从数据库来的都应该先直接映射到DO上，但是代码里应该完全避免直接操作 DO。</li><li>Entity实体类：Account 是基于领域逻辑的实体类，它的字段和数据库储存不需要有必然的联系。Entity包含数据，同时也应该包含行为。在 Account 里，字段也不仅仅是String等基础类型，而应该尽可能用上一讲的 Domain Primitive 代替，可以避免大量的校验代码。</li></ol><p><strong>DAO 和 Repository 类的对比如下：</strong></p><ol><li>DAO对应的是一个特定的数据库类型的操作，相当于SQL的封装。所有操作的对象都是DO类，所有接口都可以根据数据库实现的不同而改变。比如，insert 和 update 属于数据库专属的操作。</li><li>Repository对应的是Entity对象读取储存的抽象，在接口层面做统一，不关注底层实现。比如，通过 save 保存一个Entity对象，但至于具体是 insert 还是 update 并不关心。Repository的具体实现类通过调用DAO来实现各种操作，通过Builder&#x2F;Factory对象实现AccountDO 到 Account之间的转化</li></ol><p><strong>Repository和Entity</strong></p><ol><li>通过Account对象，避免了其他业务逻辑代码和数据库的直接耦合，避免了当数据库字段变化时，大量业务逻辑也跟着变的问题。</li><li>通过Repository，改变业务代码的思维方式，让业务逻辑不再面向数据库编程，而是面向领域模型编程。<br>Account属于一个完整的内存中对象，可以比较容易的做完整的测试覆盖，包含其行为。<br>Repository作为一个接口类，可以比较容易的实现Mock或Stub，可以很容易测试。<br>AccountRepositoryImpl实现类，由于其职责被单一出来，只需要关注Account到AccountDO的映射关系和Repository方法到DAO方法之间的映射关系，相对于来说更容易测试。<img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927164431.png" alt=""></li></ol><h3 id="抽象第三方服务"><a href="#抽象第三方服务" class="headerlink" title="抽象第三方服务"></a>抽象第三方服务</h3><p>类似对于数据库的抽象，所有第三方服务也需要通过抽象解决第三方服务不可控，入参出参强耦合的问题。在这个例子里我们抽象出 ExchangeRateService 的服务，和一个 ExchangeRate 的 Domain Primitive 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExchangeRateService</span> &#123;<br>    ExchangeRate <span class="hljs-title function_">getExchangeRate</span><span class="hljs-params">(Currency source, Currency target)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangeRateServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExchangeRateService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> YahooForexService yahooForexService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ExchangeRate <span class="hljs-title function_">getExchangeRate</span><span class="hljs-params">(Currency source, Currency target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (source.equals(target)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExchangeRate</span>(BigDecimal.ONE, source, target);<br>        &#125;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">forex</span> <span class="hljs-operator">=</span> yahooForexService.getExchangeRate(source.getValue(), target.getValue());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExchangeRate</span>(forex, source, target);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>防腐层（ACL）</strong><br>这种常见的设计模式叫做Anti-Corruption Layer（防腐层或ACL）。很多时候我们的系统会去依赖其他的系统，而被依赖的系统可能包含不合理的数据结构、API、协议或技术实现，如果对外部系统强依赖，会导致我们的系统被”腐蚀“。这个时候，通过在系统间加入一个防腐层，能够有效的隔离外部依赖和内部逻辑，无论外部如何变更，内部代码可以尽可能的保持不变。<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927164516.png" alt=""></p><p>ACL 不仅仅只是多了一层调用，在实际开发中 ACL 能够提供更多强大的功能：</p><ol><li>适配器：很多时候外部依赖的数据、接口和协议并不符合内部规范，通过适配器模式，可以将数据转化逻辑封装到ACL内部，降低对业务代码的侵入。在这个案例里，我们通过封装了ExchangeRate和Currency对象，转化了对方的入参和出参，让入参出参更符合我们的标准。</li><li>缓存：对于频繁调用且数据变更不频繁的外部依赖，通过在ACL里嵌入缓存逻辑，能够有效的降低对于外部依赖的请求压力。同时，很多时候缓存逻辑是写在业务代码里的，通过将缓存逻辑嵌入ACL，能够降低业务代码的复杂度。</li><li>兜底：如果外部依赖的稳定性较差，一个能够有效提升我们系统稳定性的策略是通过ACL起到兜底的作用，比如当外部依赖出问题后，返回最近一次成功的缓存或业务兜底数据。这种兜底逻辑一般都比较复杂，如果散落在核心业务代码中会很难维护，通过集中在ACL中，更加容易被测试和修改。</li><li>易于测试：类似于之前的Repository，ACL的接口类能够很容易的实现Mock或Stub，以便于单元测试。</li><li>功能开关：有些时候我们希望能在某些场景下开放或关闭某个接口的功能，或者让某个接口返回一个特定的值，我们可以在ACL配置功能开关来实现，而不会对真实业务代码造成影响。同时，使用功能开关也能让我们容易的实现Monkey测试，而不需要真正物理性的关闭外部依赖。<img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165835.png" alt=""></li></ol><h3 id="抽象中间件"><a href="#抽象中间件" class="headerlink" title="抽象中间件"></a>抽象中间件</h3><p>类似于2.2的第三方服务的抽象，对各种中间件的抽象的目的是让业务代码不再依赖中间件的实现逻辑。因为中间件通常需要有通用型，中间件的接口通常是String或Byte[] 类型的，导致序列化&#x2F;反序列化逻辑通常和业务逻辑混杂在一起，造成胶水代码。通过中间件的ACL抽象，减少重复胶水代码。</p><p>在这个案例里，我们通过封装一个抽象的AuditMessageProducer和AuditMessage DP对象，实现对底层 kafka 实现的隔离：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuditMessage</span> &#123;<br><br>    <span class="hljs-keyword">private</span> UserId userId;<br>    <span class="hljs-keyword">private</span> AccountNumber source;<br>    <span class="hljs-keyword">private</span> AccountNumber target;<br>    <span class="hljs-keyword">private</span> Money money;<br>    <span class="hljs-keyword">private</span> Date date;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userId + <span class="hljs-string">&quot;,&quot;</span> + source + <span class="hljs-string">&quot;,&quot;</span> + target + <span class="hljs-string">&quot;,&quot;</span> + money + <span class="hljs-string">&quot;,&quot;</span> + date;   <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AuditMessage <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-comment">// todo</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AuditMessageProducer</span> &#123;<br>    SendResult <span class="hljs-title function_">send</span><span class="hljs-params">(AuditMessage message)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuditMessageProducerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AuditMessageProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TOPIC_AUDIT_LOG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TOPIC_AUDIT_LOG&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SendResult <span class="hljs-title function_">send</span><span class="hljs-params">(AuditMessage message)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">messageBody</span> <span class="hljs-operator">=</span> message.serialize();<br>        kafkaTemplate.send(TOPIC_AUDIT_LOG, messageBody);<br>        <span class="hljs-keyword">return</span> SendResult.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的分析和2.2类似，在此略过。<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927164610.png" alt=""></p><h3 id="封装业务逻辑"><a href="#封装业务逻辑" class="headerlink" title="封装业务逻辑"></a>封装业务逻辑</h3><p>在这个案例里，有很多业务逻辑是跟外部依赖的代码混合的，包括金额计算、账户余额的校验、转账限制、金额增减等。这种逻辑混淆导致了核心计算逻辑无法被有效的测试和复用。在这里，我们的解法是通过 Entity、Domain Primitive 和 Domain Service 封装所有的业务逻辑：</p><p><strong>用Domain Primitive封装跟实体无关的无状态计算逻辑</strong><br>在这个案例里使用 ExchangeRate 来封装汇率计算逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">exchangeRate</span> <span class="hljs-operator">=</span> BigDecimal.ONE; <br><span class="hljs-keyword">if</span> (sourceAccountDO.getCurrency().equals(targetCurrency)) &#123; <br>exchangeRate = yahooForex.getExchangeRate(sourceAccountDO.getCurrency(),targetCurrency); <br>&#125; <br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">sourceAmount</span> <span class="hljs-operator">=</span> targetAmount.divide(exchangeRate, RoundingMode.DOWN); <br><span class="hljs-comment">// 变为： </span><br><span class="hljs-type">ExchangeRate</span> <span class="hljs-variable">exchangeRate</span> <span class="hljs-operator">=</span>exchangeRateService.getExchangeRate(sourceAccount.getCurrency(), targetMoney.getCurrency()); <br><span class="hljs-type">Money</span> <span class="hljs-variable">sourceMoney</span> <span class="hljs-operator">=</span> exchangeRate.exchangeTo(targetMoney);<br></code></pre></td></tr></table></figure><p><strong>用Entity封装单对象的有状态的行为，包括业务校验</strong><br>用Account实体类封装所有Account的行为，包括业务校验如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-keyword">private</span> AccountId id;<br>    <span class="hljs-keyword">private</span> AccountNumber accountNumber;<br>    <span class="hljs-keyword">private</span> UserId userId;<br>    <span class="hljs-keyword">private</span> Money available;<br>    <span class="hljs-keyword">private</span> Money dailyLimit;<br><br>    <span class="hljs-keyword">public</span> Currency <span class="hljs-title function_">getCurrency</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.available.getCurrency();<br>    &#125;<br><br>    <span class="hljs-comment">// 转入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deposit</span><span class="hljs-params">(Money money)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.getCurrency().equals(money.getCurrency())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCurrencyException</span>();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.available = <span class="hljs-built_in">this</span>.available.add(money);<br>    &#125;<br><br>    <span class="hljs-comment">// 转出</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Money money)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.available.compareTo(money) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsufficientFundsException</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dailyLimit.compareTo(money) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DailyLimitExceededException</span>();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.available = <span class="hljs-built_in">this</span>.available.subtract(money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原有的业务代码则可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">sourceAccount.deposit(sourceMoney);<br>targetAccount.withdraw(targetMoney);<br></code></pre></td></tr></table></figure><p><strong>用Domain Service封装多对象逻辑</strong><br>在这个案例里，我们发现这两个账号的转出和转入实际上是一体的，也就是说这种行为应该被封装到一个对象中去。特别是考虑到未来这个逻辑可能会产生变化：比如增加一个扣手续费的逻辑。这个时候在原有的TransferService中做并不合适，在任何一个Entity或者Domain Primitive里也不合适，需要有一个新的类去包含跨域对象的行为。这种对象叫做 Domain Service。<br>我们创建一个 AccountTransferService 的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountTransferService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account sourceAccount, Account targetAccount, Money targetMoney, ExchangeRate exchangeRate)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountTransferServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AccountTransferService</span> &#123;<br>    <span class="hljs-keyword">private</span> ExchangeRateService exchangeRateService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account sourceAccount, Account targetAccount, Money targetMoney, ExchangeRate exchangeRate)</span> &#123;<br>        <span class="hljs-type">Money</span> <span class="hljs-variable">sourceMoney</span> <span class="hljs-operator">=</span> exchangeRate.exchangeTo(targetMoney);<br>        sourceAccount.deposit(sourceMoney);<br>        targetAccount.withdraw(targetMoney);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而原始代码则简化为一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">accountTransferService.transfer(sourceAccount, targetAccount, targetMoney, exchangeRate);<br></code></pre></td></tr></table></figure><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165131.png" alt="">### 重构后结果分析这个案例重构后的代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferServiceImplNew</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> AccountRepository accountRepository;<br>    <span class="hljs-keyword">private</span> AuditMessageProducer auditMessageProducer;<br>    <span class="hljs-keyword">private</span> ExchangeRateService exchangeRateService;<br>    <span class="hljs-keyword">private</span> AccountTransferService accountTransferService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title function_">transfer</span><span class="hljs-params">(Long sourceUserId, String targetAccountNumber, BigDecimal targetAmount, String targetCurrency)</span> &#123;<br>        <span class="hljs-comment">// 参数校验</span><br>        <span class="hljs-type">Money</span> <span class="hljs-variable">targetMoney</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Money</span>(targetAmount, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Currency</span>(targetCurrency));<br><br>        <span class="hljs-comment">// 读数据</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">sourceAccount</span> <span class="hljs-operator">=</span> accountRepository.find(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserId</span>(sourceUserId));<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">targetAccount</span> <span class="hljs-operator">=</span> accountRepository.find(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountNumber</span>(targetAccountNumber));<br>        <span class="hljs-type">ExchangeRate</span> <span class="hljs-variable">exchangeRate</span> <span class="hljs-operator">=</span> exchangeRateService.getExchangeRate(sourceAccount.getCurrency(), targetMoney.getCurrency());<br><br>        <span class="hljs-comment">// 业务逻辑</span><br>        accountTransferService.transfer(sourceAccount, targetAccount, targetMoney, exchangeRate);<br><br>        <span class="hljs-comment">// 保存数据</span><br>        accountRepository.save(sourceAccount);<br>        accountRepository.save(targetAccount);<br><br>        <span class="hljs-comment">// 发送审计消息</span><br>        <span class="hljs-type">AuditMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuditMessage</span>(sourceAccount, targetAccount, targetMoney);<br>        auditMessageProducer.send(message);<br><br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>可以看出来，经过重构后的代码有以下几个特征：1. 业务逻辑清晰，数据存储和业务逻辑完全分隔。2. Entity、Domain Primitive、Domain Service都是独立的对象，没有任何外部依赖，但是却包含了所有核心业务逻辑，可以单独完整测试。3. 原有的TransferService不再包括任何计算逻辑，仅仅作为组件编排，所有逻辑均delegate到其他组件。这种仅包含Orchestration（编排）的服务叫做Application Service（应用服务）。<p>我们可以根据新的结构重新画一张图：<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165148.png" alt=""><br>然后通过重新编排后该图变为：<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165207.png" alt=""><br>我们可以发现，通过对外部依赖的抽象和内部逻辑的封装重构，应用整体的依赖关系变了：</p><ol><li>最底层不再是数据库，而是Entity、Domain Primitive和Domain Service。这些对象不依赖任何外部服务和框架，而是纯内存中的数据和操作。这些对象我们打包为Domain Layer（领域层）。领域层没有任何外部依赖关系。</li><li>再其次的是负责组件编排的Application Service，但是这些服务仅仅依赖了一些抽象出来的ACL类和Repository类，而其具体实现类是通过依赖注入注进来的。Application Service、Repository、ACL等我们统称为Application Layer（应用层）。应用层 依赖 领域层，但不依赖具体实现。</li><li>最后是ACL，Repository等的具体实现，这些实现通常依赖外部具体的技术实现和框架，所以统称为Infrastructure Layer（基础设施层）。Web框架里的对象如Controller之类的通常也属于基础设施层。</li></ol><p>如果今天能够重新写这段代码，考虑到最终的依赖关系，我们可能先写Domain层的业务逻辑，然后再写Application层的组件编排，最后才写每个外部依赖的具体实现。这种架构思路和代码组织结构就叫做Domain-Driven Design（领域驱动设计，或DDD）。所以DDD不是一个特殊的架构设计，而是所有Transction Script代码经过合理重构后一定会抵达的终点。</p><h2 id="DDD的六边形架构"><a href="#DDD的六边形架构" class="headerlink" title="DDD的六边形架构"></a>DDD的六边形架构</h2><p>在我们传统的代码里，我们一般都很注重每个外部依赖的实现细节和规范，但是今天我们需要敢于抛弃掉原有的理念，重新审视代码结构。在上面重构的代码里，如果抛弃掉所有Repository、ACL、Producer等的具体实现细节，我们会发现每一个对外部的抽象类其实就是输入或输出，类似于计算机系统中的I&#x2F;O节点。这个观点在CQRS架构中也同样适用，将所有接口分为Command（输入）和Query（输出）两种。除了I&#x2F;O之外其他的内部逻辑，就是应用业务的核心逻辑。基于这个基础，Alistair Cockburn在2005年提出了Hexagonal Architecture（六边形架构），又被称之为Ports and Adapters（端口和适配器架构）。<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165902.png" alt=""></p><p>在这张图中：</p><ol><li>I&#x2F;O的具体实现在模型的最外层</li><li>每个I&#x2F;O的适配器在灰色地带</li><li>每个Hex的边是一个端口</li><li>Hex的中央是应用的核心领域模型</li></ol><p>在Hex中，架构的组织关系第一次变成了一个二维的内外关系，而不是传统一维的上下关系。同时在Hex架构中我们第一次发现UI层、DB层、和各种中间件层实际上是没有本质上区别的，都只是数据的输入和输出，而不是在传统架构中的最上层和最下层。</p><p>除了2005年的Hex架构，2008年 Jeffery Palermo的Onion Architecture（洋葱架构）和2017年 Robert Martin的Clean Architecture（干净架构），都是极为类似的思想。除了命名不一样、切入点不一样之外，其他的整体架构都是基于一个二维的内外关系。这也说明了基于DDD的架构最终的形态都是类似的。Herberto Graca有一个很全面的图包含了绝大部分现实中的端口类，值得借鉴。<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165344.png" alt=""></p><h3 id="代码组织结构"><a href="#代码组织结构" class="headerlink" title="代码组织结构"></a>代码组织结构</h3><p>为了有效的组织代码结构，避免下层代码依赖到上层实现的情况，在Java中我们可以通过POM Module和POM依赖来处理相互的关系。通过Spring&#x2F;SpringBoot的容器来解决运行时动态注入具体实现的依赖的问题。一个简单的依赖关系图如下：<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165921.png" alt=""><br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165429.png" alt=""></p><h4 id="Types-模块"><a href="#Types-模块" class="headerlink" title="Types 模块"></a>Types 模块</h4><p>Types模块是保存可以对外暴露的Domain Primitives的地方。Domain Primitives因为是无状态的逻辑，可以对外暴露，所以经常被包含在对外的API接口中，需要单独成为模块。Types模块不依赖任何类库，纯 POJO 。<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165953.png" alt=""></p><h4 id="Domain-模块"><a href="#Domain-模块" class="headerlink" title="Domain 模块"></a>Domain 模块</h4><p>Domain 模块是核心业务逻辑的集中地，包含有状态的Entity、领域服务Domain Service、以及各种外部依赖的接口类（如Repository、ACL、中间件等。Domain模块仅依赖Types模块，也是纯 POJO 。<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165540.png" alt=""></p><h4 id="Application模块"><a href="#Application模块" class="headerlink" title="Application模块"></a>Application模块</h4><p>Application模块主要包含Application Service和一些相关的类。Application模块依赖Domain模块。还是不依赖任何框架，纯POJO。<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165730.png" alt=""></p><h4 id="Infrastructure模块"><a href="#Infrastructure模块" class="headerlink" title="Infrastructure模块"></a>Infrastructure模块</h4><p>Infrastructure模块包含了Persistence、Messaging、External等模块。比如：Persistence模块包含数据库DAO的实现，包含Data Object、ORM Mapper、Entity到DO的转化类等。Persistence模块要依赖具体的ORM类库，比如MyBatis。如果需要用Spring-Mybatis提供的注解方案，则需要依赖Spring。<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927165744.png" alt=""></p><h4 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h4><p>Web模块包含Controller等相关代码。如果用SpringMVC则需要依赖Spring。<br><img src="/posts/983808872/images/DDD%E8%AF%A6%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E8%AE%B2-20220927170052.png" alt=""></p><h4 id="Start模块"><a href="#Start模块" class="headerlink" title="Start模块"></a>Start模块</h4><p>Start模块是SpringBoot的启动类。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>Types，Domain模块都属于无外部依赖的纯POJO，基本上都可以100%的被单元测试覆盖。</li><li>Application模块的代码依赖外部抽象类，需要通过测试框架去Mock所有外部依赖，但仍然可以100%被单元测试。</li><li>Infrastructure的每个模块的代码相对独立，接口数量比较少，相对比较容易写单测。但是由于依赖了外部I&#x2F;O，速度上不可能很快，但好在模块的变动不会很频繁，属于一劳永逸。</li><li>Web模块有两种测试方法：通过Spring的MockMVC测试，或者通过HttpClient调用接口测试。但是在测试时最好把Controller依赖的服务类都Mock掉。一般来说当你把Controller的逻辑都后置到Application Service中时，Controller的逻辑变得极为简单，很容易100%覆盖。</li><li>Start模块：通常应用的集成测试写在start里。当其他模块的单元测试都能100%覆盖后，集成测试用来验证整体链路的真实性。</li></ol><h3 id="代码的演进-x2F-变化速度"><a href="#代码的演进-x2F-变化速度" class="headerlink" title="代码的演进&#x2F;变化速度"></a>代码的演进&#x2F;变化速度</h3><p>在传统架构中，代码从上到下的变化速度基本上是一致的，改个需求需要从接口、到业务逻辑、到数据库全量变更，而第三方变更可能会导致整个代码的重写。但是在DDD中不同模块的代码的演进速度是不一样的：</p><ol><li>Domain层属于核心业务逻辑，属于经常被修改的地方。比如：原来不需要扣手续费，现在需要了之类的。通过Entity能够解决基于单个对象的逻辑变更，通过Domain Service解决多个对象间的业务逻辑变更。</li><li>Application层属于Use Case（业务用例）。业务用例一般都是描述比较大方向的需求，接口相对稳定，特别是对外的接口一般不会频繁变更。添加业务用例可以通过新增Application Service或者新增接口实现功能的扩展。</li><li>Infrastructure层属于最低频变更的。一般这个层的模块只有在外部依赖变更了之后才会跟着升级，而外部依赖的变更频率一般远低于业务逻辑的变更频率。<br>所以在DDD架构中，能明显看出越外层的代码越稳定，越内层的代码演进越快，真正体现了领域“驱动”的核心思想。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DDD不是一个什么特殊的架构，而是任何传统代码经过合理的重构之后最终一定会抵达的终点。DDD的架构能够有效的解决传统架构中的问题：</p><ol><li>高可维护性：当外部依赖变更时，内部代码只用变更跟外部对接的模块，其他业务逻辑不变。</li><li>高可扩展性：做新功能时，绝大部分的代码都能复用，仅需要增加核心业务逻辑即可。</li><li>高可测试性：每个拆分出来的模块都符合单一性原则，绝大部分不依赖框架，可以快速的单元测试，做到100%覆盖。</li><li>代码结构清晰：通过POM module可以解决模块间的依赖关系，所有外接模块都可以单独独立成Jar包被复用。当团队形成规范后，可以快速的定位到相关代码。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>DDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>转载</tag>
      
      <tag>DDD详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>政治学通识</title>
    <link href="/posts/24275777/"/>
    <url>/posts/24275777/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 政治学通识</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/777/24275777/t7_24275777.jpg" alt=" 政治学通识|200"></li><li>书名： 政治学通识</li><li>作者： 包刚升</li><li>简介： 《政治的常识》是作者在复旦大学政治学课程讲义的基础上修改润色而成的。本书力求成为一部通俗易懂、深入浅出的政治学普及入门读物。这部书正是为那些对政治和公共事务感兴趣的读者朋友们而写的。通过本书，作者希望能够帮助读者加深对中国政治与世界政治的认知，帮助读者理解政治学领域的重大议题、主要理论与基本方法，帮助读者养成健全与系统的政治思考能力。</li><li>出版时间 2019-04-01 00:00:00</li><li>ISBN： 9787301263525</li><li>分类： 政治军事-政治</li><li>出版社： 北京大学出版社</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h2 id="为什么政治很重要？（代序）"><a href="#为什么政治很重要？（代序）" class="headerlink" title="为什么政治很重要？（代序）"></a>为什么政治很重要？（代序）</h2><h3 id="划线评论"><a href="#划线评论" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 技术解决方案能否成为一种公共政策，是政策背后的政治决定的。比如，有些措施从技术层面来看是可行的，但是从政治层面来看却难以实施。这样，此种技术解决方案就会被否决掉。因此，治理雾霾貌似是一个技术问题，其实也是一个政治问题。  ^7570425-7Cz8gfaIR<ul><li>💭 这里的政治层面具体是指的是什么？ 如果只是政治层面四个字的话就显得太宽泛了，很多事情都可以用这四个字来形容</li><li>⏱ 2022-09-26 21:07:51</li></ul></li></ul><h3 id="划线评论-1"><a href="#划线评论-1" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 政治  ^7570425-7Cz7Ghlfi<ul><li>💭 什么是政治？<br>政治有边界么？如果有那边界在哪里？</li><li>⏱ 2022-09-26 20:59:00</li></ul></li></ul><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>政治军事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>架构、设计、风格、模式解释</title>
    <link href="/posts/226486905/"/>
    <url>/posts/226486905/</url>
    
    <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul><li>架构：架构专注于可以被多个设计所利用的抽象</li><li>设计：设计是建立特定事务的具体计划。架构也是一种设计，专注于架构设计。</li><li>风格：某一特定应用领域中系统组织方式的惯用模式。</li><li>模式：指事物的标准样式，是结构主义用语。指用来说明事物结构的主观理性形式</li></ul><h2 id="概念剖析"><a href="#概念剖析" class="headerlink" title="概念剖析"></a>概念剖析</h2><ul><li>风格是模式的一种抽象</li><li>架构是设计的一种抽象<blockquote><p>架构风格师一种顶级抽象。其次是架构模式，设计模式时最底层实现落地层面的。</p></blockquote></li><li>架构风格是最高抽象级别的应用设计</li><li>架构模式是实现架构风格的一种方式</li><li>设计风格是设计中的某些风格，架构风格就是专注于架构设计的风格</li><li>架构设计是专注于架构的设计</li><li>设计模式是解决局部问题的方法<img src="/posts/226486905/images/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%E6%A8%A1%E5%BC%8F%E8%A7%A3%E9%87%8A.png" alt=""></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>设计</tag>
      
      <tag>风格</tag>
      
      <tag>模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/posts/3135569691/"/>
    <url>/posts/3135569691/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>string<br>最基本的类型。是 key 对应的一个单一值。二进制安全，不比担心由于编码等问题导致二进制数据变化。可以包含任何数据，一个字符串值的最大容量为 512 M</li><li>list<br>字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部或尾部。底层基于列表实现，所以操作头尾效率高，中间效率低</li><li>set<br>是 string 类型的无序集合，基于哈希表实现</li><li>zset<br>和 set 一样也是 string 类型元素的集合，切不允许重复的成员。不同的是每个元素会关联一个 double 类型的分数。redis 通过分数来为集合中的成员进行从小到大的排序。zset 的成员是唯一的，但是分数却可以重复</li><li>hash<br>本身是一个键值对的几个。可以当作 java 中 Map&lt;String, Object&gt; 对待</li></ol><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p>每个一段时间把内存中的数据作为一个快照保存到硬盘上的文件中。Redis默认开启RDB</p><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><ol><li>基于默认配置<br>例：<br><code>save 900 1</code>：900秒内至少有一次修改则出发保存操作<br><code>save 300 10</code>：300 秒内至少有10次修改则出发保存操作<br><code>save 60 10000</code>：60秒内至少有1000次修改则出发保存操作</li><li>使用保存命令<br><code>save</code>或<code>bgsave</code></li><li>使用 flushall 命令<br>这个也会产生 dump. rdb 文件，但是里面是空的，没有意义</li><li>服务器关闭<br>如果执行 <code>shutdown</code> 命令让 Redis 正常退出，那么此前Redis就会执行一次持久化保存</li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h4><p>根据配置文件中制定的策略，把生成数据的命令保存到硬盘上的文件中。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件架构编年史</title>
    <link href="/posts/263832673/"/>
    <url>/posts/263832673/</url>
    
    <content type="html"><![CDATA[<h1 id="软件架构编年史"><a href="#软件架构编年史" class="headerlink" title="软件架构编年史"></a>软件架构编年史</h1><h2 id="软件架构编年史系列"><a href="#软件架构编年史系列" class="headerlink" title="软件架构编年史系列"></a>软件架构编年史系列</h2><ul><li><a href="https://www.jianshu.com/p/b477b2cc6cfa">软件架构编年史(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/">原文</a></li><li><a href="https://www.jianshu.com/p/df295f92fb52">软件架构预述(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/07/05/software-architecture-premises/">原文</a></li><li><a href="https://www.jianshu.com/p/2c4b7f86e5d4">编程语言的演化(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/07/10/programming-language-evolution/">原文</a></li><li><a href="https://www.jianshu.com/p/d8dce27f279f">架构风格 vs. 架构模式 vs. 设计模式(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/07/28/architectural-styles-vs-architectural-patterns-vs-design-patterns/">原文</a></li><li><a href="https://www.jianshu.com/p/28c3439c11d3">单体架构(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/07/31/monolithic-architecture/">原文</a></li><li><a href="https://www.jianshu.com/p/e9fdc85d573c">分层架构(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/08/03/layered-architecture/">原文</a></li><li><a href="https://www.jianshu.com/p/21079ff15a1c">MVC 及其变种(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/08/17/mvc-and-its-variants/">原文</a><ul><li><a href="https://www.jianshu.com/p/21079ff15a1c">1979 – Model-View-Controller(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/08/17/mvc-and-its-variants/%23model-view-controller">原文</a></li><li><a href="https://www.jianshu.com/p/21079ff15a1c">1987&#x2F;2000 – PAC &#x2F; Hierarchical Model-View-Controller(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/08/17/mvc-and-its-variants/%23hierarchical-model-view-controller">原文</a></li><li><a href="https://www.jianshu.com/p/21079ff15a1c">1996 – Model-View-Presenter(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/08/17/mvc-and-its-variants/%23model-view-presenter">原文</a></li><li><a href="https://www.jianshu.com/p/bd2967d9391f">1998 –”Model 1″ &amp; “Model 2” (译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2018/08/29/model-1-model-2">原文</a></li><li><a href="https://www.jianshu.com/p/21079ff15a1c">2005 – Model-View-ViewModel(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/08/17/mvc-and-its-variants/%23model-view-view_model">原文</a></li><li><a href="https://www.jianshu.com/p/21079ff15a1c">???? – Model-View-Presenter-ViewModel(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/08/17/mvc-and-its-variants/%23model-view-presenter-view_model">原文</a></li><li><a href="https://www.jianshu.com/p/87405a5afb60">2008 – Resource-Method-Representation(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2018/08/31/resource-method-representation">原文</a></li><li><a href="https://www.jianshu.com/p/2eaa134a9fb8">2014 – Action-Domain-Responder(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2018/09/03/action-domain-responder">原文</a></li></ul></li><li><a href="https://www.jianshu.com/p/395814410cf5">EBI 架构(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/08/24/ebi-architecture/">原文</a></li><li><a href="https://www.jianshu.com/p/ebaa2e11d25e">包与命名空间(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/08/31/packaging-code/">原文</a></li><li><a href="https://www.jianshu.com/p/812636d55677">领域驱动设计(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/09/07/domain-driven-design/">原文</a></li><li><a href="https://www.jianshu.com/p/f39f4537857e">端口和适配器架构(六边形架构)(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/09/14/ports-adapters-architecture/">原文</a></li><li><a href="https://www.jianshu.com/p/d87d5389c92a">洋葱架构(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/09/21/onion-architecture/">原文</a></li><li><a href="https://www.jianshu.com/p/b565f0c00c0c">整洁架构(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/09/28/clean-architecture-standing-on-the-shoulders-of-giants/">原文</a></li><li><a href="https://www.jianshu.com/p/12dc9a4b3e35">事件驱动的架构(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/10/05/event-driven-architecture/">原文</a></li><li><a href="https://www.jianshu.com/p/ab3843093903">从 CQS 到 CQRS(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/10/19/from-cqs-to-cqrs/">原文</a></li><li><a href="https://www.jianshu.com/p/0c1354b3341f">面向服务的架构(SOA)(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/11/09/service-oriented-architecture-soa/">原文</a></li><li><a href="https://www.jianshu.com/p/d3e8b9ac097b">清晰架构(01)：融合 DDD、洋葱架构、整洁架构、CQRS…(译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/">原文</a></li><li><a href="https://www.jianshu.com/p/fcf5bb27a60b">清晰架构(02)：超越同心圆分层 (译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2018/07/07/more-than-concentric-layers/">原文</a></li><li><a href="https://www.jianshu.com/p/dd992f3fe370">清晰架构(03)：在代码中展现架构和领域 (译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2019/06/05/reflecting-architecture-and-domain-in-code/">原文</a></li><li><a href="https://www.jianshu.com/p/5f1d9500b8df">清晰架构(04)：用文档描述架构 (译)</a> &#x2F;&#x2F;<a href="https://links.jianshu.com/go?to=https://herbertograca.com/2019/08/12/documenting-software-architecture/">原文</a></li><li>一个项目的演进：从 MVP 到 P</li><li>4 + 1 架构视图模型</li><li>架构的质量属性</li></ul><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><ul><li>20 世纪 50 年代<ul><li><strong>非结构化编程</strong></li><li>~1951 – <strong>汇编</strong></li></ul></li><li>20 世纪 60 年代<ul><li><strong>结构化编程</strong></li><li><strong>分层</strong>: 用户界面、业务逻辑数据存储都在<strong>一层</strong>。</li><li>~1958 – Algol</li></ul></li><li>20 世纪 70 年代<ul><li><strong>过程式&#x2F;函数式编程</strong></li><li>~1970 – Pascal</li><li>~1972 – C</li><li><a href="https://links.jianshu.com/go?to=http://heim.ifi.uio.no/~trygver/1979/mvc-2/1979-12-MVC.pdf">1979</a> – <strong><a href="/posts/2218208641/">MVC</a> 模式(Model-View-Controller)</strong></li></ul></li><li>20 世纪 80 年代<ul><li><strong>面向对象编程</strong> (但其思想在 <a href="https://links.jianshu.com/go?to=http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">20 世纪 60 年代</a>晚期已经第一次提出)</li><li><strong>分层</strong>: <strong>两层</strong>，第一层是用户界面，第二层是业务逻辑和数据存储</li><li>~1980 – C++</li><li><strong>CORBA</strong> – 通用物件请求代理架构(尽管<a href="https://links.jianshu.com/go?to=https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture%23Versions_history">1991年</a>才推出第一个稳定版，但最早使用可以追溯到 <a href="https://links.jianshu.com/go?to=https://en.wikipedia.org/wiki/TIBCO_Software">20 世纪 80 年代</a>)</li><li>~1986 – Erlang</li><li>~1987 – Perl</li><li><a href="https://links.jianshu.com/go?to=https://www.lri.fr/~mbl/ENS/FONDIHM/2013/papers/Coutaz-Interact87.pdf">1987</a> – PAC 即 <strong>HMVC 模式(Hierarchical Model-View-Controller)</strong></li><li><a href="https://links.jianshu.com/go?to=https://drive.google.com/file/d/0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh/view">1988</a> – <strong>LSP(里氏替换原则)</strong> (~SO<strong>L</strong>ID)</li></ul></li><li>20 世纪 90 年代<ul><li><strong>分层</strong>: <strong>三层</strong>，第一层是用户界面，第二层是业务逻辑(以及浏览器作为客户端时的用户界面展现逻辑)，第三层是数据存储</li><li>~1991 – <strong>消息总线</strong></li><li>~1991 – Python</li><li><a href="https://links.jianshu.com/go?to=https://www.amazon.com/Object-Oriented-Software-Engineering-Driven-Approach/dp/0201403471">1992</a> – <strong>EBI 架构</strong>(Entity-Boundary-Interactor) 即 EBC 或 EIC</li><li>~1993 – Ruby　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</li><li>~1995 – Delphi, Java, Javascript, PHP</li><li><a href="https://links.jianshu.com/go?to=http://www.wildcrest.com/Potel/Portfolio/mvp.pdf">1996</a> – <strong>MVP 模式(Model-View-Presenter)</strong></li><li><a href="https://links.jianshu.com/go?to=http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">1996</a> – <strong>OCP</strong>, <strong>ISP</strong>, <strong>DIP</strong> (~S<strong>O</strong>L<strong>ID</strong>), REP, CRP, CCP, ADP</li><li><a href="https://links.jianshu.com/go?to=http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">1997</a> – SDP, SAP</li><li>~<a href="https://links.jianshu.com/go?to=http://www.cs.ubc.ca/~gregor/papers/kiczales-ECOOP1997-AOP.pdf">1997</a> – <strong>面向方面编程</strong></li><li>~1997 – Web 服务</li><li>~<a href="https://links.jianshu.com/go?to=http://shop.oreilly.com/product/9780596006754.do">1997</a> – <strong>ESB</strong> – 企业服务总线 (尽管创造该术语的书籍2004年才出版，但这个概念早已被使用)</li></ul></li><li>21 世纪 00 年代<ul><li><a href="http://a.co/7S3sJ2J">2002</a> – <strong>SRP</strong> (~<strong>S</strong>OLID)</li><li><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">2003</a> – <strong><a href="/posts/1836512142/">领域驱动设计</a></strong></li><li><a href="https://learn.microsoft.com/zh-cn/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps">2005</a> – <strong>MVVM 模式(Model-View-ViewModel)</strong></li><li><a href="http://alistair.cockburn.us/Hexagonal+architecture">2005</a> – <strong>端口和适配器架构</strong>即六边形架构</li><li><a href="https://youtu.be/JHGkaShoyNs?t=1m17s">2006</a>? – <strong>CQRS 与 ES</strong> (命令查询职责分离与事件溯源)</li><li><a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">2008</a> – <strong>洋葱架构</strong></li><li><a href="https://medium.com/s-c-a-l-e/talking-microservices-with-the-man-who-made-netflix-s-cloud-famous-1032689afed3">2009</a> – <strong>微服务</strong>(Netflix)</li></ul></li><li>21 世纪 10 年代<ul><li><a href="https://www.amazon.co.uk/Lean-Architecture-Agile-Software-Development/dp/0470684208">2010</a> – <strong>DCI 架构</strong>(Data-Context-Interaction)</li><li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">2012</a> – <strong>整洁架构</strong></li><li><a href="https://links.jianshu.com/go?to=http://www.codingthearchitecture.com/2014/08/24/c4_model_poster.html">2014</a> – C4 模型</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVC</title>
    <link href="/posts/2218208641/"/>
    <url>/posts/2218208641/</url>
    
    <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="MVC介绍"><a href="#MVC介绍" class="headerlink" title="MVC介绍"></a>MVC介绍</h2><img src="/posts/2218208641/images/MVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="MVC三层架构">]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>MVC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DDD</title>
    <link href="/posts/1836512142/"/>
    <url>/posts/1836512142/</url>
    
    <content type="html"><![CDATA[<h1 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h1><h2 id="DDD-介绍"><a href="#DDD-介绍" class="headerlink" title="DDD 介绍"></a>DDD 介绍</h2><h3 id="DDD整体架构"><a href="#DDD整体架构" class="headerlink" title="DDD整体架构"></a>DDD整体架构</h3><img src="/posts/1836512142/images/DDD%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt="">### DDD 分层架构<img src="/posts/1836512142/images/DDD%E6%9E%B6%E6%9E%84.png" alt="DDD分层架构">和 <a href="/posts/2218208641/">MVC</a> 三层架构的区别：1. controller 层更加纯粹，controller 可能会聚合多个 service 层调用。新的分层架构中，则纯粹作为与前端或外部系统交互的数据转换层，不再包含业务逻辑2. service 层改为 Application Services，主要体现在对 service 进行分级，打薄，Application Service 作为更高级别的抽象，新增领域层，抽离原 service 层的部分逻辑到领域服务和领域对象中。3. 领域层分为聚合和领域服务，其中聚合包括实体+值对象，实体和值对象不像 spring 提倡的贫血模型，仅包含 get、set 方法的简单对象，是包含了业务逻辑的丰富对象，即 DDD 所提倡的充血模型对象。<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>领域：切分的服务，就是范围。重点是边界， 核心思想就是将问题逐级细分来减低业务和系统的复杂度</li><li>子域：子服务。领域可以进一步划分成子领域。这里是处理高度复杂领域的设计思想，试图分离技术实现的复杂性。子域按重要程度被划分为三类： 核心域、通用域、支撑域</li><li>核心域：核心服务。</li><li>通用域：中间件服务或第三方服务。本身可以通过现有的解决方案即成来完成的服务。</li><li>支撑域：企业公共服务。没它不行，但又打不到核心的价值，围绕着产品内部所需要，但又不能单独变更为第三方服务，即它不是一个通用的服务。</li><li>统一语言（统一概念）：定义上下文的含义。价值是可以解决交流障碍，让每个团队使用统一语言（概念）来交流，甚至可读性更好的代码</li><li>限界上下文（服务职责划分的边界）：定义上下文的边界。领域模型存在边界之内。对于同一概念，不同上下文会有不同的理解。理论上，限界的边界就是微服务的边界。</li><li>聚合（包）：每个包里包含一类实体或者行为，有助于分散系统的复杂性，也是一种高层次的抽象，可以简化对领域模型的理解。<blockquote><p>拆分的实体不能都放在一个服务里，这就涉及到了拆分，有拆分就会有聚合。聚合是为了保证领域内对象之间的一致性问题。<br>在定义聚合的时候，应该遵守不变形约束法则：</p><ol><li>聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合</li><li>聚合内的某些对象的状态必须满足某个业务规则</li></ol></blockquote></li><li>聚合根（包）：一个上下文内可能包含多个聚合，每个聚合都有一个根实体，叫做聚合根，一个聚合只有一个聚合根</li><li>实体（Domain 或 Entity）：实体是具有身份和连贯性的领域概念，实体也是一个特殊的领域</li><li>值对象（Domain 或 Entity）：为了更好的展示领域模型之间的关系，制定的一个对象，本质上也是一种实体，但是相对实体而言，没有状态和身份标识，存在的目的就是为了表示一个值，通常使用值对象来传达数量的形式来表示</li></ul><h2 id="领域的四种模型"><a href="#领域的四种模型" class="headerlink" title="领域的四种模型"></a>领域的四种模型</h2><ol><li><a href="/posts/2876246174/">失血模型</a></li><li><a href="/posts/2879773850/">贫血模型</a></li><li><a href="/posts/2373614283/">充血模型</a></li><li><a href="/posts/491354674/">胀血模型</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>DDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD和Spring结合</title>
    <link href="/posts/3239946232/"/>
    <url>/posts/3239946232/</url>
    
    <content type="html"><![CDATA[<h1 id="DDD和Spring结合使用"><a href="#DDD和Spring结合使用" class="headerlink" title="DDD和Spring结合使用"></a>DDD和Spring结合使用</h1><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是 DDD 中明确提到的一种控制限界上下文的手段，一般尽量用一个模块来表示一个领域的限界上下文。<br>一般的工程中包的组织方式为 <code>&#123;com. 公司名. 组织架构. 业务. 上下文.*&#125;</code>，这样的组织结构能够明确的将一个上下文限定在包的内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.company.team.bussiness.counter.*; <span class="hljs-comment">// 计数上下文</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.category.*; <span class="hljs-comment">// 分类上下文</span><br></code></pre></td></tr></table></figure><h2 id="领域对象"><a href="#领域对象" class="headerlink" title="领域对象"></a>领域对象</h2><p>对于模块内部的组织结构，一般情况下我们时按照领域对象、领域服务、领域资源库、防腐层等组织方式定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.company.team.bussiness.cms.domain.valobj.*; <span class="hljs-comment">// 领域对象-值对象</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.cms.domain.entity.*; <span class="hljs-comment">// 领域对象-实体</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.cms.domain.aggregate.*; <span class="hljs-comment">// 领域对象-聚合根</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.cms.service.*; <span class="hljs-comment">//领域服务</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.cms.repo.*; <span class="hljs-comment">//领域资源库</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.cms.facade.*; <span class="hljs-comment">// 领域防腐层</span><br></code></pre></td></tr></table></figure><p>领域驱动要解决的一个重要的问题，就是解决对象的贫血问题，而领域对象则最直接的反应了这个能力。<br>我们定义聚合根（文章）和值对象（计数器），来举例说明<br>聚合根持有文章的 Id 和文章的计数器，这里的计数器之所以被列为值对象，而非实体的一个属性，是因为计数器是有多部分组成的，比如真实的阅读量、推广阅读量等。<br>在文章领域对象中，我们需要定义一个方法，来获取文章的计数器，用于页面上的显示，这个逻辑可能会很复杂，涉及到爆文、专栏作者级别、发布时间等因素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.team.bussiness.domain.aggregate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span>&#123;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> CategoryRepository categoryRepository;<br><span class="hljs-keyword">private</span> Long articleId;  <span class="hljs-comment">// 文章id</span><br><span class="hljs-keyword">private</span> ArticleCount articleCount; <span class="hljs-comment">//文章计数器</span><br><br><span class="hljs-comment">// 查询计显示数量，这里简化一些逻辑，甚至是不符合实际业务场景</span><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getShowArticleCount</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.articleCount == <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.articleCount.realCount + categoryRepository.getCategoryWeight(<span class="hljs-built_in">this</span>.category) + (<span class="hljs-built_in">this</span>.articleCount.addCount) * DayUtils.calDaysByNow(<span class="hljs-built_in">this</span>.articleCount.deadDays);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h2><p>资源库可以理解成 Dao，但是比 Dao 更宽泛，存储的手段可以是多样话的，常见的无非是数据库、分布式缓存、本地缓存等。资源库（Repository）的作用，就是对领域的存储和访问进行统一管理的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.company.team.bussiness.repo.dao.ArticleDao; <span class="hljs-comment">// 数据库访问对象-文章</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.repo.dao.CommentDao; <span class="hljs-comment">// 数据库访问对象-评论</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.repo.dao.po.ArticlePO; <span class="hljs-comment">// 数据库持久化对象-文章</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.repo.dao.po.CommentPO; <span class="hljs-comment">// 数据库持久化对象-评论</span><br><span class="hljs-keyword">import</span> com.company.team.bussiness.repo.cache.ArticleObj; <span class="hljs-comment">// 分布式缓存访问对象-文章缓存</span><br></code></pre></td></tr></table></figure><p>资源库对外的整体访问由 Repository 提供，它聚合了各个资源库的数据信息，同时也承担了资源存储的逻辑（例如缓存更新机制等等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.team.bussiness.repo;<br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleRepository</span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ArticleDao articleDao;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ArticleDaoCacheAccessObj articleDaoCacheAccessObj;<br><br><span class="hljs-keyword">public</span> Article <span class="hljs-title function_">getArticleById</span><span class="hljs-params">(<span class="hljs-type">int</span> articleId)</span>&#123;<br><span class="hljs-type">Article</span> <span class="hljs-variable">article</span> <span class="hljs-operator">=</span> articleDaoCacheAccessObj.get(articleId);<br><span class="hljs-keyword">if</span>(article != <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-keyword">return</span> article;<br>&#125;<br>article = getArticleFromDB(articleId);<br>articleCacheAccessObj.add(articleId, article);<br><span class="hljs-keyword">return</span> article;<br>&#125;<br><br><span class="hljs-keyword">public</span> Article <span class="hljs-title function_">getArticleFromDB</span><span class="hljs-params">(articleId)</span>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比起讲资源管理放在服务中的做法，由资源库对资源进行管理，职责更加明确，代码的可读性和可维护性也更强。</p><h2 id="防腐层"><a href="#防腐层" class="headerlink" title="防腐层"></a>防腐层</h2><p>也称适配层。在一个上下文中，有时需要对外部上下文进行访问，通常会引入防腐层的概念来对外部上下文的访问进行一次转义。<br>有以下几种情况会考虑到引入防腐层：</p><ol><li>需要讲外部上下文中的模型翻译成本上下文理解的模型</li><li>不同上下文之间的团队没有协作关系，如果是供奉者关系，建议引入防腐层，避免外部上下文变化对本上下文的侵蚀</li><li>该访问本上下文使用广泛，为了避免改动影响范围过大。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.team.bussiness.facade;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleFacade</span>&#123;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> ArticleService articleService;<br><br><span class="hljs-keyword">public</span> Article <span class="hljs-title function_">getArticle</span><span class="hljs-params">(ArticleContext context)</span>&#123;<br><span class="hljs-type">ArticleResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> articleService.getArticle(context.getArticleId());<br><span class="hljs-keyword">return</span> buildArticle(resp);<br>&#125;<br><br><span class="hljs-keyword">private</span> Article <span class="hljs-title function_">buildArticle</span><span class="hljs-params">(ArticleResponse resp)</span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>如果内部多个上下文对外部上下文需要访问，那么可以考虑将其放到通用上下文中。</li></ol><h2 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a>领域服务</h2><p>我们将领域行为封装到领域对象中，将资源管理行为封装到资源库中，将外部上下文的交互行为封装到防腐层中。此时，我们再回过头来看领域服务时，能狗发现领域服务本身所承载的职责也就更加清晰了，几就是通过串联领域对象、资源库和防腐层等一系列领域内的对象行为，对其他上下文提供交互的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.team.bussiness.service.impl;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommentService</span>&#123;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> CommentFacade commentFacade;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> ArticleRepository articleRepository;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> ArticleService articleService;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> CommentResponse <span class="hljs-title function_">commentArticle</span><span class="hljs-params">(CommentContext commentContext)</span>&#123;<br><span class="hljs-type">Article</span> <span class="hljs-variable">article</span> <span class="hljs-operator">=</span> articleRepository.getArticleById(commentContext.getArticleId); <span class="hljs-comment">//获取文章聚合根</span><br>commentFacade.doComment(commentContext); <span class="hljs-comment">//增加计数器</span><br><span class="hljs-keyword">return</span> buildCommentResponse(commentContext, article); <span class="hljs-comment">//组装评论后的文章信息</span><br>&#125;<br><br><span class="hljs-keyword">private</span> CommentResponse <span class="hljs-title function_">buildCommentResponse</span><span class="hljs-params">(CommentContext commentContext, Article article)</span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h2><img src="/posts/3239946232/images/%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="">]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>DDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD 实战</title>
    <link href="/posts/3778015330/"/>
    <url>/posts/3778015330/</url>
    
    <content type="html"><![CDATA[<h1 id="DDD-实战"><a href="#DDD-实战" class="headerlink" title="DDD 实战"></a>DDD 实战</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><ol><li>通过公共平台梳理出系统之间的调用关系（具有 RPC 和 HTTP 调用关系），画出来。<img src="/posts/3778015330/images/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.png" alt=""></li><li>分配组员每个人认领几个项目，来梳理项目维度关系，包括：对外接口、交互、用例、MQ 等详细说明。个别核心系统可以画出内部实体或者聚合根</li><li>小组开会，挨个 review 每个系统的业务概念，达到组内统一语言<img src="/posts/3778015330/images/%E7%BB%84%E5%86%85%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80.png" alt=""></li><li>根据以上资料，即可看出不合理的调用关系（比如循环调用、不规范的调用等），甚至不合理的分层</li><li>根据主线业务自顶向下细分领域，以及限界上下文。此过程可能会颠覆之前的系统划分</li><li>根据业务组杂性，指定领域模型，选择贫血或充血模型。团队内最好实行统一习惯，以免出现交接成本过大</li><li>分工进行开发，并设置 deadline，注意：不要单一的设置一个 deadline，要设置中间 check 时间，用来分别沟通代码风格以及边界职责，以免 deadline 延期</li></ol><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><h3 id="领域模型设计"><a href="#领域模型设计" class="headerlink" title="领域模型设计"></a>领域模型设计</h3><p>以渠道中心（一个微服务）作为例子来做领域模型设计，核心就是设计 2 个图，一个是战略设计图（宏观），一个是战术设计图（微观）</p><ol><li>领域战略设计图<br>战略设计图是一个限界上下文的角度出发去分析业务场景。主要是宏观上的核心域、子域、实体关系图。如下图：<img src="/posts/3778015330/images/%E9%A2%86%E5%9F%9F%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt=""></li><li>领域战术设计图<br>战术设计图是从一个限界上下文的角度出发分析业务场景。细化到核心业务字段、领域实体、值对象、领域服务、领域事件等。基本上这个图画完，代码已经知道怎么写了。如下图：<img src="/posts/3778015330/images/%E9%A2%86%E5%9F%9F%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt=""></li></ol><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><p>整体项目架构分层如下图：<br><img src="/posts/3778015330/images/DDD%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.png" alt=""><br>四层典型 DDD 分层架构：</p><ol><li>展现层：controller 层。无业务逻辑</li><li>应用服务层：此层可以包含查询逻辑，但核心业务逻辑必须下沉到领域层</li><li>领域服务层：业务在这里组装。仓储（资源库）接口在此定义</li><li>基础设计层：仓库（资源层）实现层+PO持久化层</li></ol><p>注：</p><ol><li>简单查询不设计业务，是可以直接从应用层直接穿透到 PO 查询，不需要经过 Domain 层。DDD 本身是不限制非业务类操作跨层调用的。如下图：<img src="/posts/3778015330/images/DDD%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.png" alt=""></li><li>DTO 是不能存在于 Domain 层的，DDD 设计不认为 DTO 是业务对象，entity 才是。或者传值简单数据类型也是可以的。</li></ol><h3 id="服务调用问题"><a href="#服务调用问题" class="headerlink" title="服务调用问题"></a>服务调用问题</h3><h4 id="域内调用"><a href="#域内调用" class="headerlink" title="域内调用"></a>域内调用</h4><p>领域内调用，随便调用。实现由一个核心域的仓库实现层（第四层）去实现多个 Repository 接口（比如这里 A 时核心域的实体名，B是支撑域、通用域等）<br><img src="/posts/3778015330/images/%E9%A2%86%E5%9F%9F%E5%86%85%E8%B0%83%E7%94%A8.png" alt=""></p><h4 id="跨域调用"><a href="#跨域调用" class="headerlink" title="跨域调用"></a>跨域调用</h4><p>跨域调用分为：</p><ol><li>同上下文跨域：ACL 层 -&gt; Adapter 适配器层 -&gt; 调用其他域的 repository （不推荐使用）<br>推荐使用：<blockquote><ol><li>使用领域事件 eventBus 来解耦</li><li>考虑是否可以合并为一个领域</li></ol></blockquote></li><li>跨上下文（肯定跨域）：ACL 层 -&gt; Adapter 适配器层 -&gt; feign 调用 <img src="/posts/3778015330/images/%E8%B7%A8%E5%9F%9F%E8%B0%83%E7%94%A8.png" alt=""></li></ol><h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><p>包结构：<br><img src="/posts/3778015330/images/DDD%E5%88%86%E5%B1%82.png" alt=""><br>包结构细节：<br><strong>展现层</strong>：Controller 仅做接口的入口定义和编排转发，不做任何业务处理<br><strong>应用服务层</strong>：application 负责接口参数 DTO 的简单校验，以及 DTO 和实体值对象的数据转换，对于简单业务，可以在应用层加载实体直接执行实体行为方法<br><strong>领域层</strong>：</p><ul><li>模型：根据领域模型分析领域内各个实体、聚合、聚合根、值对象等，这些对象在 <strong>*. domain.model</strong> 中定义，实体内的行为方法只负责维护实体自身的生命周期和状态</li><li>行为：领域内各实体、聚合、聚合根等，会有相应的行为，在 <strong>*.domain.model</strong>包下定义行为方法   </li><li>领域服务：领域提供的接口服务，需要定义在 <strong>*.domain.service</strong> 包下，业务相关的前置业务判断、多个实体或值对象的行为逻辑处理等，都在领域服务中实现，需要注意的是并不是每个实体都有一个对应的领域服务，但是依赖多个实体的行为方法，最好根据这个业务模块是建立一个领域服务</li><li>仓储：领域服务或上层应用服务需要使用到的基础设施层，包括 DB、Feign 调用等，定义在 <strong>*.domain.repository</strong> 下，在 <strong>*. infrastructure.repository</strong> 下实现<br><strong>适配层</strong>：在 acl 包下的 feign 定义依赖外部的接口，并在 acl 的 adapter 包编写转换，由仓储层操作实体时调用<br><strong>持久层</strong>：与常用 DAO 定义一致，由仓储层操作实体时调用<img src="/posts/3778015330/images/DDD%E5%90%84%E5%B1%82%E7%BB%86%E8%8A%82.png" alt=""></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>DDD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>充血模型</title>
    <link href="/posts/2373614283/"/>
    <url>/posts/2373614283/</url>
    
    <content type="html"><![CDATA[<h1 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>充血模型中，绝大多业务逻辑都因该放在 <code>domain object</code> 里面，包括持久话逻辑，而 <code>Service</code> 层是很薄的一层，仅封装事务和少量逻辑，不和<code>dao</code>层打交道<br><em>Service</em>：组合服务，也叫事务服务<br><em>model</em>：除包含 <code>get/set</code> 方法，还包含原子服务和数据持久化的逻辑</p><h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><blockquote><p>充血模型和贫血模型的区别在于业务逻辑划分，将绝大多数业务逻辑放到 Domain 中。<br>Service(事务封装) -&gt; Domain Object &lt;–&gt; Dao</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArticleDao articleDao;<br><br><span class="hljs-keyword">private</span> Long id;<br><span class="hljs-keyword">private</span> String title;<br><span class="hljs-keyword">private</span> Long authorId;<br><br><span class="hljs-comment">// 使用 articleDao 进行持久化交互</span><br><span class="hljs-keyword">public</span> List&lt;Article&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> articleDao.findAll();<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHotClass</span><span class="hljs-params">(Article article)</span>&#123;<br><span class="hljs-keyword">return</span> Stream.of(<span class="hljs-number">57</span>,<span class="hljs-number">102</span>).anyMatch(classId-&gt;classId.equals(article.getId));<br>&#125;<br><br><span class="hljs-keyword">public</span> Article <span class="hljs-title function_">changeClass</span><span class="hljs-params">(Article article, ArticleClass ac)</span>&#123;<br><span class="hljs-keyword">return</span> article.setClassId(ac.getId());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>所有的业务逻辑都在 Domain 中，事务管理也在 Item 中实现。</strong><br>优点：</p><ol><li>更加符合OO的原则</li><li>Service 层很薄，只充当 Facade 的角色，不和Dao打交道<br>缺点：</li><li>Dao 和 Domain Object 形成了双向依赖，复杂的双向依赖会导致很多潜在的问题</li><li>如何划分 Service 层逻辑和 Domain 层逻辑是非常含混的，在实际项目中，由于设计和开发人员的水平差异，可能导致整个结构的混乱无序</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>领域模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>领域模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>失血模型</title>
    <link href="/posts/2876246174/"/>
    <url>/posts/2876246174/</url>
    
    <content type="html"><![CDATA[<h1 id="失血模型"><a href="#失血模型" class="headerlink" title="失血模型"></a>失血模型</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>失血模型中，<code>domain object</code> 只有属性的 <code>get</code>、<code>set</code> 方法的纯数据类，所有的业务逻辑完全由 <code>service</code> 层来完成的，由于没有 <code>dao</code>，<code>Service</code> 直接操作数据库，进行数据持久化</p><p><em>Service</em>：肿胀的服务逻辑<br><em>model</em>：只包含 <code>get/set</code>方法</p><h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><blockquote><p>Domain Object 只有属性的 <code>getter/setter</code> 方法的纯数据类，所有的业务逻辑完全由 business object 完成 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span> &#123;<br><span class="hljs-keyword">private</span> Long id;<br><span class="hljs-keyword">private</span> String title;<br><span class="hljs-keyword">private</span> Long classId;<br><span class="hljs-keyword">private</span> String authorName;<br><span class="hljs-keyword">private</span> Long authorId;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArticleDao</span>&#123;<br>Article <span class="hljs-title function_">getArticleById</span><span class="hljs-params">(Long id)</span>;<br>Article <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>领域模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>领域模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胀血模型</title>
    <link href="/posts/491354674/"/>
    <url>/posts/491354674/</url>
    
    <content type="html"><![CDATA[<h1 id="胀血模型"><a href="#胀血模型" class="headerlink" title="胀血模型"></a>胀血模型</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>胀血模型取消了 <code>service</code> 层，只剩下 <code>domain object</code> 和 <code>dao</code> 两层，在<code>domain object</code>的<code>domain logic</code>上面封装事务</p><h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><blockquote><p>直接取消 Service 层，只剩下 Domain Object 和 Dao 两层，在 Domain Object 的 Domain Logic 上面封装事务<br> Domain Object（事务封装，业务逻辑）&lt;–&gt; Dao</p></blockquote><p>优点：</p><ol><li>简化了分层</li><li>也算符合OO<br>缺点：</li><li>很多不是 Domain Logic 的 Service 逻辑也被强行放入 Domain Object，引起了 Domain Object 模型的很不稳定</li><li>Domain Object 暴露给 Web 层过多信息，可能引起意想不到的副作用</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>领域模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>领域模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贫血模型</title>
    <link href="/posts/2879773850/"/>
    <url>/posts/2879773850/</url>
    
    <content type="html"><![CDATA[<h1 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>贫血模型中，<code>domain object</code> 包含了不依赖持久化的原子领域逻辑，而组合逻辑在 <code>Service</code> 层<br><em>service</em>：组合服务，也叫事务服务<br><em>model</em>：除包含 <code>get/set</code> 方法，还包含原子事务<br><em>dao</em>：数据持久化</p><h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><blockquote><p>Domain Object 包含了不依赖于持久化的领域逻辑，而那些依赖持久化的领域逻辑被分到了 Service 层</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span>&#123;<br><span class="hljs-keyword">private</span> Long id;<br><span class="hljs-keyword">private</span> String title;<br><span class="hljs-keyword">private</span> Long authorId;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHotClass</span><span class="hljs-params">(Article article)</span>&#123;<br><span class="hljs-keyword">return</span> Stream.of(<span class="hljs-number">57</span>,<span class="hljs-number">102</span>).anyMatch(classId-&gt;classId.equals(article.getId));<br>&#125;<br><br><span class="hljs-keyword">public</span> Article <span class="hljs-title function_">changeClass</span><span class="hljs-params">(Article article, ArticleClass ac)</span>&#123;<br><span class="hljs-keyword">return</span> article.setClassId(ac.getId());<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ArticleDao</span>&#123;<br><span class="hljs-keyword">private</span> ArticleDao articleDao;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeClass</span><span class="hljs-params">(Article article, ArticleClass ac)</span>&#123;<br>article.changeClass(article, ac);<br>articleDao.update(article);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：这个模式不在 Domain 中依赖 Dao，持久化的工作还需要在 Dao 或者Service中进行</strong><br>优点：</p><ol><li>各层单向依赖，结构清晰<br>缺点：</li><li>Domain Object 的部分比较紧密依赖的持久化 Domain Logic 被分离到 Service 层，显得不够OO</li><li>Service层过于厚重</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>架构</category>
      
      <category>软件架构</category>
      
      <category>领域模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>领域模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java HashMap源码分析</title>
    <link href="/posts/379/"/>
    <url>/posts/379/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-HashMap"><a href="#Java-HashMap" class="headerlink" title="Java HashMap"></a>Java HashMap</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>哈希表结构（链表散列：数组+链表）实现，结合数组和链表的优点。当链长超过 8 时，链表转换为红黑树</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map。Map. Entry 接口）实现，HashMap 通过 put 和 get 方法存储和获取</p><p>存储对象时，将 K&#x2F;V 键值传给 <code>put()</code> 方法</p><ol><li>调用 <code>hash(K)</code> 方法计算 K 的 hash 值，然后结合数组长度，计算得到数组的下标</li><li>调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容 resize 为 2n）</li><li>如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，且 equals 返回相等，则更新 V，如果不相等，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）</li><li>当碰撞导致链表大于 <code>TREEIFY_THRESHOLD=8</code> 就把链表转换成红黑树</li></ol><p>获取对象时，将 K 传给 <code>get()</code> 方法</p><ol><li>调用 hash(K) 方法计算 K 的 hash 值 从而获取该键值在链表的数组下标</li><li>顺序遍历链表，<code>equals()</code> 方法查找相同 Node 链表中 K 值对应的 V 值</li></ol><p><strong>hashCode 用于定位，存储位置；equals用于比较两者是否相等</strong></p><h2 id="为什么不用二叉树"><a href="#为什么不用二叉树" class="headerlink" title="为什么不用二叉树"></a>为什么不用二叉树</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程</title>
    <link href="/posts/382/"/>
    <url>/posts/382/</url>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ul><li>NEW：新建状态，线程被创建出来，但尚未启动时的线程状态</li><li>RUNNABLE：就绪状态，表示可以运行的线程状态，可能是在运行，也有可能是在排队等待操作系统分配CPU资源</li><li>BLOCKED：阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行<code>synchronized</code>代码块或者使用<code>synchronized</code>标记的方法</li><li>WAITING：等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定动作，比如，一个线程调用了 <code>Object.wait()</code> 方法，那就在等待另一个线程调用 <code>Object.notify()</code> 或 <code>Object.notifyAll()</code> 方法</li><li>TIMED_WAITING：计时等待状态和 WAITING 类似，只是多了超时时间，比如调用了有超时时间设置的方法 <code>Object.warit(long timeout)</code> 和 <code>Thread.join(long timeout)</code> 等这些方法时，才会进入此状态</li><li>TERMINATED：终止状态，表示线程已经执行完成</li></ul><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>创建线程并指定线程需要执行的业务方法，调用线程的 <code>start()</code> 方法，就会从 <code>NEW</code> 状态变成 <code>RUNNABLE</code> 状态，线程会判断要执行的方法中有没有 <code>synchronized</code> 同步代码块，如果有并且其他线程也在使用此锁，那么线程就会变为 <code>BLOCKED</code> 状态，当其他线程使用完此锁之后，线程会继续执行剩余方法。当遇到 <code>Object.wait()</code> 或 <code>Thread.join()</code> 时，线程就会变为 <code>WAITING</code> 状态，如果是带了超时时间的等待方法，那么线程就会进入 <code>TIME_WAITING()</code> 状态，当有其他线程执行了 <code>notify()</code> 或 <code>notifyAll()</code> 方法之后，线程被唤醒继续执行剩下的方法<br><img src="/posts/382/images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="线程的执行流程"></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java String源码分析</title>
    <link href="/posts/380/"/>
    <url>/posts/380/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-String"><a href="#Java-String" class="headerlink" title="Java String"></a>Java String</h1><h2 id="Stirng、StringBuilder-和-StringBuffer-的区别"><a href="#Stirng、StringBuilder-和-StringBuffer-的区别" class="headerlink" title="Stirng、StringBuilder 和 StringBuffer 的区别"></a>Stirng、StringBuilder 和 StringBuffer 的区别</h2><p>因为 String 类型是不可变的，所以在字符串拼接的时候如果使用 String 会导致性能很低，因此需要看 StirngBuffer 来保证性能，StringBuffer 提供了可用于字符串的拼接，使用了 <code>synchronized</code> 来保证线程安全。但是会导致性能低下，所有使用 StringBuilder 来在非线程安全下使用并保证性能</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go编译模式</title>
    <link href="/posts/368/"/>
    <url>/posts/368/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-编译模式"><a href="#Go-编译模式" class="headerlink" title="Go 编译模式"></a>Go 编译模式</h1><p>在使用 <code>go build</code> 或 <code>go install</code> 两个命令编译代码的时候要生成什么样的文件。即:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -buildmode=&lt;mode&gt;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> install -buildmode=&lt;mode&gt;<br></code></pre></td></tr></table></figure><p>#Todo 记录 Go 语言各种编译模式 </p><ol><li><a href="https://chenjiehua.me/golang/golang-buildmode.html">https://chenjiehua.me/golang/golang-buildmode.html</a></li><li><a href="https://www.niansong.top/2020/12/29/Go%E8%AF%AD%E9%9F%B3%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F%E6%B5%85%E8%B0%88/">https://www.niansong.top/2020/12/29/Go%E8%AF%AD%E9%9F%B3%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F%E6%B5%85%E8%B0%88/</a></li></ol><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>在 go 编译时，go 编译器支持的模式有：</p><ol><li><p><code>-buildmode=archive</code>：把源文件编译成 Go 语言的静态库文件，如果包名为<code>main</code>会被忽略掉</p></li><li><p><code>-buildmode=c-archive</code>：把源文件编译成 C 语言可以使用的静态库，也就是 <code>.a</code> 文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br><span class="hljs-comment">// export Add</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d + %d = %d\n&quot;</span>, a, b, a + b)<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用 <code>-buildmode=c-archive</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build -buildmode=c-archive add.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure></li><li><p><code>-buildmode=c-shared</code>：编译成 C 可以使用的动态库文件，也就是 <code>.so</code> 文件或者<code>.dll</code>文件</p></li><li><p><code>-buildmode=default</code>：默认编译</p></li><li><p><code>-buildmode=shared</code>：Go 使用的静态链接库文件，C 不能使用，将非 <code>main</code> 的 package 编译为动态链接库，并在构建其他 Go 程序时使用 <code>-linkshared</code> 参数来指定，编译 Go 动态库 <code>go install -buildmode=shared std</code>，需要注意的是暂时不支持 macos</p></li><li><p><code>-buildmode=exe</code>：编译成 <code>.exe</code> 文件，忽略包名为 <code>main</code></p></li><li><p><code>-buildmode=pie</code>：编译带上这个参数可以防止反编译，即使反编译也看不懂</p></li><li><p><code>-buildmode=plugin</code>：Go 的插件，将 <code>package main</code> 编译为一个 go 插件，并可在运行时动态加载</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据类型</title>
    <link href="/posts/367/"/>
    <url>/posts/367/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-数据类型"><a href="#Go-数据类型" class="headerlink" title="Go 数据类型"></a>Go 数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><ol><li>uint8: 无符号 8 为整形 (0-255)</li><li>unit16: 无符号16位整形(0-65535)</li><li>unit32: 无符号32位整形(0-4294967295)</li><li>unit64: 无符号64位整形(0-18446744073709551615)</li><li>int8: 有符号 8位整型 (-128 到 127)</li><li>int16: 有符号 16位整型 (-32768 到 32767)</li><li>int32: 有符号 32位整型 (-2147483648 到 2147483647)</li><li>int64: 有符号 64 位整型(-9223372036854775808 到 9223372036854775807)</li></ol><h2 id="特殊整形"><a href="#特殊整形" class="headerlink" title="特殊整形"></a>特殊整形</h2><ol><li>uint: 32 位操作系统上就是 <code>uint32</code>，64 位操作系统上就是 <code>uint64</code></li><li>int: 32 位操作系统上就是 <code>int32</code>，64位操作系统上就是<code>int64</code></li><li>uintptr: 无符号整型，用于存放一个指针</li></ol><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><ol><li>float32: 最大范围 <code>3.4e38</code>，常量 <code>math.MaxFloat32</code> </li><li>float64: 最大范围 <code>1.8e308</code>，常量 <code>math.MaxFloat64</code></li></ol><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><ol><li>complex64: 实部和虚部都是 32 位</li><li>complex128: 实部和虚部都是 64 位</li></ol><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>bool 进行声明，只有 <code>true</code> 和 <code>false</code> 两个值，默认为 false </p><h2 id="byte-和-rune-类型"><a href="#byte-和-rune-类型" class="headerlink" title="byte 和 rune 类型"></a>byte 和 rune 类型</h2><ol><li>uint8 类型，或者叫 byte 型，代表一个<code>ASCII</code>码字符</li><li>rune 类型：代表一个 <code>UTF-8</code> 字符</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>定义: <code>var 变量名 [元素数量]类型</code></p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>本质就是对底层数组的封装，包含三个信息：底层数组的指针、切片的长度(len)和切片的容量(cap)，只是一个引用，最终指向的还是原数组同一个地址<br>切片是一个拥有相同类型元素的可变长度的序列。基于数据类型做的一层封装。非常灵活，支持自动扩容。是一个引用类型，内部结构包含 <code>地址</code>、<code>长度</code> 和 <code>容量</code>。一般用于快速操作一块数据集合</p><p>定义: <code>var 变量名 []类型</code> </p><blockquote><p>切片的长度和容量</p></blockquote><p>切片拥有自己的长度和容量，可以通过内置的 <code>len()</code> 函数求长度，使用内置的<code>cap()</code>函数求切片的容量</p><p><strong>切片无法直接比较，不能使用 <code>==</code> 来判断两个切片是否相等。可以通过<code>equal.Equal</code> 进行比较</strong></p><h4 id="复制切片"><a href="#复制切片" class="headerlink" title="复制切片"></a>复制切片</h4><p><code>copy()</code> 可以将一个切片的数据复制到另外一个切片空间中。使用方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">copy</span>(destSlice,srcSlice []T)<br></code></pre></td></tr></table></figure><p>destSlice: 数据来源切片<br>srcSlice: 目标切片</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">var</span> a []<span class="hljs-type">int</span> = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;  <br>   a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>:]...)  <br>   fmt.Println(a)  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[keyType]valueType<br></code></pre></td></tr></table></figure><p>这样定义出来的变量默认初始值是 nil，需要使用 make 函数 来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[keyType]valueType, [<span class="hljs-built_in">cap</span>])<br></code></pre></td></tr></table></figure><h3 id="判断-key-是否存在"><a href="#判断-key-是否存在" class="headerlink" title="判断 key 是否存在"></a>判断 key 是否存在</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value,ok := <span class="hljs-keyword">map</span>[key]<br></code></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)  <br>   a[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;张三&quot;</span>  <br>   fmt.Println(a)  <br>   <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> a &#123;  <br>      <span class="hljs-built_in">print</span>(value)  <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(<span class="hljs-keyword">map</span>,key)<br></code></pre></td></tr></table></figure><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><strong>derfer 语句会将其后面跟随的语句进行延迟处理。在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 定义的逆序进行执行。也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行</strong></p><h3 id="defer-的执行时机"><a href="#defer-的执行时机" class="headerlink" title="defer 的执行时机"></a>defer 的执行时机</h3><blockquote><p>Go 语言的函数中，<code>return</code> 语句在底层并不是原子操作，分为给返回值赋值和 RET 指令两步。而 defer 语句执行的时机在返回值赋值操作后，RET 指令执行前。</p></blockquote><img src="/posts/367/images/defer%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA.png" alt="defer执行时机"><h2 id="Go-结构体"><a href="#Go-结构体" class="headerlink" title="Go 结构体"></a>Go 结构体</h2><p><strong>Go 语言没有类的概念，也不支持类的继承等面向对象的概念。Go 语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性</strong></p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>使用  <code>type</code>  和 <code>struct</code> 关键字来定义结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 类型名 <span class="hljs-keyword">struct</span>&#123;<br>字段名 字段类型<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复</li><li>字段名：表示结构体字段名</li><li>字段类型：表示结构体字段的具体类型</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>接口类型具体描述了一系列方法的集合，接口的实例则是实现了这些方法的具体类型。<br><strong>Go 语言中的接口的实现都是隐式的，只需要实现对应接口中的所有方法就实现了这个接口</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速学会一门语言的50%</title>
    <link href="/posts/356/"/>
    <url>/posts/356/</url>
    
    <content type="html"><![CDATA[<p>现在的开发工作要求我们能够快速掌握一门语言。一般来说应对这种挑战有两种态度：其一，粗粗看看语法，就撸起袖子开干，边查Google边学习；其二是花很多时间完整地把整个语言学习一遍，做到胸有成竹，然后再开始做实际工作。然而这两种方法都有弊病。第二种方法的问题当然很明显，不仅浪费了时间，偏离了目标，而且学习效率不高。因为没有实际问题驱动的语言学习通常是不牢固不深入的。有的人学着学着成了语言专家，反而忘了自己原本是要解决问题来的。第一种路子也有问题，在对于这种语言的脾气秉性还没有了解的情况下大刀阔斧地拼凑代码，写出来的东西肯定不入流。说穿新鞋走老路，新瓶装旧酒，那都是小问题，真正严重的是这样的程序员可以在短时间内堆积大量充满缺陷的垃圾代码。由于通常开发阶段的测试完备程度有限，这些垃圾代码往往能通过这个阶段，从而潜伏下来，在后期成为整个项目的毒瘤，反反复复让后来的维护者陷入西西弗斯困境。<br>实际上语言学习有一定规律可循，对于已经掌握一门语言的开发者来说，对于一般的语言，完全可以以最快的速度，在几天至一周之内掌握其最常用的50%，而且保证路子基本正宗，没有出偏的弊病。其实真正写程序不怕完全不会，最怕一知半解的去攒解决方案。因为你完全不会，就自然会去认真查书学习，如果学习能力好的话，写出来的代码质量不会差。而一知半解，自己动手土法炼钢，那搞出来的基本上都是废铜烂铁。比如错误处理和序列化，很多人不去了解“正路子”，而是凭借自己的一知半解去攒野路子，这是最危险的。因此，即使时间再紧张，这些内容也是必须首先完整了解一遍的。掌握这些内容之后进入实际开发，即使有问题，也基本不会伤及项目大体。而开发者本人则可以安步当车，慢慢在实践中提高自己。<br>以下列出一个学习提纲，主要针对的是有经验的人，初学者不合适。这个提纲只能用于一般的庸俗编程语言学习，目前在流行编程语言排行榜上排前20的基本上都是庸俗语言。如果你要学的是LISP之类非庸俗语言，或是某个软件中的二次开发语言，这里的建议未必合适。还是那句话，仅供参考。</p><ol><li><strong>首先了解该语言的 #基本数据类型 ，基本 #语法 和 #主要语言构造</strong> ， #主要数学运算符 和 #print函数 的使用，达到能够写谭浩强程序设计书课后数学习题的程度</li><li><strong>其次掌握 #数组 和其他 #集合类 的使用</strong>，有基础的话可以理解一下 #泛型 ，如果理解不了也问题不大，后面可以补</li><li>简单 #字符串 处理。所谓简单，就是Regex和Parser以下的内容，什么查找替换，截断去字串之类的。不过这个阶段有一个难点，就是字符编码问题。如果理解不了，可以先跳过，否则的话最好在这时候把这个问题搞定，免留后患</li><li><strong>基本 #面向对象 或者 #函数式编程 的特征</strong>，无非是什么继承、多态、Lambda函数之类的，如果有经验的话很快就明白了</li><li><strong>#异常 、 #错误处理 、 #断言 、 #日志 和 #调试支持</strong> ，对 #单元测试 的支持。你不一定要用TDD，但是在这个时候应该掌握在这个语言里做TDD的基本技能</li><li><strong>程序代码和 #可执行代码 的 #组织机制 ， #运行时模块加载  、 #符号查找机制</strong>，这是初学时的一个难点，因为大部分书都不太注意介绍这个极为重要的内容</li><li><strong>#基本输入输出  和 #文件处理 ， #输入输出流类 的组织</strong>，这通常是比较繁琐的一部分，可以提纲挈领学一下，搞清楚概念，用到的时候查就是了。到这个阶段可以写大部分控制台应用了；</li><li><strong>该语言如何进行 #callback方法调用 ，如何支持 #事件驱动编程模型</strong>。在现代编程环境下，这个问题是涉及开发思想的一个核心问题，几乎每种语言在这里都会用足功夫，.NET的delegate，Java的anonymous inner class，Java 7的closure，C++OX的 tr1::function&#x2F;bind，五花八门。如果能彻底理解这个问题，不但程序就不至于写得太走样，而且对该语言的设计思路也能有比较好的认识</li><li>如果有必要，可在这时研究 #regex 和 #XML处理 问题，如无必要可跳过</li><li><strong>#序列化 和 #反序列化</strong>，掌握一下缺省的机制就可以了</li><li>如果必要，可了解一下 #线程 、 #并发 和 #异步调用 机制，主要是为了读懂别人的代码，如果自己要写这类代码，必须专门花时间严肃认真系统地学习，严禁半桶水上阵</li><li>#动态编程 ， #反射 和 #元数据编程 ， #数据和程序之间的相互转化 机制， #运行时编译和执行 的机制 ，有抱负的开发者在这块可以多下些功夫，能够使你对语言的认识高出一个层面</li><li>如果有必要，可研究一下该语言对于 #泛型 的支持，不必花太多时间，只要能使用现成的 #泛型集合 和 #泛型函数 就可以了，可在以后闲暇时抽时间系统学习。需要注意的是，泛型技术跟多线程技术一样，用不好就成为万恶之源，必须系统学习，谨慎使用，否则不如不学不用</li><li>如果还有时间，最好咨询一下有经验的人，看看这个语言较常用的 #特色 features是什么，如果之前没学过，应当补一下。比如Ruby的block interator, Java的dynamic proxy，C# 3的LINQ和extension method。没时间的话，我认为也可以边做边学，没有大问题</li><li>有必要的话，在工作的闲暇时间，可以着重考察两个问题，第一，这个语言有哪些 #惯用法 和 #模式 ，第二，这个语言的 #编译执行机制  、 #解释执行机制<br>至此语言的基本部分就可以说掌握了，之后是做数据库、网络还是做图形，可以根据具体需求去搞，找相应的成熟框架或库，边做边学，加深理解。对于一个庸俗语言，我自己把上面的内容走一遍大概要花2-3周时间，不能算很快，但也耽误不了太多事情，毕竟不是每个月都学新语言。掌握了以上的内容，就给练武术打好了基本功，虽然不见得有多优秀，但是肯定是根正苗红，将来不必绕大弯子。就算是临时使用的语言，把上面这个提纲精简一下，只看蓝色重体字的部分，大致能在几天到一周内搞定，不算是太耗时，而且写出来的代码不会太不靠谱。<br>以上提纲未设及内存模型。对于C&#x2F;C++，这个问题很重要，要放在显著位置来考虑，但对于其他语言，这个问题被透明化了，除非你要做hardcore项目，否则不必太关注。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Go函数</title>
    <link href="/posts/364/"/>
    <url>/posts/364/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-函数"><a href="#Go-函数" class="headerlink" title="Go 函数"></a>Go 函数</h1><p><strong>Go 语言支持函数、匿名函数和闭包，并且函数是 Go 语言中属于一等公民</strong></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名<span class="hljs-params">(参数)</span></span>返回值&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数名：由字母、数字、下划线组成。但是函数名的第一个字母不能是数字。在同一个包内，函数名不能重复</li><li>参数：由参数变量和参数类型组成</li><li>返回值：由返回值变量和变量的类型组成，多个返回值使用 <code>()</code> 包裹，并用 <code>,</code> 分隔</li></ul><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>使用 <code>type</code> 关键字定义一个函数类型，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> calculation <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>凡是满足这个条件的函数都是 <code>calculation</code> 类型的函数。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x,y <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br><span class="hljs-keyword">return</span> x+y<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(x,y <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br><span class="hljs-keyword">return</span> x-y<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的两个函数 <code>add</code>、<code>sub</code> 可以赋值给 <code>calculation</code> 类型的变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x calculation<br>x = add<br>fmt.Println(x(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><strong>高阶函数分为函数作为参数和函数作为返回值两个部分</strong></p><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;  <br>   <span class="hljs-keyword">return</span> x + y  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>, op <span class="hljs-keyword">func</span>(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;  <br>   <span class="hljs-keyword">return</span> op(x, y)  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   i := calc(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, add)  <br>   fmt.Println(i)  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;  <br>   <span class="hljs-keyword">switch</span> s &#123;  <br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:  <br>      <span class="hljs-keyword">return</span> add, <span class="hljs-literal">nil</span>  <br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:  <br>      <span class="hljs-keyword">return</span> sub, <span class="hljs-literal">nil</span>  <br>   <span class="hljs-keyword">default</span>:  <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;无法识别&quot;</span>)  <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(参数)</span></span>(返回值)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>匿名函数没有函数名，没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包指的是一个函数和其他相关的引用环境组合而成的实体。<code>闭包=函数+引用环境</code>。</strong> 例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;  <br>   <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span>  <br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;  <br>      x += y  <br>      <span class="hljs-keyword">return</span> x  <br>   &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">var</span> f = adder()  <br>   fmt.Println(f(<span class="hljs-number">1</span>))  <br>   fmt.Println(f(<span class="hljs-number">2</span>))  <br>&#125;<br><span class="hljs-comment">// 输出 1 3</span><br></code></pre></td></tr></table></figure><p>变量 <code>f</code> 是一个函数并且引用了外部作用域 <code>x</code> 变量，此时 <code>f</code> 就是一个闭包。在 <code>f</code> 的生命周期内，变量<code>x</code>一直有效 </p><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语法</title>
    <link href="/posts/369/"/>
    <url>/posts/369/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-语法"><a href="#Go-语法" class="headerlink" title="Go 语法"></a>Go 语法</h1><h2 id="Go-关键字"><a href="#Go-关键字" class="headerlink" title="Go 关键字"></a>Go 关键字</h2><blockquote><p>共25个</p></blockquote><p><code>break</code>  <code>default</code>  <code>func</code>  <code>interface</code> <code>select</code> <code>case</code> <code>defer</code> <code>go</code> <code>map</code> <code>struct</code> <code>chan</code> <code>else</code> <code>goto</code> <code>package</code> <code>switch</code> <code>const</code> <code>fallthrough</code> <code>if</code> <code>range</code> <code>type</code> <code>continue</code> <code>for</code> <code>import</code> <code>return</code> <code>var</code></p><h2 id="Go-保留字"><a href="#Go-保留字" class="headerlink" title="Go 保留字"></a>Go 保留字</h2><blockquote><p>共37个  </p></blockquote><p>Constants:<br><code>true</code> <code>false</code> <code>iota</code> <code>nil</code></p><p>Types:<br><code>int</code> <code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code> <code>uint</code> <code>uint8</code> <code>uint16</code> <code>uint32</code> <code>uint64</code> <code>uintptr</code> <code>float32</code> <code>float64</code> <code>complex128</code> <code>complex64</code> <code>bool</code> <code>byte</code> <code>rune</code> <code>string</code> <code>error</code></p><p>Functions:<br><code>make</code> <code>len</code> <code>cap</code> <code>new</code> <code>append</code> <code>copy</code> <code>close</code> <code>delete</code> <code>complex</code> <code>real</code> <code>imag</code> <code>panic</code> <code>recover</code></p><h2 id="Go-变量"><a href="#Go-变量" class="headerlink" title="Go 变量"></a>Go 变量</h2><h3 id="Go-变量声明"><a href="#Go-变量声明" class="headerlink" title="Go 变量声明"></a>Go 变量声明</h3><ol><li>标准声明：<code>var 变量名 变量类型</code></li><li>批量声明：<code>var (a string; b string)</code></li></ol><h3 id="Go-变量初始化"><a href="#Go-变量初始化" class="headerlink" title="Go 变量初始化"></a>Go 变量初始化</h3><ol><li>标准声明：<code>var 变量名 类型 = 表达式</code></li></ol><h2 id="令牌"><a href="#令牌" class="headerlink" title="令牌"></a>令牌</h2><p>Go 程序包括各种令牌，令牌可以是一个关键字，一个标识符，常量，字符串文字或符号。例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br></code></pre></td></tr></table></figure><p>由 6 个令牌组成，分别为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt<br>.<br>Println<br>(<br><span class="hljs-string">&quot;hello world&quot;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="行分离器"><a href="#行分离器" class="headerlink" title="行分离器"></a>行分离器</h2><p>行的分隔符关键是一个语句终止。也就是说，每一个单独语句不需要特殊的分割线</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符是用来标识标量，函数或任何其他用户定义的项目名称。一个标识符可以以字母或下划线开头，后面跟零个或多个字母，下划线和数字<br><code>identifier = letter &#123;letter | unicode_digit&#125;</code></p><h2 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h2><h3 id="三种特殊形式"><a href="#三种特殊形式" class="headerlink" title="三种特殊形式"></a>三种特殊形式</h3><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (  <br>   _ <span class="hljs-string">&quot;github.com/v2fly/v2ray-core/v4/main/distro/all&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>这种方式导包，只是为了执行该包下所有的 <code>init()</code> 函数，所以也就没办法通过包名来调用包中的其他函数</p><h4 id="加点"><a href="#加点" class="headerlink" title="加点"></a>加点</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br>. <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式导包，是为了之后在调用这个包的函数时，可以省略前缀的包名</p><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> f <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>f.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>别名操作可以把包命名成另一个用起来比较容易记忆的名字</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go指针</title>
    <link href="/posts/366/"/>
    <url>/posts/366/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-指针"><a href="#Go-指针" class="headerlink" title="Go 指针"></a>Go 指针</h1><p><strong>指针式一种直接存储了变量的内存地址的数据类型。指针是可见的内存地址，<code>&amp;</code> 操作符可以返回一个变量的内存地址，并且 <code>*</code> 操作符可以获取指针指向的变量内容，但是在 Go 语言里没有指针运算，也就是不能像 c 语言里可以对指针进行加减操作</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>  <br>   <span class="hljs-keyword">var</span> b = &amp;a  <br>   fmt.Printf(<span class="hljs-string">&quot;a:%d, ptr:%p, type:%T\n&quot;</span>, a, &amp;a, a) <span class="hljs-comment">// a:10, ptr:0xc0000b2008, type:*int  </span><br>   fmt.Printf(<span class="hljs-string">&quot;b:%d, ptr:%p, type:%T\n&quot;</span>, b, b, b)  <span class="hljs-comment">// b:824634449928, ptr:0xc0000b2008, type:*int  </span><br>   fmt.Printf(<span class="hljs-string">&quot;&amp;b:%d, ptr:%p\n&quot;</span>, *b, &amp;b)           <span class="hljs-comment">// &amp;b:10, ptr:0xc0000ac018  </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p><code>new</code> 是一个内置函数<br>定义: <code>func new(Type) *Type</code></p><ul><li>Type 表示类型，new 函数只接受一个参数，该参数是一个类型</li><li>*Type 表示类型指针，new 函数返回一个指向该类型内存地址的指针</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白夜行</title>
    <link href="/posts/230107/"/>
    <url>/posts/230107/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 白夜行</p><ul><li><img src="https://weread-1258476243.file.myqcloud.com/weread/cover/7/230107/t7_230107.jpg" alt=" 白夜行|200"></li><li>书名： 白夜行</li><li>作者： 东野圭吾</li><li>简介： 1999年，东野圭吾41岁正值盛年，写作出道已14年，在笔力、技巧、体力和雄心上都炉火纯青，于是洋洋洒洒写出了这部鸿篇巨制《白夜行》。这种规模宏大的长篇作品在职业作家一生的创作中极为罕见，完成后基本都被视为生涯代表作。《白夜行》一经推出即成为东野圭吾的长篇小说代表作，被万千书迷视为东野圭吾作品中的无冕之·王，畅销至今。《白夜行》中文版发行量超600万册，和《嫌疑人X的献身》《恶意》《解忧杂货店》并称为东野圭吾四大杰作。</li><li>出版时间 2017-07-21 00:00:00</li><li>ISBN： 9787544291163</li><li>分类： 精品小说-悬疑推理</li><li>出版社： 南海出版公司</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><h2 id="9-1"><a href="#9-1" class="headerlink" title="9"></a>9</h2><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6"></a>6</h2><h3 id="划线评论"><a href="#划线评论" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 一个男子  ^7570425-6QkBvOFoi<ul><li>💭 感觉这里的这个男子像是桐原</li><li>⏱ 2017-05-09 21:02:44</li></ul></li></ul><h2 id="7-1"><a href="#7-1" class="headerlink" title="7"></a>7</h2><h3 id="划线评论-1"><a href="#划线评论-1" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 “清华有个姓仓桥的女人吧，仓桥香苗？”  ^7570425-6QkBMwD57<ul><li>💭 这里感觉是桐原和穗他们将江利子抓了，然后嫁祸给仓桥，但是又不明说，让一成来自己猜，可怕</li><li>⏱ 2017-05-09 21:06:51</li></ul></li></ul><h2 id="8-1"><a href="#8-1" class="headerlink" title="8"></a>8</h2><h3 id="划线评论-2"><a href="#划线评论-2" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 “你说的难道是……”  ^7570425-6QkC3LGDc<ul><li>💭 果然和我想的一样，感觉好重的心机啊</li><li>⏱ 2017-05-09 21:11:06</li></ul></li></ul><h2 id="9-2"><a href="#9-2" class="headerlink" title="9"></a>9</h2><h3 id="划线评论-3"><a href="#划线评论-3" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 银行发生了盗领事件。存款人在毫不知情的状况下，户头遭到盗领。受害者是东京都内的上班族，本月十日到银行柜台提领存款时，发现应有两百万元左右的余额变成零。调查结果发现，存款是于三协银行府中分行由银行卡分七次提领，最后一次提款是四月二十二日。被害人是在银行推广下，于一九七九年办理银行卡，但卡片一直放在办公室的办公桌内，从未使用。警方研判极有可能是银行卡遭到伪造，现正展开调——”  ^7570425-6QkDHzpZW<ul><li>💭 这一段和后面的关掉电视都 说明了这里埋了一个伏笔，而且在后面会有重要的描写</li><li>⏱ 2017-05-09 21:36:10</li></ul></li></ul><h2 id="9-3"><a href="#9-3" class="headerlink" title="9"></a>9</h2><h3 id="划线评论-4"><a href="#划线评论-4" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 黑色西装的年轻男子  ^7570425-6QlBlEDko<ul><li>💭 看样子，这里的男子应该也是桐原，而且电话被监听应该确定了</li><li>⏱ 2017-05-10 12:46:54</li></ul></li></ul><h2 id="6-2"><a href="#6-2" class="headerlink" title="6"></a>6</h2><h3 id="划线评论-5"><a href="#划线评论-5" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 一个男孩与一个女孩手牵手的图案。男孩戴着帽子，女孩头上系着大大的蝴蝶结，非常精致  ^7570425-6QlDDEGxY<ul><li>💭 这个不就是书的封面么</li><li>⏱ 2017-05-10 13:21:53</li></ul></li></ul><h3 id="划线评论-6"><a href="#划线评论-6" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 一把剪刀，刀刃部分长达十余厘米，前端相当锐利。  ^7570425-6QlDAGO3n<ul><li>💭 ‘‘’细而锐利的刀刃，可能比水果刀更窄一点。‘’ 很像是杀死他父亲的啊</li><li>⏱ 2017-05-10 13:21:09</li></ul></li></ul><h3 id="划线评论-7"><a href="#划线评论-7" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 白夜里走路  ^7570425-6QlDalRjU<ul><li>💭 白夜走路，所以才叫白夜行么</li><li>⏱ 2017-05-10 13:14:40</li></ul></li></ul><h2 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h2><h3 id="划线评论-8"><a href="#划线评论-8" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 从新婚起，他们就分床睡，雪穗睡单人床。  ^7570425-6QlFZOeT7<ul><li>💭 新婚就分床睡？感觉 怪怪的</li><li>⏱ 2017-05-10 13:57:52</li></ul></li></ul><h2 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h2><h3 id="划线评论-9"><a href="#划线评论-9" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 氰化钾  ^7570425-6QmmSt2cR<ul><li>💭 看来是这个害死的今枝，那个侦探</li><li>⏱ 2017-05-11 00:52:37</li></ul></li></ul><h2 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h2><h3 id="划线评论-10"><a href="#划线评论-10" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 不久，一些鬼鬼祟祟的男人就常往这里跑，进大楼的时候还偷偷摸摸的，怕别人看到。一开始，我不知道在大楼里能干吗，问别的小孩，也没人知道，大人也不肯告诉我们。不过没多久，就有人搜集到消息了。他说那里好像是男人买女人的地方，只要付一万  ^7570425-6QmSsi9R8<ul><li>💭 这里是最开始的时候 的那个一万卖身的地方吧，从这里开始 ，应该慢慢的填坑了</li><li>⏱ 2017-05-11 08:54:47</li></ul></li></ul><h2 id="13-1"><a href="#13-1" class="headerlink" title="13"></a>13</h2><h3 id="划线评论-11"><a href="#划线评论-11" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 老公的兴趣  ^7570425-6QmV6M7ea<ul><li>💭 看到那个洋介，当铺老板是喜欢幼女，所以应该可以推出，是她把雪穗给强奸了，才会有后面的故事吧</li><li>⏱ 2017-05-11 09:35:17</li></ul></li></ul><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>精品小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脂砚斋评石头记（全集）</title>
    <link href="/posts/814416/"/>
    <url>/posts/814416/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 脂砚斋评石头记（全集）</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/416/814416/t7_814416.jpg" alt=" 脂砚斋评石头记（全集）|200"></li><li>书名： 脂砚斋评石头记（全集）</li><li>作者： 曹雪芹 脂砚斋评</li><li>简介：     《石头记》是中国古代小说的之作，从传抄面世之初，各个抄本上都保留了大量的朱红色批语，一些重要的传抄版本上题有《脂砚斋重评石头记》的字样，所以后人便称这些早期的《红楼梦》抄本为“脂评本”或“脂批本”。</li></ul></blockquote><blockquote><ul><li>出版时间 2016-03-21 00:00:00</li><li>ISBN： </li><li>分类： 历史-历史典籍</li><li>出版社： 阅文集团</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="第二回-贾夫人仙逝扬州城-冷子兴演说荣国府"><a href="#第二回-贾夫人仙逝扬州城-冷子兴演说荣国府" class="headerlink" title="第二回 贾夫人仙逝扬州城 冷子兴演说荣国府"></a>第二回 贾夫人仙逝扬州城 冷子兴演说荣国府</h2><ul><li>📌 以百回之大文，先以此回作两大笔以冒之，诚是大观。世态人情，尽盘旋于其间，而一线不乱，非具龙象力者其孰能哉。此回亦非正文，本旨只在冷子兴一人，即俗谓冷中出热、无中生有也。其演说荣府一篇者，盖因族大人多，若从作者笔下一一叙出，尽一二回不能得明，则成何文字。故借用冷子一人，略出其大半，使阅者心中已有一荣府隐隐在心。然后用黛玉、宝钗等两三次皴染，则耀然于心中眼中矣。此即画家三染法也。未写荣府正人，先写外戚，是由远及近，由小至大也。若使先叙出荣府，然后一一叙及外戚，又一一至朋友，至奴仆，其死板拮据之笔，岂作十二钗人手中之物也。今先写外戚者，正是写荣国一府也。故又怕闲文赘累，开笔即先写贾夫人已死，是特使黛玉入荣之速也。通灵宝玉于士隐梦中一出，今（又）于子兴口中一出，阅者已洞然矣。然后于黛玉、宝钗二人目中，极精极细一描，则是文章锁合处。盖不肯一笔直下，有若放闸之水，燃信之爆，使其精华一泄而无余也。究竟此玉原应出自钗、黛目中，方有照应。今预从子兴口中说出，实虽写而却未写。观其后文可知，此一回则是虚敲旁击之文，笔则是反逆隐曲之笔。诗云： ^814416-4-860<ul><li>⏱ 2018-07-21 12:48:44</li></ul></li></ul><h2 id="第十二回-王熙凤毒设相思局-贾天祥正照风月鉴"><a href="#第十二回-王熙凤毒设相思局-贾天祥正照风月鉴" class="headerlink" title="第十二回 王熙凤毒设相思局 贾天祥正照风月鉴"></a>第十二回 王熙凤毒设相思局 贾天祥正照风月鉴</h2><ul><li>📌 贾瑞侧耳听着，半日不见人来，忽听“咯噔”一声，东边的门也倒关了。[平平略施小计。]贾瑞急的也不敢则声，只得悄悄的出来，将门撼了撼，关的铁桶一般。[此大抵是凤姐调遣，不先为点明者，可以少许多事故，又可以藏拙。]此时要求出去，亦不能够。南北皆是大房墙，要跳亦无攀援。这屋内又是过门风，空落落的。现是腊月天气，夜又长，朔风凛凛，侵肌裂骨，一夜几乎不曾冻死。[可为偷情一戒。][教导之法，慈悲之心尽矣，无奈迷途不悟何！]好容易盼到早晨，只见一个老婆子先将东门开了，进来去叫西门。贾瑞瞅他背着脸，一溜烟抱着肩竟跑了出来。幸而天气尚早，人都未起，从后门一径跑回家去。原来贾瑞父母早亡，只有他祖父代儒教养。那代儒素日教训最严，[教训最严，奈其心何。一叹！]不许贾瑞多走一步，生怕他在外吃酒赌钱，有误学业。今忽见他一夜不归，只料定他在外非饮即赌，嫖娼宿妓，[展转灵活，一人不放，一笔不肖。]那里想到这段公案！[世人万万想不到，况老学究乎！]因此气了一夜。贾瑞也捻着一把汗，少不得回来撒谎，只说：“往舅舅家去了，天黑了，留我住了一夜。”代儒道：“自来出门，非禀我不敢擅出，如何昨日私自去了？据此亦该打，何况是撒谎。”因此，发狠到底打了三四十板，[教令何尝不好，业种故此不同。]不许吃饭，令他跪在院内读文章，定要补出十天的工课来方罢。[处处点父母痴心，子孙不肖。此书系自愧而成。]贾瑞直冻了一夜，今又遭了苦打，且饿着肚子，跪在风地里读文章， [祸福无门，惟人自招。 ^814416-14-2588<ul><li>⏱ 2018-12-18 08:44:02</li></ul></li></ul><h2 id="第十六回-贾元春才选凤藻宫-秦鲸卿夭逝黄泉路"><a href="#第十六回-贾元春才选凤藻宫-秦鲸卿夭逝黄泉路" class="headerlink" title="第十六回 贾元春才选凤藻宫 秦鲸卿夭逝黄泉路"></a>第十六回 贾元春才选凤藻宫 秦鲸卿夭逝黄泉路</h2><ul><li>📌 ]笑道：“你能在这一行么？[勾下文。]这个事虽不算甚大，里头大有藏掖的。”[射利人微露心迹。][射利语，可叹是亲侄。]贾蔷笑道：“只好习学着办罢了。”贾蓉在身后灯影下悄拉凤姐衣襟，凤姐会意，因笑道：“你也太操心了，难道大爷比咱们还不会用人？偏你又怕他不在行了，谁都是在行的！孩子们已长的这么大了，没吃过猪肉，也看见过猪跑。大爷派他去，原不过是个坐纛旗儿，难道认真的叫他去讲价钱会经纪去呢！依我说就很好。”贾琏道：“自然是这样，并不是我驳回，少不得替他算计算计。”因问：“这一项银子动那一处的？”贾蔷道：“才也议到这里。赖爷爷说，[此等称呼，令人酸鼻。][好称呼。]不用从京里带下去，江南甄家还收着我们五万银子。明日写一封书信会票我们带去，先支三万，下剩二万存着，等置办花烛彩灯并各色帘栊帐幔的使费。”贾琏点头道：“这个主意好。”[《石头记》中多作心传神会之文，不必道明，一道明白，便入庸俗之套。]凤姐忙向贾蔷道：[再不略让一步，正是阿凤一生短处。]“既这样，我有两个在行妥当人，你就带他们去办，这个便宜了你呢。”贾蔷忙陪笑道：“正要和婶子讨两个人呢，[写贾蔷乖处。]这可巧了。”因问名字，凤姐便问赵嬷嬷。彼时赵嬷嬷已听呆了话，平儿忙笑推他，他才醒悟过来，[真是强将手下无弱兵。至精至细。]忙说：“一个叫赵天梁，一个叫赵天栋。”凤姐道：“可别忘了，我可干我的去了。”说着便出去了。贾蓉忙送出来，又悄悄向凤姐道：“婶子要带什么东西，吩咐开个帐，给蔷兄弟带了去，叫他按帐置办了来。” ^814416-18-12090<ul><li>⏱ 2019-01-25 21:45:24</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>历史</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美元真相</title>
    <link href="/posts/39481983/"/>
    <url>/posts/39481983/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 美元真相</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/983/39481983/t7_39481983.jpg" alt=" 美元真相|200"></li><li>书名： 美元真相</li><li>作者： 达尔辛妮·大卫</li><li>简介： 为什么我们比父辈买得起更多衣服，却买不起房子？为什么国际油价在跌，汽油价格却不跟着跌？为什么奢侈品国外卖那么便宜，到国内却贵那么多？为什么俄罗斯人喜欢到德国买房？这一切日常问题的背后力量都是经济。跟随1美元的环球流通之旅，我们可以把小问题和大道理联系起来。在这本通俗易懂的经济学读物中，经济学家达尔辛妮·大卫跟随1美元从一个消费者到另一个消费者的足迹，以旁观者的口吻讲述了全球化世界运转的规律，深入浅出地揭示了全球化、贸易战、国债、关税、汇率等经济学基本概念，剖析了全球各国间的关系；用直观形象的写作手法，揭示了全球化世界究竟是如何运行的。这本书以一种有趣而有启发性的方式解读经济现象，让对经济学完全没有概念的我们也能轻松理解全球经济。</li><li>出版时间 2021-06-01 00:00:00</li><li>ISBN： 9787521728774</li><li>分类： 经济理财-财经</li><li>出版社： 中信出版社</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="第7章-混合家庭的实验：从俄罗斯到德国"><a href="#第7章-混合家庭的实验：从俄罗斯到德国" class="headerlink" title="第7章 混合家庭的实验：从俄罗斯到德国"></a>第7章 混合家庭的实验：从俄罗斯到德国</h2><ul><li>📌 华尔特·罗斯托起飞模型 ^39481983-11-3397-3408<ul><li>⏱ 2022-04-03 09:48:02</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>经济理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构性改革</title>
    <link href="/posts/33362049/"/>
    <url>/posts/33362049/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 结构性改革</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/49/33362049/t7_33362049.jpg" alt=" 结构性改革|200"></li><li>书名： 结构性改革</li><li>作者： 黄奇帆</li><li>简介： 恰逢百年未有之大变局，经济转型发展、中美贸易摩擦、新冠疫情暴发等问题交相叠加，无不考验着我国面对复杂问题的智慧和勇气，供给侧结构性改革的重要性与紧迫性空前凸显。这本书从基础性、结构性、机制性、制度性等多个维度，深入剖析我国供给侧关键矛盾并对症下药。 全书一共七章。第 一章详解如何紧抓供给侧结构性改革主线；第二章聚焦去杠杆与金融风险防范；第三章解读新时代下我国资本市场高质量发展之路；第四章讲述“数字化”如何重塑经济社会生态；第五章对房地产长效调控机制开出药方，并预判今后十年房地产行业六大趋势；第六章着眼于国有企业资本运作与地方政府营商环境改善；第七章阐释新局面、新特征下，我国对国际形势与中美关系的应对之道，深入剖析“双循环”新格局。</li><li>出版时间 2020-08-01 00:00:00</li><li>ISBN： 9787521718645</li><li>分类： 经济理财-财经</li><li>出版社： 中信出版社</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="序一-一部为解决经济难题提供对策的好书"><a href="#序一-一部为解决经济难题提供对策的好书" class="headerlink" title="序一 一部为解决经济难题提供对策的好书"></a>序一 一部为解决经济难题提供对策的好书</h2><ul><li>📌 人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾 ^33362049-4-839-867<ul><li>⏱ 2021-01-23 15:52:09</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>经济理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哲学家们都干了些什么</title>
    <link href="/posts/821598/"/>
    <url>/posts/821598/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 哲学家们都干了些什么</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/598/821598/t7_821598.jpg" alt=" 哲学家们都干了些什么|200"></li><li>书名： 哲学家们都干了些什么</li><li>作者： 林欣浩</li><li>简介：     “哲学史写得这么浅白风趣八卦，你让我们哲学系的人还怎么混？！”用穷凶极恶的吐槽和喜闻乐见的八卦，彻底瓦解你对哲学史的成见，翻开任何一页，都是欲罢不能的哲学故事。来吧，哲学家们！自己说说看，你们究竟都干了些什么？宇宙的外面是什么？世界会不会是假的？上帝到底存在还是不存在？这个世界有没有终极真理？……你知道吗，你想过或者没想过的这些奇形怪状的问题，早在几千年前就被哲学家们一本正经地提出，挖空心思地找证据，面红耳赤地争论过了。在整个世界忙着探索、发展的漫长历史中，这帮哲学家们却神经质地死磕这个世界的真相和人生的意义，就好像一个网络游戏里的角色试图琢磨自己手里武器的代码是什么……</li></ul></blockquote><blockquote><ul><li>出版时间 2015-04-01 00:00:00</li><li>ISBN： 9787550242234</li><li>分类： 哲学宗教-哲学读物</li><li>出版社： 北京联合出版公司</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1><h2 id="书评-No-1"><a href="#书评-No-1" class="headerlink" title="书评 No.1"></a>书评 No.1</h2><p>哲学的科普书还是得可以，看完使我对哲学感到了兴趣。<br>以前觉得哲学的作用只是为了问那三个问题：<br>我是谁？我从哪里来？我到哪里去？<br>看完后觉得哲学是对世间所有的问题都去寻找一个最终的答案  ^7570425-7nS6FGNZh<br>⏱ 2021-02-04 23:06:40</p><h2 id="书评-No-2"><a href="#书评-No-2" class="headerlink" title="书评 No.2"></a>书评 No.2</h2><p> ^7570425-7nS6goplV<br>⏱ 2021-02-04 23:00:27</p>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>哲学宗教</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何阅读一本书</title>
    <link href="/posts/856735/"/>
    <url>/posts/856735/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 如何阅读一本书</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/735/856735/t7_856735.jpg" alt=" 如何阅读一本书|200"></li><li>书名： 如何阅读一本书</li><li>作者： 轻阅读编写组</li><li>简介： 读懂一本书，精于一件事，好方法比努力更重要。这是一本可靠的阅读技巧训练手册！每天8分钟，让你读得快、记得牢、学得透。林语堂、余秋雨、周国平倾情推荐你学会阅读！</li><li>出版时间 2017-03-01 00:00:00</li><li>ISBN： 9787513911504</li><li>分类： 生活百科-育儿</li><li>出版社： 民主与建设出版社</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="Why：为什么要阅读"><a href="#Why：为什么要阅读" class="headerlink" title="Why：为什么要阅读"></a>Why：为什么要阅读</h2><ul><li>📌 “读史使人明智，读诗使人灵秀，数学使人周密，物理学使人深刻，伦理学使人庄重，逻辑修辞之学则使人善辩：凡有所学，皆成性格。 ^856735-6-1626-1686<ul><li>⏱ 2017-06-22 12:45:13</li></ul></li></ul><h2 id="How：如何阅读一本书"><a href="#How：如何阅读一本书" class="headerlink" title="How：如何阅读一本书"></a>How：如何阅读一本书</h2><ul><li>📌 1．以缺乏时间为借口拒绝读书的人，需要更强烈的阅读动机和更有效的阅读方法。2．因旁人的眼光而拒绝读书的人，需要更强的专注力。3．只买书来读的人，需要警惕“藏而不读”。4．书非读完不可的人可以试着学会略读，用来处理分明不喜欢、心中却放不下的书。5．从不在书上涂画的人可以尝试边读边写，从现在起，拿起笔来阅读。6．只读不评，阅读的效果会减少一半。阅读虽是个人行为，本质却是交流。7．书可以多次阅读，但在不懂之处不断回读，并不是最好的解决办法。8．逐字逐句地阅读，是低效的阅读方式。也许你并不如自己想象中那么认真。9．读过就忘，说明阅读的效果还不佳，需要加强记忆与理解。10．只读经典或许会使人陷入误区，也容易让人产生阅读上的优越感。对于关注的主题，还是广泛阅读更好。 ^856735-9-1144-1736<ul><li>⏱ 2017-06-23 09:10:34</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>生活百科</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单之美：软件开发实践者的思考</title>
    <link href="/posts/602534/"/>
    <url>/posts/602534/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 简单之美：软件开发实践者的思考</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/534/602534/t7_602534.jpg" alt=" 简单之美：软件开发实践者的思考|200"></li><li>书名： 简单之美：软件开发实践者的思考</li><li>作者： 倪健</li><li>简介： 本书不是一本关于方法论的理论性书籍（尽管已经尝试在大量的思考上进行一些理论归纳），也不是一本关于具体技术的操作手册。本书为读者呈现的是作者在软件开发实践中的思考和体验，目的在于探究实践中的问题的根源，并给出思想上的解决之道。本书以软件开发的基本顺序为主线，以简单、想象和文化的开发思想为线索，以为软件开发实践提供指导价值为目标。本书力图做到传递经过组织的、可操作的软件开发经验，使软件开发领域的新手在知识（软件开发思想）积累过程中少走弯路，也使软件开发领域的老手可以对照自己的经验把可能的困惑降到最低。有一些有趣例子为那些有价值的思考提供支持。本书中，作者尝试对简单、想象和文化做一些形而上的思考。这些思考会比较抽象，但却是很多话题的基础。</li><li>出版时间 2010-04-01 00:00:00</li><li>ISBN： 9787111301035</li><li>分类： 计算机-计算机综合</li><li>出版社： 机械工业出版社</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>📌 什么样的信息是有效的呢？简洁明确的思想表述；层次清晰的分类信息；令人信服的论证过程。 ^602534-4-6199-6317<ul><li>⏱ 2017-07-11 09:46:17</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>东周列国志：中国古典白话短篇小说的巅峰</title>
    <link href="/posts/814401/"/>
    <url>/posts/814401/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 东周列国志：中国古典白话短篇小说的巅峰</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/401/814401/t7_814401.jpg" alt=" 东周列国志：中国古典白话短篇小说的巅峰|200"></li><li>书名： 东周列国志：中国古典白话短篇小说的巅峰</li><li>作者： 冯梦龙</li><li>简介： 《东周列国志》是明代著名白话历史演义小说，以春秋五霸和战国七雄为主线，描写了西周末年到秦统一六国五百多年间的璀璨历史，其场面之宏大，跨度之久，事件之复杂，人物之多，描绘之深刻，后世史书只能望其项背。一个个以时间为顺序串联的列国故事，把上起治国、强军、富民之道，下至为人、做事、相处之策兼包并蓄，成为后世评判是非成败的标准和榜样，至今依然影响深远。</li><li>出版时间 2016-03-21 00:00:00</li><li>ISBN： </li><li>分类： 文学-古典文学</li><li>出版社： 阅文集团</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="第四回-秦文公郊天应梦-郑庄公掘地见母"><a href="#第四回-秦文公郊天应梦-郑庄公掘地见母" class="headerlink" title="第四回 秦文公郊天应梦 郑庄公掘地见母"></a>第四回 秦文公郊天应梦 郑庄公掘地见母</h2><ul><li>📌 白帝 ^814401-6-1738-1740<ul><li>⏱ 2017-06-12 19:02:50</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h2 id="第四回-秦文公郊天应梦-郑庄公掘地见母-1"><a href="#第四回-秦文公郊天应梦-郑庄公掘地见母-1" class="headerlink" title="第四回 秦文公郊天应梦 郑庄公掘地见母"></a>第四回 秦文公郊天应梦 郑庄公掘地见母</h2><h3 id="划线评论"><a href="#划线评论" class="headerlink" title="划线评论"></a>划线评论</h3><ul><li>📌 白帝  ^7570425-6RacblmGI<ul><li>💭 白帝是秦文公   那么 秦始皇是白帝的后裔 ，刘邦 灭秦    有趣的是 刘备死在白帝城  传说中的天理循环？</li><li>⏱ 2017-06-12 19:02:51</li></ul></li></ul><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>文学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苏格兰女王的悲剧（玛丽·斯图亚特传）</title>
    <link href="/posts/816218/"/>
    <url>/posts/816218/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 苏格兰女王的悲剧（玛丽·斯图亚特传）</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/218/816218/t7_816218.jpg" alt=" 苏格兰女王的悲剧（玛丽·斯图亚特传）|200"></li><li>书名： 苏格兰女王的悲剧（玛丽·斯图亚特传）</li><li>作者： 斯蒂芬·茨威格</li><li>简介： 本书是奥地利著名作家斯蒂芬·茨威格具有代表性的人物传记作品之一，茨威格的作品以刻画人物内心活动著称。本版由国内著名翻译家侯焕闳老师翻译并重新修订，其翻译作品一直受到国内读者高度认可和好评。本书对苏格兰女王玛丽·斯图亚特一生做了精彩而又深入细致的剖析，既充分展示了她跌宕起伏、命远多舛的女王生涯，又生动深刻地刻画了她作为一个女人对爱情飞蛾扑火般的执着追求。玛丽·斯图亚特，十六世纪宗教改革时期苏格兰的女王，出生六天便继承了苏格兰王位，十六岁时获得法国王后、苏格兰女王、英格兰女王三顶王冠，荣耀一时。十九岁时返回苏格兰亲政，后因宗教矛盾的激化以及涉嫌参与谋杀她的丈夫而引起苏格兰贵族的不满。</li><li>出版时间 2014-07-01 00:00:00</li><li>ISBN： 9787547030028</li><li>分类： 人物传记-女性人物</li><li>出版社： 万卷出版公司</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h2><ul><li>📌 [插图] ^816218-1-376<ul><li>⏱ 2018-02-07 09:06:02</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>人物传记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嫌疑人X的献身</title>
    <link href="/posts/230110/"/>
    <url>/posts/230110/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 嫌疑人X的献身</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/110/230110/t7_230110.jpg" alt=" 嫌疑人X的献身|200"></li><li>书名： 嫌疑人X的献身</li><li>作者： 东野圭吾</li><li>简介： 日本推理小说天王、直木奖得主东野圭吾“迄今为止最高杰作”，创造了日本推理小说史上绝无仅有的奇迹，将第134届直木奖、第6届本格推理小说大奖及当年度日本三大推理小说排行榜第一名全部收入囊中。百年一遇的数学天才石神，每天都去固定的便当店买午餐，只为看一眼在那里做事的邻居靖子。与女儿相依为命的靖子，失手杀了上门纠缠勒索的前夫。为救靖子，石神挺身料理善后，以数学家缜密的逻辑思考设了一个匪夷所思的局，以令人惊骇莫名的诡计诠释了一份无比真挚纯粹的爱情……”</li><li>出版时间 2010-01-01 00:00:00</li><li>ISBN： 9787544245555</li><li>分类： 精品小说-悬疑推理</li><li>出版社： 南海出版公司</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ul><li>📌 的衣物。衣物塞在一斗深的桶里，遭到部分焚烧，包括外套、毛衣、长裤、袜子和内衣。应是凶手点火后立即离去，没想到衣物并未继续燃烧，火很快就熄灭了。专案组并未提议针对这些衣物清查制造厂商，这些衣物显然属于批量生产的成衣。画像技术人员根据衣物和死者的体格，画出了被害者生前的模样。一些调查人员拿着这张图，以筱崎车站为中心四处收集相关信息。可能是这样的服装实在不够惹眼，几圈下来并未打听到任何有用的信息。新闻节目中也发布了这张肖像图，不久倒是收到了一大堆线索，但是没有一个能和尸体扯上关系。另外，警方针对报失人口进行了认真的比对，但没找到任何线索。接着，警方以江户川区为中心，彻底清查附近是否有近期失踪的独居男子，或是突然失踪的旅馆房客。最后，终于得到一条线索。位于龟户的出租旅馆扇屋，有一名房客失踪了。旅馆是在三月十一日发现房客失踪的，也就是尸体被人发现那天。由于已过了退房时间，旅馆员工只好去房间查看，却只看到少许行李，人不见踪影。由于经营者事先收了房钱，因而并未报警。警方立刻从房间和行李上采集到毛发与指纹，竟与尸体的完全一致！此外，从自行车上采到的指纹之一，也与房间行李上留下的指纹完全相同！失踪客人在旅馆登记簿上留下的姓名为“富樫慎二”，住 ^230110-5-5708<ul><li>⏱ 2017-05-14 02:30:49</li></ul></li></ul><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1><h2 id="书评-No-1"><a href="#书评-No-1" class="headerlink" title="书评 No.1"></a>书评 No.1</h2><p>比上一本有趣些 ^7570425-6QorcZUL0<br>⏱ 2017-05-12 09:32:06</p>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>精品小说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>货币论（全两册）</title>
    <link href="/posts/184066/"/>
    <url>/posts/184066/</url>
    
    <content type="html"><![CDATA[<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 货币论（全两册）</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/66/184066/t7_184066.jpg" alt=" 货币论（全两册）|200"></li><li>书名： 货币论（全两册）</li><li>作者： 凯恩斯</li><li>简介： 通货膨胀永远是、而且在任何地方都只是一种货币现象。</li></ul></blockquote><blockquote><ul><li>出版时间 2008-07-01 00:00:00</li><li>ISBN： 9787561342299</li><li>分类： 经济理财-财经</li><li>出版社： 陕西师范大学出版社</li></ul></blockquote><h1 id="高亮划线"><a href="#高亮划线" class="headerlink" title="高亮划线"></a>高亮划线</h1><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="章节评论-No-1"><a href="#章节评论-No-1" class="headerlink" title="章节评论 No.1"></a>章节评论 No.1</h3><ul><li>嗯嗯，货币是一个国家的信用，那么因此会具有不稳定性，因此我觉得马克思在这里说是天然货币是指，金银在货币上的稳定性，所以金银天生就可以当做货币 ^7570425-6TbkybtDI<ul><li>⏱ 2017-09-03 01:24:27</li></ul></li></ul><h1 id="本书评论"><a href="#本书评论" class="headerlink" title="本书评论"></a>本书评论</h1>]]></content>
    
    
    <categories>
      
      <category>微信读书</category>
      
      <category>经济理财</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
